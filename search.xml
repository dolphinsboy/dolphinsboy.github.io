<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL set variable的源码实现分析]]></title>
    <url>%2F2018-09-04-MySQL-set-variables%E7%9A%84%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[背景项目在使用Inception的时候，对于大表需要考虑对延迟的控制，会使用到pt-online-schema-change的–recursion-method。公司在使用RDS数据库，故对于osc只能使用–recursion-method=dsn这种方式。目前inception不支持这种方式，故研究其代码。同时也是对MySQL set variable这个SQL对应的背后知识有源码层次的了解。 MySQL gdb调试1gdb --args /usr/local/mysql/bin/Inception --defaults-file=/usr/local/mysql/etc/inception.cnf 针对gdb过程中遇到的 optimized out，参照How to compile without optimizations -O0 using CMake进行处理。选择方式在CMakeLists.txt中加入: 12SET(CMAKE_CXX_FLAGS &quot;-O0&quot;)SET(CMAKE_C_FLAGS &quot;-O0&quot;) 以枚举变量为例变量类型 作用域 类型 存储地方 涉及文件 Session SESSION_VAR struct system_variables sql/sql_class.h Global GLOBAL_VAR 按照类型存储 sql/mysqld.cc和sql/mysqld.h set variable调用关系12345678910111213141516171819(gdb) bt#0 find_type (lib=0xfdf370 &lt;Sys_inception_osc_recursion_method+208&gt;, find=0x7ffff0004c00 "processlist", length=11, part_match=false) at /opt/source/inception/sql/strfunc.cc:123#1 0x0000000000707d0f in Sys_var_typelib::do_check (this=0xfdf2a0 &lt;Sys_inception_osc_recursion_method&gt;, thd=0x1005f40, var=0x7ffff0004cc0) at /opt/source/inception/sql/sys_vars.h:288#2 0x00000000006299b4 in sys_var::check (this=0xfdf2a0 &lt;Sys_inception_osc_recursion_method&gt;, thd=0x1005f40, var=0x7ffff0004cc0) at /opt/source/inception/sql/set_var.cc:213#3 0x000000000062a742 in set_var::check (this=0x7ffff0004cc0, thd=0x1005f40) at /opt/source/inception/sql/set_var.cc:624#4 0x00000000006a2fe1 in mysql_execute_inception_set_command (thd=0x1005f40) at /opt/source/inception/sql/sql_parse.cc:4219#5 0x00000000006a31a7 in mysql_execute_inception_command (thd=0x1005f40) at /opt/source/inception/sql/sql_parse.cc:4255#6 0x00000000006add22 in mysql_check_command (thd=0x1005f40) at /opt/source/inception/sql/sql_parse.cc:7794#7 0x00000000006b91e4 in mysql_process_command (thd=0x1005f40, parser_state=0x7ffff7fe8c80) at /opt/source/inception/sql/sql_parse.cc:11636#8 0x00000000006b9261 in mysql_parse (thd=0x1005f40, length=66, parser_state=0x7ffff7fe8c80) at /opt/source/inception/sql/sql_parse.cc:11664#9 0x000000000069ad11 in dispatch_command (command=COM_QUERY, thd=0x1005f40, packet=0x100a4d1 "inception set session inception_osc_recursion_method='processlist'", packet_length=66) at /opt/source/inception/sql/sql_parse.cc:1059#10 0x0000000000698a30 in do_command (thd=0x1005f40) at /opt/source/inception/sql/sql_parse.cc:489#11 0x0000000000673dd0 in do_handle_one_connection (thd_arg=0x1005f40) at /opt/source/inception/sql/sql_connect.cc:926#12 0x0000000000673b9a in handle_one_connection (arg=0x1005f40) at /opt/source/inception/sql/sql_connect.cc:842#13 0x00007ffff7bc6e25 in start_thread () from /lib64/libpthread.so.0#14 0x00007ffff6c96bad in clone () from /lib64/libc.so.6 在find_type中会对参数进行比较进行比较，判断字符串是否和符合预期，不符合预期报语法错误。 支持recursion_method代码分析在Inception中使用Sys_var_enum类型支持recursion_method的设置。这是一个枚举类型，只支持固定的值。 1234567const char *osc_recursion_method[]= &#123;"processlist", "hosts", "none", "dsn", NullS&#125;;static Sys_var_enum Sys_inception_osc_recursion_method( "inception_osc_recursion_method", "Preferred recursion method used to find slaves.", SESSION_VAR(inception_osc_recursion_method), CMD_LINE(REQUIRED_ARG), osc_recursion_method, DEFAULT(recursion_method_processlist), NO_MUTEX_GUARD, NOT_IN_BINLOG); 对osc_recursion_method加dsn之后，可以设置inception_osc_recursion_method为dsn，否则报错。 12345678910mysql&gt; inception set inception_osc_recursion_method='dsn';Query OK, 0 rows affected (2.88 sec)mysql&gt; inception get variables 'inception_osc_recursion_method';+--------------------------------+-------+| Variable_name | Value |+--------------------------------+-------+| inception_osc_recursion_method | dsn |+--------------------------------+-------+1 row in set (0.00 sec) 但是实际pt-osc在设置dsn为如下模式: 1dsn=h=192.40.120.26,P=4500,D=dpadmin,t=dsns_5627 这个不是一个固定的值，而是随着操作端口的不同，t的值是可以变化的，例如dsns_4300。所以这里无法使用enum类型的，如果支持这种的话，需要使用Sys_var_charptr类型。 将enum修改为string类型两者变量继承关系 Sys_var_charptr Sys_var_enum Sys_var_charptr只支持Global变量 修改代码 修改sql/mysqld.h 1extern char* inception_osc_recursion_method; 修改sql/mysqld.ccGlobal变量需要修改sql/mysqld.cc，Session级别变量在sql/sql_class.h中定义即可。 123//Added by Guosong 20180905 STARTchar* inception_osc_recursion_method= NULL;//Added by Guosong 20180905 END sql/sys_var.cc 123456789101112131415//Modified by Guosong START 20180905/*const char *osc_recursion_method[]= &#123;"processlist", "hosts", "none", "dsn", NullS&#125;;static Sys_var_charptr Sys_inception_osc_recursion_method( "inception_osc_recursion_method", "Preferred recursion method used to find slaves.", SESSION_VAR(inception_osc_recursion_method), CMD_LINE(REQUIRED_ARG), osc_recursion_method, DEFAULT("none"), NO_MUTEX_GUARD, NOT_IN_BINLOG);*/static Sys_var_charptr Sys_inception_osc_recursion_method( "inception_osc_recursion_method", "Preferred recursion method used to find slaves.", GLOBAL_VAR(inception_osc_recursion_method), CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG);//Modified by Guosong END 20190905 修改sql/sql_parse.cc 12sprintf(cmd_line, &quot;--recursion-method=%s&quot;, ¦ inception_osc_recursion_method); 测试 123456789101112131415161718192021mysql&gt; inception set inception_osc_recursion_method='processlist';Query OK, 0 rows affected (0.00 sec)mysql&gt; inception get variables 'inception_osc_recursion_method';+--------------------------------+-------------+| Variable_name | Value |+--------------------------------+-------------+| inception_osc_recursion_method | processlist |+--------------------------------+-------------+1 row in set (0.00 sec)mysql&gt; inception set inception_osc_recursion_method='dsn=h=10.40.120.26,P=4300,D=dpadmin,t=dsns_5627';Query OK, 0 rows affected (0.00 sec)mysql&gt; inception get variables 'inception_osc_recursion_method';+--------------------------------+-------------------------------------------------+| Variable_name | Value |+--------------------------------+-------------------------------------------------+| inception_osc_recursion_method | dsn=h=10.40.120.26,P=4300,D=dpadmin,t=dsns_5627 |+--------------------------------+-------------------------------------------------+1 row in set (0.00 sec) 参考 https://blog.csdn.net/slwang001/article/details/77343172 http://ourmysql.com/archives/945 https://www.cnblogs.com/cchust/p/3252117.html https://edu.aliyun.com/a/27029?spm=5176.11182482.0.0.Z8MZrV https://dev.mysql.com/doc/dev/mysql-server/8.0.12/classSys__var__enum.html]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
      <tags>
        <tag>MySQL内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mariadb原理和实现Notes]]></title>
    <url>%2F2018-08-31-Mariadb%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0Notes%2F</url>
    <content type="text"><![CDATA[背景学习Mariadb原理和实现，记录一些notes。 内存分配init_alloc_root测试 test.c 1234567891011121314#include &lt;stdio.h&gt;#include &lt;my_sys.h&gt;int main()&#123; MEM_ROOT mem_root; init_alloc_root(&amp;mem_root, 4096, 0, MY_THREAD_SPECIFIC); //char *p1 = (char*)alloc_root(&amp;mem_root, 128); //char *p2 = (char*)alloc_root(&amp;mem_root, 64); printf("HelloWorld!\n"); free_root(&amp;mem_root, 0); return 0;&#125; Makefile 12345678910MYSQL_INCLUDE= -I /home/guosong/source/mariadb-10.0.36/includeMYSQL_LIB = /home/guosong/source/mariadb-10.0.36/libmysql/libmysqlclient.aWALL = -fPIC -fno-exceptions -fno-rtti -g -DENABLED_DEBUG_SYNC -ggdb3 -DSAFE_MUTEX -DSAFEMALLOC -Wall -Wextra -Wformat-security -Wvla -Woverloaded-virtual -Wno-unused-parameter GCC=&quot;c++&quot;test:test.c $(GCC) -g $(WALL) -c test.c $(MYSQL_INCLUDE) $(GCC) -o test test.o $(MYSQL_LIB) -lpthread -lz -lm -ldl -lssl -lcrypto -ljemallocclean: rm -rf test *.o 方法 通过修改client/CMakeList.txt成功编译模拟编译此文件12MYSQL_ADD_EXECUTABLE(guosongtest guosongtest.c)TARGET_LINK_LIBRARIES(guosongtest mysqlclient) 然后查看其CMakeFiles/guosongtest.dir/link.txt找到其link的方式生成上面的Makefile gdb 123456789101112131415161718192021222324(gdb) l1 #include &lt;stdio.h&gt;2 #include &lt;my_sys.h&gt;34 int main()&#123;5 MEM_ROOT mem_root;6 init_alloc_root(&amp;mem_root, 4096, 4096, MY_THREAD_SPECIFIC);78 char *p1 = (char*)alloc_root(&amp;mem_root, 128);9 char *p2 = (char*)alloc_root(&amp;mem_root, 64);10 printf(&quot;HelloWorld!\n&quot;);(gdb) b 6Breakpoint 1 at 0x4025f8: file test.c, line 6.(gdb) sThe program is not being run.(gdb) rBreakpoint 1, main () at test.c:66 init_alloc_root(&amp;mem_root, 4096, 4096, MY_THREAD_SPECIFIC);(gdb) sinit_alloc_root (mem_root=0x7fffffffe040, block_size=4096, pre_alloc_size=4096, my_flags=65536) at /home/guosong/source/mariadb-10.0.36/mysys/my_alloc.c:6060 DBUG_ENTER(&quot;init_alloc_root&quot;);(gdb) bt#0 init_alloc_root (mem_root=0x7fffffffe040, block_size=4096, pre_alloc_size=4096, my_flags=65536) at /home/guosong/source/mariadb-10.0.36/mysys/my_alloc.c:60#1 0x0000000000402613 in main () at test.c:6]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django使用多个数据库]]></title>
    <url>%2F2018-07-10-Django%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[背景现在的Django项目需要使用到多个数据库，一个是Django自带的库，一个是元数据库。本文使用Django自带的ORM模式访问多个库。演示的项目基于SQL审核项目基础上添加个性化功能。 步骤创建新的appProject的当前路径为/data/web/AuditSQL，该Project存在多个app，统一放到一个目录下面。 1234567891011[root@qbj3-op-wiki-00 apps]# pwd /data/web/AuditSQL/apps[root@qbj3-op-wiki-00 apps]# tree -L 1.|-- dpadmin|-- __init__.py|-- mstats|-- project_manager|-- __pycache__|-- scheduled_tasks`-- user_manager 所有app放到固定的目录下，故在startapp的时候需要指定目录。 1python manage.py startapp dpadmin /data/web/AuditSQL/apps/dpadmin 将新app添加到project中修改AuditSQL/settings.py中INSTALLED_APPS添加如下： 12345INSTALLED_APPS = [ ... 'scheduled_tasks', 'dpadmin',] 修改DATABASES添加多个DB123456789101112131415161718192021222324252627282930313233DATABASES = &#123; #'default': &#123;&#125;, 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'auditsql', 'USER': 'root', 'HOST': 'localhost', 'PASSWORD': '123.com', 'OPTIONS': &#123; 'init_command': "SET sql_mode='STRICT_TRANS_TABLES'", 'charset': 'utf8mb4' &#125; &#125;, 'dpadmin': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'dpadmin', 'USER': 'dba', 'HOST': 'XXXXXXXXXXX', 'PORT': 4300, 'PASSWORD': 'XXXXXXXXXXXXXXXXXXX', 'OPTIONS':&#123; 'charset': 'utf8' &#125; &#125;&#125;#构建APP和DB的映射关系DATABASE_ROUTERS = ['AuditSQL.database_router.DatabaseAppsRouter']DATABASE_APPS_MAPPING = &#123; 'scheduled_tasks':'default', 'dpadmin': 'dpadmin'&#125; 添加路由关系在AuditSQL Project目录文件夹中创建database_router.py文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: utf-8 -*-from django.conf import settings DATABASE_MAPPING = settings.DATABASE_APPS_MAPPING class DatabaseAppsRouter(object): """ A router to control all database operations on models for different databases. In case an app is not set in settings.DATABASE_APPS_MAPPING, the router will fallback to the `default` database. Settings example: DATABASE_APPS_MAPPING = &#123;'app1': 'db1', 'app2': 'db2'&#125; """ def db_for_read(self, model, **hints): """"Point all read operations to the specific database.""" if model._meta.app_label in DATABASE_MAPPING: return DATABASE_MAPPING[model._meta.app_label] return None def db_for_write(self, model, **hints): """Point all write operations to the specific database.""" if model._meta.app_label in DATABASE_MAPPING: return DATABASE_MAPPING[model._meta.app_label] return None def allow_relation(self, obj1, obj2, **hints): """Allow any relation between apps that use the same database.""" db_obj1 = DATABASE_MAPPING.get(obj1._meta.app_label) db_obj2 = DATABASE_MAPPING.get(obj2._meta.app_label) if db_obj1 and db_obj2: if db_obj1 == db_obj2: return True else: return False return None # for Django 1.4 - Django 1.6 def allow_syncdb(self, db, model): """Make sure that apps only appear in the related database.""" if db in DATABASE_MAPPING.values(): return DATABASE_MAPPING.get(model._meta.app_label) == db elif model._meta.app_label in DATABASE_MAPPING: return False return None # Django 1.7 - Django 1.11 def allow_migrate(self, db, app_label, model_name=None, **hints): print db, app_label, model_name, hints if db in DATABASE_MAPPING.values(): return DATABASE_MAPPING.get(app_label) == db elif app_label in DATABASE_MAPPING: return False return None 通过inspectdb获取指定数据库对应models.py文件从Django文档中可知: 123--database DATABASESpecifies the database to introspect. Defaults to default. 默认只创建default，故创建dpadmin新APP对应的models.py文件命令如下: 12345#默认创建该库下面对应的所有表python manage.py inspectdb --database &apos;dpadmin&apos; &gt; models.py#创建指定表node_infopython manage.py inspectdb --database &apos;dpadmin&apos; node_info &gt; models.py 将该models.py拷贝到dpadmin新App下： 1mv models.py ./apps/dpadmin/models.py 测试使用shell交互模式进行测试，并使用ipython终端利于tab键提示和补全关键字： 12345678(venv_py36) [root@d89b6a65640c AuditSQL]# python manage.py shell -i ipythonPython 3.6.4 (default, May 17 2018, 06:03:23) Type 'copyright', 'credits' or 'license' for more informationIPython 6.4.0 -- An enhanced Interactive Python. Type '?' for help.In [1]: from dpadmin.models import NodeInfoIn [4]: NodeInfo.objects.count()Out[4]: 121 参考文档 Django 多数据库联用 Django inspectdb指定单个DB]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python性能分析]]></title>
    <url>%2F2018-05-18-Python%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Python性能分析 Python web 应用性能调优 Python profiling]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Profile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Graph 深度遍历]]></title>
    <url>%2F2018-05-18-graph-dfs%2F</url>
    <content type="text"><![CDATA[图表示 邻接矩阵 邻接链表 图遍历 BFS 使用队列 DFS 使用栈 DFS Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from collections import defaultdictclass Graph: def __init__(self): self.graph = defaultdict(list) def addEdge(self, u, v): self.graph[u].append(v) def DFSUtils(self, v, visited): visited[v] = True print(v) for i in self.graph[v]: if not visited[i]: self.DFSUtils(i, visited) def DFS(self, v): visited = [False] * len(self.graph) print("DFS results:") self.DFSUtils(v, visited) def BFS(self, v): visited = [False] * len(self.graph) queue = [v] visited[v] = True print("BFS results:") while queue: s = queue.pop(0) print(s, " ") for i in self.graph[s]: if not visited[i]: queue.append(i) visited[i] = Truedef main(): g = Graph() g.addEdge(0, 1) g.addEdge(0, 2) g.addEdge(1, 2) g.addEdge(2, 0) g.addEdge(2, 3) g.addEdge(3, 3) print("Following is DFS from (staring from vertex 2)") g.DFS(2) g.BFS(2)if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vimgdb]]></title>
    <url>%2F2018-04-09-vimgdb%2F</url>
    <content type="text"><![CDATA[说明单独使用gdb时候，需要通过另外一个窗口看代码。有点麻烦，所以产生了vimgdb，vim和gdb的结合。 配置vimgdb https://github.com/cpiger/vimgdb-for-vim7.4 https://blog.easwy.com/archives/advanced-vim-skills-vim-gdb-vimgdb-faq/ 检查vim是否包括gdb 12[guosong@dev-00 11:04:34 ~]$vim --version|grep gdb+cindent +gdb +multi_lang +termresponse 测试 启动vimgdb之后按space键 12file /home/guosong/mysql5627/bin/mysqldrun --defaults-file=/home/guosong/mysql5627/etc/my5627.cnf 打断点 1234b do_commandb dispatch_commandb mysql_parseb mysql_execute_command 使用截图 使用快捷键将屏幕竖着 12ctrl+wshift+l]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cache2go源码阅读]]></title>
    <url>%2F2018-03-14-cache2go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[背景介绍cache2go是具有并发安全golang缓存库，其key具有过期特性。本文研究其代码，学习Go的并发编程。 主要类和函数说明创建CacheTable创建以myCache为名字的CacheTable结构指针 12// Accessing a new cache table for the first time will create it.cache := cache2go.Cache("myCache") Cache在cache.go中进行定义。以myCache作为key的map，其value为CacheTable结构体指针，支持多个CacheTable，其对应的名字为string类型。 1cache = make(map[string]*CacheTable) 如果这个map中不存在myCache的话，重新创建一个。 123456789101112131415161718192021func Cache(table string) *CacheTable &#123; mutex.RLock() t, ok := cache[table] mutex.RUnlock() if !ok &#123; mutex.Lock() t, ok = cache[table] // Double check whether the table exists or not. if !ok &#123; t = &amp;CacheTable&#123; name: table, items: make(map[interface&#123;&#125;]*CacheItem), &#125; cache[table] = t &#125; mutex.Unlock() &#125; return t&#125; 这些涉及到RLock以及Lock，从而保证并行安全，RLock为读锁, Lock为互斥锁。判断以table为名对应CacheTable结构体是否存在使用RLock，如果不存在，使用Mutex进行创建。这里涉及到CacheTable以及CacheItem两个struct，其关系如下图。 CacheTableCacheTable定义1234567891011121314151617181920212223type CacheTable struct &#123; sync.RWMutex // The table's name. name string // All cached items. items map[interface&#123;&#125;]*CacheItem // Timer responsible for triggering cleanup. cleanupTimer *time.Timer // Current timer duration. cleanupInterval time.Duration // The logger used for this table. logger *log.Logger // Callback method triggered when trying to load a non-existing key. loadData func(key interface&#123;&#125;, args ...interface&#123;&#125;) *CacheItem // Callback method triggered when adding a new item to the cache. addedItem func(item *CacheItem) // Callback method triggered before deleting an item from the cache. aboutToDeleteItem func(item *CacheItem)&#125; CacheTable 结构体说明 成员 成员类型 说明 sync.RWMutex 继承一个读写锁 name string cacheTable名称 items map类型，key为任意类型，value为CacheItem cacheTable的各个item cleanupTimer time.Timer 定时器，用于过期处理 cleanupInterval time.Duration 定时扫描interval logger log.Logger 日志句柄 loadData function 回调函数，加载key使用 addedItem function 添加一个item，参数为CacheItem aboutToDeleteItem function 在删除item之前回调 CacheTable函数 Count 123456// Count returns how many items are currently stored in the cache.func (table *CacheTable) Count() int &#123; table.RLock() defer table.RUnlock() return len(table.items)&#125; 这里加读锁，返回map的长度，比较简单。 Foreach 123456789// Foreach all itemsfunc (table *CacheTable) Foreach(trans func(key interface&#123;&#125;, item *CacheItem)) &#123; table.RLock() defer table.RUnlock() for k, v := range table.items &#123; trans(k, v) &#125;&#125; Foreach读操作，遍历map，并使用trans回调函数进行处理。 Set Callback 12345678910111213141516171819202122// SetAddedItemCallback configures a callback, which will be called every time// a new item is added to the cache.func (table *CacheTable) SetAddedItemCallback(f func(*CacheItem)) &#123; table.Lock() defer table.Unlock() table.addedItem = f&#125;// SetAboutToDeleteItemCallback configures a callback, which will be called// every time an item is about to be removed from the cache.func (table *CacheTable) SetAboutToDeleteItemCallback(f func(*CacheItem)) &#123; table.Lock() defer table.Unlock() table.aboutToDeleteItem = f&#125;// SetLogger sets the logger to be used by this cache table.func (table *CacheTable) SetLogger(logger *log.Logger) &#123; table.Lock() defer table.Unlock() table.logger = logger&#125; 使用Mutex锁。 expirationCheck 每次过期检查的时候，使用table.Lock进行控制。 123456789101112131415161718192021222324// To be more accurate with timers, we would need to update 'now' on every// loop iteration. Not sure it's really efficient though.now := time.Now()smallestDuration := 0 * time.Secondfor key, item := range table.items &#123; // Cache values so we don't keep blocking the mutex. item.RLock() lifeSpan := item.lifeSpan accessedOn := item.accessedOn item.RUnlock() if lifeSpan == 0 &#123; continue &#125; if now.Sub(accessedOn) &gt;= lifeSpan &#123; // Item has excessed its lifespan. table.deleteInternal(key) &#125; else &#123; // Find the item chronologically closest to its end-of-lifespan. if smallestDuration == 0 || lifeSpan-now.Sub(accessedOn) &lt; smallestDuration &#123; smallestDuration = lifeSpan - now.Sub(accessedOn) &#125; &#125;&#125; 遍历table.items这个map，判断当前时间时间和每个item的access时间以及生命周期liftSpan，如果过期，将其删除，否则判断全局最小时间smallestDuration，用于下次过期检查。 1234567// Setup the interval for the next cleanup run.table.cleanupInterval = smallestDurationif smallestDuration &gt; 0 &#123; table.cleanupTimer = time.AfterFunc(smallestDuration, func() &#123; go table.expirationCheck() &#125;)&#125; 这里涉及到time定时器。定时器等到smallestDuration之后，再进行新一轮的过期检查。 deleteInternal 123456789101112131415161718192021222324252627func (table *CacheTable) deleteInternal(key interface&#123;&#125;) (*CacheItem, error) &#123; r, ok := table.items[key] if !ok &#123; return nil, ErrKeyNotFound &#125; // Cache value so we don't keep blocking the mutex. aboutToDeleteItem := table.aboutToDeleteItem table.Unlock() // Trigger callbacks before deleting an item from cache. if aboutToDeleteItem != nil &#123; aboutToDeleteItem(r) &#125; r.RLock() defer r.RUnlock() if r.aboutToExpire != nil &#123; r.aboutToExpire(key) &#125; table.Lock() table.log("Deleting item with key", key, "created on", r.createdOn, "and hit", r.accessCount, "times from table", table.name) delete(table.items, key) return r, nil&#125; 首先判断要删除的key是否存在。存在的话，先解锁（table.Unlock），这里是为了不影响其他并发。回调删除前item需要做的函数。同样适用读锁，调用aboutToExpire(key)。这些操作完成之后，再table.Lock，真正进行map删除。 addInternal 123456789101112131415161718192021func (table *CacheTable) addInternal(item *CacheItem) &#123; // Careful: do not run this method unless the table-mutex is locked! // It will unlock it for the caller before running the callbacks and checks table.log("Adding item with key", item.key, "and lifespan of", item.lifeSpan, "to table", table.name) table.items[item.key] = item // Cache values so we don't keep blocking the mutex. expDur := table.cleanupInterval addedItem := table.addedItem table.Unlock() // Trigger callback after adding an item to cache. if addedItem != nil &#123; addedItem(item) &#125; // If we haven't set up any expiration check timer or found a more imminent item. if item.lifeSpan &gt; 0 &amp;&amp; (expDur == 0 || item.lifeSpan &lt; expDur) &#123; table.expirationCheck() &#125;&#125; 添加一样，添加操作前提是已经获取table.Lock。调用addedItem。 Add和Delete封装 1234567891011121314151617func (table *CacheTable) Add(key interface&#123;&#125;, lifeSpan time.Duration, data interface&#123;&#125;) *CacheItem &#123; item := NewCacheItem(key, lifeSpan, data) // Add item to cache. table.Lock() table.addInternal(item) return item&#125;// Delete an item from the cache.func (table *CacheTable) Delete(key interface&#123;&#125;) (*CacheItem, error) &#123; table.Lock() defer table.Unlock() return table.deleteInternal(key)&#125; Exists 和NotFoundAdd 1234567891011121314151617181920212223242526// Exists returns whether an item exists in the cache. Unlike the Value method// Exists neither tries to fetch data via the loadData callback nor does it// keep the item alive in the cache.func (table *CacheTable) Exists(key interface&#123;&#125;) bool &#123; table.RLock() defer table.RUnlock() _, ok := table.items[key] return ok&#125;// NotFoundAdd tests whether an item not found in the cache. Unlike the Exists// method this also adds data if they key could not be found.func (table *CacheTable) NotFoundAdd(key interface&#123;&#125;, lifeSpan time.Duration, data interface&#123;&#125;) bool &#123; table.Lock() if _, ok := table.items[key]; ok &#123; table.Unlock() return false &#125; item := NewCacheItem(key, lifeSpan, data) table.addInternal(item) return true&#125; Value 123456789101112131415161718192021222324252627// Value returns an item from the cache and marks it to be kept alive. You can// pass additional arguments to your DataLoader callback function.func (table *CacheTable) Value(key interface&#123;&#125;, args ...interface&#123;&#125;) (*CacheItem, error) &#123; table.RLock() r, ok := table.items[key] loadData := table.loadData table.RUnlock() if ok &#123; // Update access counter and timestamp. r.KeepAlive() return r, nil &#125; // Item doesn't exist in cache. Try and fetch it with a data-loader. if loadData != nil &#123; item := loadData(key, args...) if item != nil &#123; table.Add(key, item.lifeSpan, item.data) return item, nil &#125; return nil, ErrKeyNotFoundOrLoadable &#125; return nil, ErrKeyNotFound&#125; 根据key获取相关CacheItem，如果key存在的话，更新相关访问时间r.KeepAlive；如果不存在，判断是否设置loadData回调函数，如果设置的话，按照loadData规则创建相关key。 如例子中使用这种方法创建key： 12345678910111213141516171819202122232425func main() &#123; cache := cache2go.Cache("myCache") // The data loader gets called automatically whenever something // tries to retrieve a non-existing key from the cache. cache.SetDataLoader(func(key interface&#123;&#125;, args ...interface&#123;&#125;) *cache2go.CacheItem &#123; // Apply some clever loading logic here, e.g. read values for // this key from database, network or file. val := "This is a test with key " + key.(string) // This helper method creates the cached item for us. Yay! item := cache2go.NewCacheItem(key, 0, val) return item &#125;) // Let's retrieve a few auto-generated items from the cache. for i := 0; i &lt; 10; i++ &#123; res, err := cache.Value("someKey_" + strconv.Itoa(i)) if err == nil &#123; fmt.Println("Found value in cache:", res.Data()) &#125; else &#123; fmt.Println("Error retrieving value from cache:", err) &#125; &#125;&#125; Flush 12345678910111213// Flush deletes all items from this cache table.func (table *CacheTable) Flush() &#123; table.Lock() defer table.Unlock() table.log("Flushing table", table.name) table.items = make(map[interface&#123;&#125;]*CacheItem) table.cleanupInterval = 0 if table.cleanupTimer != nil &#123; table.cleanupTimer.Stop() &#125;&#125; Flush key重新分配items，历史的交给Go内存回收。 log 12345678// Internal logging method for convenience.func (table *CacheTable) log(v ...interface&#123;&#125;) &#123; if table.logger == nil &#123; return &#125; table.logger.Println(v)&#125; 日志封装，使用Println。 MostAccessed 12345678910111213// CacheItemPair maps key to access countertype CacheItemPair struct &#123; Key interface&#123;&#125; AccessCount int64&#125;// CacheItemPairList is a slice of CacheIemPairs that implements sort.// Interface to sort by AccessCount.type CacheItemPairList []CacheItemPairfunc (p CacheItemPairList) Swap(i, j int) &#123; p[i], p[j] = p[j], p[i] &#125;func (p CacheItemPairList) Len() int &#123; return len(p) &#125;func (p CacheItemPairList) Less(i, j int) bool &#123; return p[i].AccessCount &gt; p[j].AccessCount &#125; 创建CacheItemPair结构体，统计最常访问的key，实现Swap|Len|Less接口函数，为了sort.Sort排序创建仿函数。 1234567891011121314151617181920212223242526272829// MostAccessed returns the most accessed items in this cache tablefunc (table *CacheTable) MostAccessed(count int64) []*CacheItem &#123; table.RLock() defer table.RUnlock() p := make(CacheItemPairList, len(table.items)) i := 0 for k, v := range table.items &#123; p[i] = CacheItemPair&#123;k, v.accessCount&#125; i++ &#125; sort.Sort(p) var r []*CacheItem c := int64(0) for _, v := range p &#123; if c &gt;= count &#123; break &#125; item, ok := table.items[v.Key] if ok &#123; r = append(r, item) &#125; c++ &#125; return r&#125; 使用读锁，将map中items转换为CacheItemPair进行排序，返回访问次数大于count的CacheItem。 CacheItemCacheItem struct说明12345678910111213141516171819202122// CacheItem is an individual cache item// Parameter data contains the user-set value in the cache.type CacheItem struct &#123; sync.RWMutex // The item's key. key interface&#123;&#125; // The item's data. data interface&#123;&#125; // How long will the item live in the cache when not being accessed/kept alive. lifeSpan time.Duration // Creation timestamp. createdOn time.Time // Last access timestamp. accessedOn time.Time // How often the item was accessed. accessCount int64 // Callback method triggered right before removing the item from the cache aboutToExpire func(key interface&#123;&#125;)&#125; 成员名称 类型 说明 sync.RWMutex 继承读写锁 key interface{} key支持任意类型 data interace{} value支持任意类型 lifSpan time.Duration 寿命周期，单位为纳秒 createdOn time.Time 创建时间 accessedOn time.Time 访问时间 accessCount int64 访问次数 aboutToExpire func 在删除item之前调用的触发函数 CacheItem函数说明 NewCacheItem 1234567891011121314151617// NewCacheItem returns a newly created CacheItem.// Parameter key is the item's cache-key.// Parameter lifeSpan determines after which time period without an access the item// will get removed from the cache.// Parameter data is the item's value.func NewCacheItem(key interface&#123;&#125;, lifeSpan time.Duration, data interface&#123;&#125;) *CacheItem &#123; t := time.Now() return &amp;CacheItem&#123; key: key, lifeSpan: lifeSpan, createdOn: t, accessedOn: t, accessCount: 0, aboutToExpire: nil, data: data, &#125;&#125; KeepAlive 1234567// KeepAlive marks an item to be kept for another expireDuration period.func (item *CacheItem) KeepAlive() &#123; item.Lock() defer item.Unlock() item.accessedOn = time.Now() item.accessCount++&#125; 这里使用读写锁 元素获取 12345678910111213141516171819202122232425262728293031323334353637// LifeSpan returns this item's expiration duration.func (item *CacheItem) LifeSpan() time.Duration &#123; // immutable return item.lifeSpan&#125;// AccessedOn returns when this item was last accessed.func (item *CacheItem) AccessedOn() time.Time &#123; item.RLock() defer item.RUnlock() return item.accessedOn&#125;// CreatedOn returns when this item was added to the cache.func (item *CacheItem) CreatedOn() time.Time &#123; // immutable return item.createdOn&#125;// AccessCount returns how often this item has been accessed.func (item *CacheItem) AccessCount() int64 &#123; item.RLock() defer item.RUnlock() return item.accessCount&#125;// Key returns the key of this cached item.func (item *CacheItem) Key() interface&#123;&#125; &#123; // immutable return item.key&#125;// Data returns the value of this cached item.func (item *CacheItem) Data() interface&#123;&#125; &#123; // immutable return item.data&#125; 可能修改的数据，使用读锁，不修改的数据不加锁。 SetAboutToExpireCallback 1234567// SetAboutToExpireCallback configures a callback, which will be called right// before the item is about to be removed from the cache.func (item *CacheItem) SetAboutToExpireCallback(f func(interface&#123;&#125;)) &#123; item.Lock() defer item.Unlock() item.aboutToExpire = f&#125; 测试mycachedapp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( "fmt" "time" "github.com/muesli/cache2go" "os" "log")// Keys &amp; values in cache2go can be of arbitrary types, e.g. a struct.type myStruct struct &#123; text string moreData []byte&#125;func main() &#123; // Accessing a new cache table for the first time will create it. cache := cache2go.Cache("myCache") //Aadded for debug log := log.Logger&#123;&#125; log.SetOutput(os.Stdout) cache.SetLogger(&amp;log) // We will put a new item in the cache. It will expire after // not being accessed via Value(key) for more than 5 seconds. val := myStruct&#123;"This is a test!", []byte&#123;&#125;&#125; cache.Add("someKey", 5*time.Second, &amp;val) fmt.Printf("Now: %v.\n", time.Now()) // Let's retrieve the item from the cache. res, err := cache.Value("someKey") if err == nil &#123; fmt.Println("Found value in cache:", res.Data().(*myStruct).text) &#125; else &#123; fmt.Println("Error retrieving value from cache:", err) &#125; // Wait for the item to expire in cache. time.Sleep(10 * time.Second) res, err = cache.Value("someKey") if err != nil &#123; fmt.Println("Item is not cached (anymore).") &#125; // Add another item that never expires. cache.Add("someKey", 0, &amp;val) // cache2go supports a few handy callbacks and loading mechanisms. cache.SetAboutToDeleteItemCallback(func(e *cache2go.CacheItem) &#123; fmt.Println("Deleting:", e.Key(), e.Data().(*myStruct).text, e.CreatedOn()) &#125;) // Remove the item from the cache. cache.Delete("someKey") // And wipe the entire cache table. cache.Flush()&#125; 输出： 123456789101112131415[Adding item with key someKey and lifespan of 5s to table myCache][In Expiration check....][Expiration check installed for table myCache]Now: 2018-03-16 18:06:18.421989715 +0800 CST m=+0.000683071.Found value in cache: This is a test![In Expiration check....][Expiration check triggered after 4.999843946s for table myCache][In Expiration check....][Expiration check triggered after 161.058µs for table myCache][Deleting item with key someKey created on 2018-03-16 18:06:18.421813674 +0800 CST m=+0.000507035 and hit 1 times from table myCache]Item is not cached (anymore).[Adding item with key someKey and lifespan of 0s to table myCache]Deleting: someKey This is a test! 2018-03-16 18:06:28.42451005 +0800 CST m=+10.002926414[Deleting item with key someKey created on 2018-03-16 18:06:28.42451005 +0800 CST m=+10.002926414 and hit 0 times from table myCache][Flushing table myCache] 使用协程进行过期的判断。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>cache2go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TiDB初始篇]]></title>
    <url>%2F2018-03-09-TiDB%E5%88%9D%E5%A7%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言看到TiDB发布的微信公众账号文章，TiDB 源码阅读系列文章，开始研究TiDB学习一些基本的Go开发以及SQL开发知识。更多的可以参照TiDB官方博客 TiDB编译源码编译 go环境 12bogon:tidb guosong$ go versiongo version go1.10 darwin/amd64 编译二进制 123git clone https://github.com/pingcap/tidb.git $GOPATH/src/github.com/pingcap/tidbcd $GOPATH/src/github.com/pingcap/tidbmake IDE工具源码使用intelliJ IDEA工具,打开tidb-server的main.go进行run 测试默认密码为空，完全支持MySQL协议123456789101112131415161718192021222324252627282930313233bogon:tidb guosong$ mysql -h 127.0.0.1 -P 4000 -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 1Server version: 5.7.1-TiDB-None MySQL Community Server (Apache License 2.0)Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; \s--------------mysql Ver 14.14 Distrib 5.6.20, for osx10.8 (x86_64) using EditLine wrapperConnection id: 1Current database:Current user: root@127.0.0.1SSL: Not in useCurrent pager: stdoutUsing outfile: &apos;&apos;Using delimiter: ;Server version: 5.7.1-TiDB-None MySQL Community Server (Apache License 2.0)Protocol version: 10Connection: 127.0.0.1 via TCP/IPServer characterset: latin1Db characterset: latin1Client characterset: utf8Conn. characterset: utf8TCP port: 4000]]></content>
      <tags>
        <tag>TiDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L5 Longest Palindromic Substring]]></title>
    <url>%2F2018-03-06-L5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[题目描述Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: 123Input: &quot;babad&quot;Output: &quot;bab&quot; Note: “aba” is also a valid answer. Example:123Input: &quot;cbbd&quot;Output: &quot;bb&quot; 解题思路 使用O(NNlogN)时间复杂度算法各个子串进行逐一判断，获取最长的回文子串 Go代码实现Go代码实现1——时间复杂度O(NNlogN)1234567891011121314151617181920212223242526272829303132333435func isPalindrome(str string) bool &#123; if len(str) == 0&#123; return false &#125; s := 0 e := len(str)-1 for s&lt;e &#123; if str[s] != str[e] &#123; return false &#125; s++ e-- &#125; return true&#125;func longestPalindrome(s string) string &#123; n := len(s) if n &lt;=1 &#123; return s &#125; maxInt:=0 ret := "" for i:=0;i&lt;n-1;i++ &#123; for j:=n;j&gt;i ;j-- &#123; if isPalindrome(s[i:j]) &amp;&amp; j-i+1&gt;maxInt &#123; maxInt = j-i+1 ret = s[i:j] &#125; &#125; &#125; return ret&#125; Runtime:756ms, 5.11%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L64 Minimum Path Sum]]></title>
    <url>%2F2018-03-06-L64-Minimum-Path-Sum%2F</url>
    <content type="text"><![CDATA[题目描述Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time.1234Example 1:[[1,3,1], [1,5,1], [4,2,1]] Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum. 解题思路 二维DP问题参照动态规划入门 优化存储空间的二维DP Go代码实现Go动态规划实现——二维1234567891011121314151617181920212223242526272829303132333435func min(a int, b int)int &#123; if a&lt;b &#123; return a &#125;else &#123; return b &#125;&#125;func minPathSum(grid [][]int) int &#123; n := len(grid) m := len(grid[0]) if n==0 || m==0 &#123; return 0 &#125; s := make([][]int,n) for i:=0; i&lt;n;i++ &#123; s[i] = make([]int,m) &#125; for i:=0;i&lt;n ;i++ &#123; for j:=0;j&lt;m ; j++ &#123; if i==0 &amp;&amp; j==0 &#123; s[i][j] = grid[i][j] &#125;else if i==0 &amp;&amp; j&gt;0 &#123; s[i][j] = grid[i][j] + s[i][j-1] &#125;else if i&gt;0 &amp;&amp; j==0 &#123; s[i][j] = grid[i][j] + s[i-1][j] &#125;else&#123; s[i][j] = grid[i][j] + min(s[i][j-1], s[i-1][j]) &#125; &#125; &#125; return s[n-1][m-1]&#125; Runtime:12ms, 100.0% Go代码实现——直接修改grid123456789101112131415161718192021222324252627282930func min(a int, b int)int &#123; if a&lt;b &#123; return a &#125;else &#123; return b &#125;&#125;func minPathSum(grid [][]int) int &#123; n := len(grid) m := len(grid[0]) if n==0 || m==0 &#123; return 0 &#125; for i:=0;i&lt;n ;i++ &#123; for j:=0;j&lt;m ; j++ &#123; if i==0 &amp;&amp; j==0 &#123; continue &#125;else if i==0 &amp;&amp; j&gt;0 &#123; grid[i][j] += grid[i][j-1] &#125;else if i&gt;0 &amp;&amp; j==0 &#123; grid[i][j] += grid[i-1][j] &#125;else&#123; grid[i][j] +=min(grid[i][j-1], grid[i-1][j]) &#125; &#125; &#125; return grid[n-1][m-1]&#125; Runtime:12ms, 100.0%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L300 Longest Increasing Subsequence]]></title>
    <url>%2F2018-03-05-L300-Longest-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[题目描述Given an unsorted array of integers, find the length of longest increasing subsequence. For example,Given [10, 9, 2, 5, 3, 7, 101, 18],The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? 解题思路 动态规划思想，状态转移方程式 1dp[i] = max&#123;dp[j]+1&#125; 其中j&lt;i &amp;&amp; A[j]&lt;=A[i] O(NlogN)时间复杂度 Go代码实现Go代码实现1——动态规划，O(N*N)时间复杂度12345678910111213141516171819202122func lengthOfLIS(nums []int) int &#123; n:=len(nums) if n == 0 &#123; return 0 &#125; ret:=1 dp := make([]int, n) for i:=0;i&lt;n;i++ &#123; dp[i] = 1 for j:=0; j&lt;i;j++ &#123; if nums[j]&lt;nums[i] &amp;&amp; dp[j]+1&gt;dp[i] &#123; dp[i] = dp[j]+1 &#125; if dp[i]&gt;ret&#123; ret = dp[i] &#125; &#125; &#125; return ret&#125; Go代码实现2——O(N*logN)时间复杂度12345678910111213141516171819202122232425262728293031323334func upper_bound(nums []int, target int, s int, e int) int &#123; if nums[e]&lt;target &#123; return e+1 &#125; for s&lt;e &#123; mid := s + (e-s)/2 if nums[mid]&lt;target &#123; s = mid+1 &#125;else &#123; e = mid &#125; &#125; return s&#125;func lengthOfLIS(nums []int) int &#123; n:=len(nums) if n == 0 &#123; return 0 &#125; end := make([]int, n+1) end[1] = nums[0] len := 1 for i:=1;i&lt;n;i++ &#123; pos := upper_bound(end,nums[i], 1,len) end[pos] = nums[i] if len&lt;pos &#123; len = pos &#125; &#125; return len&#125; 参考资料https://www.felix021.com/blog/read.php?1587]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L746 Min Cost Climbing Stairs]]></title>
    <url>%2F2018-03-05-L746-Min-Cost-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[题目描述On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1:12Input: cost = [10, 15, 20]Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.Example 2:12Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].Note:cost will have a length in the range [2, 1000].Every cost[i] will be an integer in the range [0, 999]. 解题思路 动态规划思想dp[i] = min(cost[i-1]+dp[i-1], cost[i-2]+dp[i-2]) Go代码实现Go代码实现——数组存储子问题解1234567891011121314151617181920212223242526func min(a int, b int)int &#123; if a&lt;b &#123; return a &#125;else&#123; return b &#125;&#125;func minCostClimbingStairs(cost []int) int &#123; n := len(cost) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return cost[0] &#125; dp := make([]int, n+1) for i:=2;i&lt;n+1;i++ &#123; dp[i] = min(cost[i-1]+dp[i-1], cost[i-2]+dp[i-2]) &#125; return dp[n]&#125; Runtime: 8ms Go代码实现——数组存储子问题解123456789101112131415161718192021222324252627func min(a int, b int)int &#123; if a&lt;b &#123; return a &#125;else&#123; return b &#125;&#125;func minCostClimbingStairs(cost []int) int &#123; n := len(cost) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return cost[0] &#125; dp := make([]int, n) dp[0] = cost[0] dp[1] = cost[1] for i:=2;i&lt;n;i++ &#123; dp[i] = min(dp[i-1], dp[i-2]) + cost[i] &#125; return min(dp[n-1],dp[n-2])&#125; Go代码实现——dp空间优化1234567891011121314151617181920func minCostClimbingStairs(cost []int) int &#123; n := len(cost) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return cost[0] &#125; a := 0 b := 0 for i:=0;i&lt;n;i++ &#123; t := min(a,b) + cost[i] a = b b = t &#125; return min(a,b)&#125; 参考资料：http://www.cnblogs.com/grandyang/p/8343874.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L322 Climbing Stairs]]></title>
    <url>%2F2018-03-02-L322-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[题目描述You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1:123456Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2:1234567Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 解题思路 动态规划思想dp[i] = dp[i-2] + dp[i-1]注意初始化条件dp[0] = 0dp[1] = 1dp[2] = {dp[1]+1（爬1个）,dp[0]+2（爬2个）} = dp[1] + dp[0]&lt;–more–&gt; Go代码实现Go动态规划实现——使用n个存储1234567891011121314151617181920func climbStairs(n int) int &#123; if n == 0 &#123; return 0 &#125; if n==1 &#123; return 1 &#125; dp := make([]int, n) dp[0] = 1 dp[1] = 2 for i:=2;i&lt;n;i++ &#123; dp[i] = dp[i-2]+dp[i-1] &#125; return dp[n-1]&#125; Runtime:0ms, 4.84% Go动态规划优化——使用三个变量实现12345678910111213141516171819202122func climbStairs(n int) int &#123; if n == 0 &#123; return 0 &#125; if n==1 &#123; return 1 &#125; a := 1 b := 2 ret := b for i:=2;i&lt;n;i++ &#123; ret = a+b a = b b = ret &#125; return ret&#125; 参考资料 http://www.cnblogs.com/grandyang/p/4079165.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L198 House Robber]]></title>
    <url>%2F2018-03-01-L198-House-Robber%2F</url>
    <content type="text"><![CDATA[L198题目描述You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Credits:Special thanks to @ifanchu for adding this problem and creating all test cases. Also thanks to @ts for adding additional test cases. 关键点给一组数，不能取相邻的两个数，获取最大和。例如数组nums[3, 10, 20, 32, 4]，其最大和为10+32=42 解题思路 使用动态规划思想 d(i) = max{d(i-2)+nums[i], d(i-1)} 判断依据是否获取当前值，结果返回d最后一个值即可。 Go代码实现Go代码实现112345678910111213141516171819202122232425262728func max(a int, b int) int &#123; if a&gt;b &#123; return a &#125;else&#123; return b &#125;&#125;func rob(nums []int) int &#123; n := len(nums) if n == 0&#123; return 0 &#125; if n == 1 &#123; return nums[0] &#125; sums := make([]int, n) sums[0] = nums[0] sums[1] = max(nums[0], nums[1]) for i:=2;i&lt;n;i++ &#123; sums[i] = max(sums[i-2]+nums[i], sums[i-1]) &#125; return sums[n-1]&#125; Runtime:0ms, 29.82% Go代码实现2从动态规划总结的表达式d(i) = max{d[i-2]+nums[i], d[i-1]}可以看出子问题的解只依赖于d[i-1]和d[i-2]两个变量，使用两个变量而不是sums数组进行一步优化动态规划的程序。 123456789101112131415161718192021222324252627282930func max(a int, b int) int &#123; if a&gt;b &#123; return a &#125;else&#123; return b &#125;&#125;func rob(nums []int) int &#123; n := len(nums) if n == 0&#123; return 0 &#125; if n == 1 &#123; return nums[0] &#125; a := 0 b := 0 maxSum := 0 for i:=0; i&lt;n; i++ &#123; maxSum = max(a+nums[i], b) a = b b = maxSum &#125; return maxSum&#125; Rumtime:0ms, 29.82% 相似问题L213 House Robber II题目描述This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. 解题思路 将问题L213转换为L198，进行两次判断包含首个元素和包含最后一个元素，判断两者的最大值。 Go代码实现1234567891011121314151617181920212223242526272829303132333435func max(a int, b int) int &#123; if a&gt;b &#123; return a &#125;else&#123; return b &#125;&#125;func rob(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return nums[0] &#125; return max(robNoCycle(nums[0:n-1]), robNoCycle(nums[1:]))&#125;func robNoCycle(nums []int) int &#123; n := len(nums) a := 0 b := 0 maxSum := 0 for i:=0; i&lt;n; i++ &#123; maxSum = max(a+nums[i], b) a = b b = maxSum &#125; return maxSum&#125; Runtime:0ms, 35.71%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L53-Maximum-Subarray]]></title>
    <url>%2F2018-02-28-53-Maximum-Subarray%2F</url>
    <content type="text"><![CDATA[题目描述Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解题思路动态规划思想以nums数组[-2,1,-3,4,-1]为例 dp[0]为-2 dp[1] = max(dp[0]+nums[1],1)=max(-2,1)=1 dp[2] = max(dp[1]+nums[2],-3)=max(1-3,-3)=-2 当前的sum为dp[i-1]+nums[i], nums[i]最大值 然后将maxSum和sum进行比较，取最大值 Go代码实现Go代码实现11234567891011121314151617181920212223242526272829func max(a int, b int)int &#123; if a&gt;b &#123; return a &#125;else&#123; return b &#125;&#125;func maxSubArray(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return nums[0] &#125; sums := make([]int, n) maxSum := nums[0] sums[0] = nums[0] for i:=1;i&lt;n ; i++ &#123; sums[i] = max(sums[i-1]+nums[i], nums[i]) maxSum = max(sums[i], maxSum) &#125; return maxSum&#125; Go代码实现21234567891011121314151617181920212223func maxSubArray(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; maxSum := nums[0] curSum := nums[0] for i:=1;i&lt;n ; i++ &#123; if curSum&lt;0 &#123; curSum = nums[i] &#125;else&#123; curSum += nums[i] &#125; if curSum&gt;maxSum &#123; maxSum = curSum &#125; &#125; return maxSum&#125; 参考文档 http://blog.csdn.net/liu2012huan/article/details/51296635]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L414-Third-Maximum-Number]]></title>
    <url>%2F2018-02-26-414-Third-Maximum-Number%2F</url>
    <content type="text"><![CDATA[题目描述Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). 12345678910111213141516Example 1:Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1.Example 2:Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:Input: [2, 2, 3, 1]Output: 1 Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 解题思路 使用三个变量 Go代码Go代码实现1234567891011121314151617181920212223import "math"func thirdMax(nums []int) int &#123; ret := []int&#123;math.MinInt64, math.MinInt64, math.MinInt64&#125; for _,n := range nums&#123; if n == ret[0] || n == ret[1] || n == ret[2] &#123; continue &#125; if n &gt; ret[0]&#123; ret = []int&#123;n, ret[0], ret[1]&#125; &#125;else if n&gt;ret[1] &#123; ret = []int&#123;ret[0], n, ret[1]&#125; &#125;else if n&gt;ret[2]&#123; ret = []int&#123;ret[0], ret[1], n&#125; &#125; &#125; if ret[2] == math.MinInt64&#123; return ret[0] &#125;else&#123; return ret[2] &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划入门]]></title>
    <url>%2F2018-02-01-dynamic-planning%2F</url>
    <content type="text"><![CDATA[硬币问题问题描述我们有面值为1元、3元和5元的硬币若干，如何使用更少的硬币凑成11元？ 问题分析规定dp[i] = j 表示凑成i元至少需要j个硬币。 i = 0，显然需要0个硬币凑成0元，即有dp[0] = 0i = 1，凑成1元需要硬币的数目为dp[1] = dp[0] + 1 = 1i = 2，凑成2元需要硬币的数目为dp[2] = dp[1] + 1 = 2i = 3，凑成3元需要硬币的数目有两种情况，dp[3] = dp[2] + 1 = 2 + 1= 3 , 还可以dp[3] = dp[3-3] + 1 = dp[0] + 1 = 1。通过比较两个最小值，可以获得dp[3] = 1i = 4，可以使用1元硬币dp[4] = dp[4-1] + 1 = 2 ，也可以使用3元硬币dp[4] = dp[4-3] + 1 = dp[1] + 1 = 2i = 5，要凑5元，可以使用下面三种： 使用1元硬币，dp[5] = dp[5-1] + 1 = dp[4] + 1 = 3 使用3元硬币，dp[5] = dp[5-3] + 1 = dp[2] + 1 = 3 使用5元硬币，dp[5] = dp[5-5] + 1 = dp[0] + 1 = 1于是dp[5] = 1 可以递归公式：d(i) = min{d[i-vj]+1 | vj属于{1,3,5}} 伪代码: 123456789Set Min[i] equal to Infinity for all of iMin[0]=0Min[1:S] = MaxValueFor i = 1 to SFor j = 0 to N - 1 If (Vj&lt;=i AND Min[i-Vj]+1&lt;Min[i])Then Min[i]=Min[i-Vj]+1Output Min[S] Go代码实现123456789101112131415161718package DPfunc testDp(s int) int &#123; v := []int&#123;1,3,5&#125; dp := make([]int,s+1) dp[0] = 0 for i:=1; i&lt;=s;i++ &#123; dp[i] = s for j:=0;j&lt;len(v) ; j++ &#123; if v[j]&lt;=i &amp;&amp; dp[i-v[j]]+1&lt;dp[i] &#123; dp[i] = dp[i-v[j]] + 1 &#125; &#125; &#125; return dp[s]&#125; 总结在求解凑成11元需要多少个硬币，没有直接计算dp[11]，而是将这个问题分解成许多个相同的子问题。依赖这些子问题解得到最终解。 最长非降子序列长度题目描述一个序列有N个数，例如5, 3, 4, 8, 6, 7，求这个序列最长非降子序列长度。 问题分析LIS表示最长非降序子列长度 前1个数的LIS长度为d(1)=1 (序列: 5) 前2个数的LIS长度为d(2)=1 (序列: 3，3前面没有比3小的) 前3个数的LIS长度为d(3)=2 (序列4有一个比它小的3)，所以等于d(2)+1 前4个数的LIS长度为d(4)=(序列: 3, 4, 8)，d(4) = max{d(1), d(2), d(3)} + 1 = 3 前5个数的LIS长度为d(5)=(序列：3，4，6), d(5) = max{d(1), d(2), d(3)} + 1 = 3 1234状态转移方程式d(i) = max&#123;1, d(j)+1&#125;，其中j&lt;i, A[j]&lt;=A[i]d(i)表示前i个数以A[i]结尾的LIS Go代码实现1234567891011121314151617181920212223func LIS(nums []int)int &#123; n := len(nums) dp := make([]int, n) for i:=0;i&lt;n;i++ &#123; dp[i] = 1 &#125; max := 1 j := 1 for j&lt;n &#123; for i:=0;i&lt;j;i++&#123; if nums[j]&gt;nums[i] &amp;&amp; dp[j]&lt;dp[i]+1 &#123; dp[j] = dp[i]+1 if dp[j]&gt;max &#123; max = dp[j] &#125; &#125; &#125; j++ &#125; return max&#125; 二维DP问题——中级题目描述平面上有N*M个格子，每个格子放着一定数量的苹果。从左上角的格子开始，每一步只能向下或者向右走，每次走到一个格子上就把格子里的苹果都收集起来。问最多能收集多少个苹果？ 解题思路 状态状态S[i][j]表示走到第(i,j)格子，最多能收集的苹果数目。从左边来S[i-1][j],从上边来S[i][j-1]。 状态转移方程式 1S[i][j] = A[i][j] + max&#123;S[i-1][j] if i &gt;0, S[i][j-1] if j &gt; 0&#125; Go代码实现Go代码实现123456789101112131415161718192021222324func TwoDiDp(nums [][]int) int &#123; n := len(nums) m := len(nums[0]) s := make([][]int,n) for i:=0;i&lt;n ;i++ &#123; s[i] = make([]int,m) &#125; for i:=0;i&lt;n;i++&#123; for j:=0;j&lt;m ;j++ &#123; if i==0 &amp;&amp;j == 0 &#123; s[i][j] = nums[i][j] &#125;else if i==0&amp;&amp;j&gt;0 &#123; s[i][j] = nums[i][j] + max(0, s[i][j-1]) &#125;else if j==0 &amp;&amp; i&gt;0 &#123; s[i][j] = nums[i][j] + max(s[i-1][j], 0) &#125;else&#123; s[i][j] = nums[i][j]+max(s[i-1][j], s[i][j-1]) &#125; &#125; &#125; return s[n-1][m-1]&#125; 测试用例12345678func TestCase3(t *testing.T) &#123; nums := [][]int&#123;&#123;7,8,9&#125;,&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;10,11,12&#125;&#125; ret := TwoDiDp(nums) if ret != 45 &#123; t.Error("TestCase3 failed") &#125;&#125; LeetCode测试题目 L64. Minimum Path Sum 参考文档 动态规划专题 http://www.cnblogs.com/skydreamteam/p/3652971.html 动态规划入门之硬币问题 http://blog.csdn.net/kerryfish/article/details/25563937 动态规划：从新手到专家 http://www.hawstein.com/posts/dp-novice-to-advanced.html]]></content>
      <tags>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L541 Reverse String II]]></title>
    <url>%2F2018-01-31-L541-Reverse-String-II%2F</url>
    <content type="text"><![CDATA[题目描述Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. 123Example:Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot; Restrictions:The string consists of lower English letters only.Length of the given string and k will in the range [1, 10000] 解题思路 在Python和Go中string都是const，不可以直接替换，故将其转换为list 使用二分进行reverse，reverse函数接收list、low、high，list为全量，只需要调整low和high即可 Go实现Go实现112345678910111213141516171819202122232425262728package L541import ( "strings")func reverse(strs []string, low int, high int) &#123; for low&lt;high &#123; strs[low], strs[high] = strs[high], strs[low] low++ high-- &#125;&#125;func reverseStr(s string, k int) string &#123; strs := strings.Split(s, "") n := len(strs) i := 0 for i&lt;n &#123; if i+k&gt;n &#123; reverse(strs, i, n-1) &#125;else&#123; reverse(strs, i, i+k-1) &#125; i = i+2*k &#125; return strings.Join(strs, "")&#125; Runtime: 9 ms 16.67% Go实现2 不使用strings库函数，使用bytes数组，将bytes和string之间进行转换 12345678910111213141516171819202122func reverse(bytes []byte, low int, high int) &#123; for low&lt;high &#123; bytes[low], bytes[high] = bytes[high], bytes[low] low++ high-- &#125;&#125;func reverseStr(s string, k int) string &#123; bytes := []byte(s) n := len(bytes) i := 0 for i&lt;n &#123; if i+k&gt;n &#123; reverse(bytes, i, n-1) &#125;else&#123; reverse(bytes, i, i+k-1) &#125; i = i+2*k &#125; return string(bytes)&#125; Runtime 5ms 58.33% 类似题目L557 Reverse Words in a String III12345678910111213141516171819202122232425func reverse(bytes []byte, low int, high int) &#123; for low&lt;high &#123; bytes[low], bytes[high] = bytes[high], bytes[low] low++ high-- &#125;&#125;func reverseWords(s string) string &#123; bytes := []byte(s) n := len(s) low := 0 high := 0 for high&lt;n &#123; for high&lt;n &amp;&amp; s[high]!= ' ' &#123; high++ &#125; reverse(bytes, low, high-1) low = high+1 high++ &#125; return string(bytes)&#125; Runtime:8ms, 100.00%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto_Jump 准备工作1]]></title>
    <url>%2F2018-01-26-Auto-Jump%2F</url>
    <content type="text"><![CDATA[背景刷微信公众账号的时候看到一篇文章AI 玩跳一跳的正确姿势，Auto-Jump 算法详解，觉得挺感兴趣的。再加上现在AI这么火，故按照文章上相关资料进行尝试。本系列文章记录尝试的过程以及遇到的问题。 OpencvOpencv安装在Mac安装Opencv，主要参照文章Mac下安装使用Python-OpenCV。遇到主要问题是brew update时候遇到git错误，后来通过重新安装brew根本解决。 Opencv测试人脸识别参照Face Recognition with Python, in Under 25 Lines of Code实现第一个人脸识别Python Demo。 123456789101112131415161718192021222324252627282930import sysimport cv2def test(image_path, casc_path): newPath = "new_" + image_path faceCascade = cv2.CascadeClassifier(casc_path) image = cv2.imread(image_path) gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) faces = faceCascade.detectMultiScale( gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30), flags=cv2.CASCADE_SCALE_IMAGE ) print "Found &#123;0&#125; faces!".format(len(faces)) # Draw a rectangle around the faces for (x, y, w, h) in faces: cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 1) cv2.imwrite(newPath, image)if __name__ == "__main__": imagePath = sys.argv[1] cascPath = sys.argv[2] test(imagePath, cascPath) 运行参数：1python2.7 Test_Face.py head.jpeg haarcascade_frontalface_default.xml 其中第一个参数为图片，第二个参数为frontface检查器。 程序中最关键的是face检测，也就是Line 37，结果返回检测的faces在图片的坐标，通过rectangle将这些face使用矩形框标记。 WebDriverAgent安装参照git上给出连接搭建WebDriverAgent，期间由于mac、IOS以及Xcode版本过低，统一都进行了升级。具体版本如下： Mac 10.13.3 High Sierra IOS 11.2.5 Xcode 9.2 端口转发 文档中给出是imobiledevice，在mac实现测试使用libimobiledevice。 1brew install libimobiledevice 测试使用iproxy进行端口转发 1iproxy 8100 8100 sign配置]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Opencv</tag>
        <tag>WebDriverAgent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L459 Repeated Substring Pattern]]></title>
    <url>%2F2018-01-18-L459-Repeated-Substring-Pattern%2F</url>
    <content type="text"><![CDATA[题目描述Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. 12345678910111213141516Example 1:Input: &quot;abab&quot;Output: TrueExplanation: It&apos;s the substring &quot;ab&quot; twice.Example 2:Input: &quot;aba&quot;Output: FalseExample 3:Input: &quot;abcabcabcabc&quot;Output: TrueExplanation: It&apos;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.) 解题思路思路1 从字符串str[0:n/2]分成n/2子串，判断是否以这个子串repeated成字符串str，如果是返回true，否则继续检查 O(N**2)时间复杂度 思路2 KMP算法思想，http://blog.csdn.net/v_july_v/article/details/7041827 Go代码实现Go代码实现112345678910111213141516171819202122232425262728func repeatedSubstringPattern(s string) bool &#123; n := len(s) mid := n/2 for i:=1;i&lt;=mid;i++ &#123; substr :=s[0:i] m := len(substr) flag := true for k:=0;k&lt;n; &#123; t:= m+k if m+k&gt;n&#123; t = n-1 &#125; tmp := s[k:t] if tmp != substr &#123; flag = false break &#125; k += m &#125; if flag &#123; return true &#125; &#125; return false&#125; Runtime: 20 ms 33.33% KMP算法代码实现1234567891011121314151617181920func repeatedSubstringPattern(s string) bool &#123; n := len(s) kmp := make([]int, n+1) i, j := 1, 0 for i&lt;n &#123; if s[i] == s[j] &#123; i++ j++ kmp[i] = j &#125;else if j==0 &#123; i++ &#125;else &#123; j = kmp[j] &#125; &#125; return kmp[n] != 0 &amp;&amp; (kmp[n] % (n-kmp[n]) == 0)&#125; 时间复杂度为O(n)，Runtime: 24 ms， 33.33% Go实现3 将s[1:]和s[0:n-1]组合一个字符串new_s，判断new_s是否在s中，通过系统的库函数进行判断。 12345678910func repeatedSubstringPattern(s string) bool &#123; sub1 := s[1:] sub2 := s[:len(s)-1] bigdick := sub1 + sub2 if strings.Contains(bigdick,s)&#123; return true &#125;else&#123; return false &#125;&#125; Runtime:19ms, 33.33% KMP算法思想问题描述有一个文本串S，和一个模式串P，现在要查找P在S中的位置。例如文本串S “BBC ABCDAB ABCDABCDABDE”，模式串P “ABCDABD”，结果P在S中的位置是15。 暴力匹配暴力匹配思想假设现在文本串S匹配到i位置，模式串P匹配到j位置，则有： 如果S[i] 等于 P[j]， 则i++,j++，继续匹配下一个字符 如果S[i] 不等于 P[j], 则将i回溯为i-j+1, j=0。匹配失败，重新归零和回溯。 如果所有S字符匹配完成之后，判断j是否等于模式串的长度，如果是，返回i-j，否则返回-1（未匹配上） 暴力匹配Go实现123456789101112131415161718192021func VolientMatch(s string, p string) int &#123; ns := len(s) np := len(p) i,j:=0, 0 for i&lt;ns &amp;&amp; j &lt;np &#123; if s[i] == p[j] &#123; i++ j++ &#125;else&#123; i = i - j + 1 fmt.Printf("i = %d\n", i) j = 0 &#125; &#125; if j == np &#123; return i-j &#125;else&#123; return -1 &#125;&#125; 针对给出例子，可以看出来i是0-15，文本串S中前15个字符都进行匹配了。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L387 First Unique Character in a String]]></title>
    <url>%2F2018-01-18-L387-First-Unique-Character-in-a-String%2F</url>
    <content type="text"><![CDATA[题目描述Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Examples: 12345s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. Note: You may assume the string contain only lowercase letters. 解题思路 题目中note说是字符串中包含的只有小写字母，故可以包含26个int的数组表示各个字符出现的次数 然后再从新遍历字符串，首次只出现一次的字符串的index返回 Go代码实现Go代码实现112345678910111213141516func firstUniqChar(s string) int &#123; m := make([]int, 26) for _, c := range s&#123; idx := int(c-'a') m[idx]++ &#125; for i, c := range s&#123; if m[c-'a'] == 1 &#123; return i &#125; &#125; return -1&#125; Runtime: 20ms 73.91% Go代码实现2123456789101112131415func firstUniqChar(s string) int &#123; var m [128]int for _, c := range s&#123; m[c]++ &#125; for i, c := range s&#123; if m[c] == 1 &#123; return i &#125; &#125; return -1&#125; 注意不能使用byte数组，存在越界情况,数组表示字符出现的次数，故不限制byte上限127]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L443 String Compression]]></title>
    <url>%2F2018-01-17-L443-String-Compression%2F</url>
    <content type="text"><![CDATA[题目描述Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array. Follow up:Could you solve it using only O(1) extra space? 12345678910111213141516171819202122232425262728293031Example 1:Input:[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Output:Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]Explanation:&quot;aa&quot; is replaced by &quot;a2&quot;. &quot;bb&quot; is replaced by &quot;b2&quot;. &quot;ccc&quot; is replaced by &quot;c3&quot;.Example 2:Input:[&quot;a&quot;]Output:Return 1, and the first 1 characters of the input array should be: [&quot;a&quot;]Explanation:Nothing is replaced.Example 3:Input:[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]Output:Return 4, and the first 4 characters of the input array should be: [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;].Explanation:Since the character &quot;a&quot; does not repeat, it is not compressed. &quot;bbbbbbbbbbbb&quot; is replaced by &quot;b12&quot;.Notice each digit has it&apos;s own entry in the array.Note:All characters have an ASCII value in [35, 126].1 &lt;= len(chars) &lt;= 1000. 解题思路 对连续的字符进行压缩，压缩的结果是字符以及对应的连续的次数，如果连续次数为1，不显示次数 返回结果为压缩后字符的总长度 同时，需要将chars修改为压缩后结果 Go代码实现Go代码实现11234567891011121314151617181920212223242526272829mport ( "strconv")func compress(chars []byte) int &#123; n:=len(chars) idx := 0 for i:=0;i&lt;n;i++ &#123; char := chars[i] count := 0 for i&lt;n &amp;&amp; chars[i] == char &#123; count++ i++ &#125; i-- chars[idx] = char idx++ if count &gt; 1 &#123; countStr := strconv.Itoa(count) for k:=0;k&lt;len(countStr);k++ &#123; chars[idx] = countStr[k] idx++ &#125; &#125; &#125; return idx&#125; Runtime 35ms 0.00%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L434 Number of Segments in a String]]></title>
    <url>%2F2018-01-17-L434-Number-of-Segments-in-a-String%2F</url>
    <content type="text"><![CDATA[题目描述Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. Example:12Input: &quot;Hello, my name is John&quot;Output: 5 解题思路 使用库函数 使用基本算法 更简洁做法：判断当前不为空以及前一个字符为空，即新增一个seg Go代码实现Go代码实现1123456789101112import "strings"func countSegments(s string) int &#123; c:=0 strs := strings.Split(s, " ") for _,str := range strs&#123; if str != ""&#123; c++ &#125; &#125; return c&#125; Runtime 2ms Go代码实现212345678910111213141516171819202122func countSegments(s string) int &#123; n := len(s) i := 0 for i&lt;n &amp;&amp; s[i] == ' ' &#123; i++ &#125; head := true w := 0 for i&lt;n &#123; if s[i] != ' '&#123; if head &#123; w++ head = false &#125; &#125;else&#123; head = true &#125; i++ &#125; return w&#125; 注意左右部分连续空字符Runtime 1ms Go代码实现31234567891011func countSegments(s string) int &#123; n := len(s) ret := 0 for i:=0;i&lt;n ; i++ &#123; if s[i] != ' ' &amp;&amp; (i==0 || s[i-1] ==' ') &#123; ret++ &#125; &#125; return ret&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L383 Ransom Note]]></title>
    <url>%2F2018-01-17-L383-Ransom-Note%2F</url>
    <content type="text"><![CDATA[题目描述Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note:You may assume that both strings contain only lowercase letters. 123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 解题思路 使用两个map表示字符串，判断第一个map中key是否存在于第二个map中，且value是否小于第二个map 使用一个128位的数组 Go代码实现Go代码实现1——使用map123456789101112131415161718192021222324252627func canConstruct(ransomNote string, magazine string) bool &#123; m1 := map[int32]int&#123;&#125; m2 := map[int32]int&#123;&#125; for _,c := range ransomNote &#123; if _,ok := m1[c];!ok &#123; m1[c] = 1 &#125;else &#123; m1[c] += 1 &#125; &#125; for _,c := range magazine &#123; if _,ok := m2[c];!ok &#123; m2[c] = 1 &#125;else &#123; m2[c] += 1 &#125; &#125; for k,v := range m1&#123; if v1, ok := m2[k];!ok || v&gt;v1 &#123; return false &#125; &#125; return true&#125; Runtime: 45 ms 38.10% Go代码实现212345678910111213141516func canConstruct(ransomNote string, magazine string) bool &#123; letter := make([]int32, 128) for _,n := range magazine&#123; letter[n] += 1 &#125; for _,n := range ransomNote&#123; letter[n]-=1 if letter[n]&lt;0 &#123; return false &#125; &#125; return true&#125; Runtime: 11 ms 80.95%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L345 Reverse Vowels of a String]]></title>
    <url>%2F2018-01-17-L345-Reverse-Vowels-of-a-String%2F</url>
    <content type="text"><![CDATA[题目描述Write a function that takes a string as input and reverse only the vowels of a string. Example 1:Given s = “hello”, return “holle”. Example 2:Given s = “leetcode”, return “leotcede”. Note:The vowels does not include the letter “y”. 解题思路 使用low和high两个索引进行遍历，如果两个是元音字母进行交换，否则哪个非元音字母进行low、high跳位 Go代码实现Go代码实现11234567891011121314151617181920212223242526272829303132import "strings"func isVowels(c string) bool &#123; vowels := []string&#123;"a", "e", "i", "o", "u", "A", "E", "I", "O", "U"&#125; for _,v := range vowels&#123; if c == v &#123; return true &#125; &#125; return false&#125;func reverseVowels(s string) string &#123; arr := strings.Split(s, "") low := 0 high := len(s)-1 for low&lt;high &#123; if isVowels(arr[low]) &amp;&amp; isVowels(arr[high])&#123; arr[low], arr[high] = arr[high], arr[low] low++ high-- &#125;else if !isVowels(arr[low]) &#123; low++ &#125;else if !isVowels(arr[high]) &#123; high-- &#125; &#125; return strings.Join(arr, "")&#125; Golang中string值不可以直接更改。Runtime: 41 ms 10.00% Go代码实现212345678910111213141516171819202122232425262728293031func isVowels(c byte) bool &#123; vowels := []byte&#123;'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'&#125; for _,v := range vowels&#123; if c == v &#123; return true &#125; &#125; return false&#125;func reverseVowels(s string) string &#123; ret := make([]byte, len(s)) low := 0 high := len(s)-1 for low&lt;=high &#123; if isVowels(s[low]) &amp;&amp; isVowels(s[high])&#123; ret[low], ret[high] = s[high], s[low] low++ high-- &#125;else if !isVowels(s[low]) &#123; ret[low] = s[low] low++ &#125;else if !isVowels(s[high]) &#123; ret[high] = s[high] high-- &#125; &#125; return string(ret)&#125; Runtime: 13 ms 35.00%使用字节数组，而非string数组]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intersection of Two Arrays]]></title>
    <url>%2F2018-01-16-Intersection-of-Two-Arrays%2F</url>
    <content type="text"><![CDATA[题目描述L349Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note:Each element in the result must be unique.The result can be in any order. L350Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.Follow up:What if the given array is already sorted? How would you optimize your algorithm?What if nums1’s size is small compared to nums2’s size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 解题思路 使用map实现 Go代码实现L34912345678910111213141516171819202122232425func intersection(nums1 []int, nums2 []int) []int &#123; m := map[int]int&#123;&#125; ret_map := map[int]int&#123;&#125; ret := []int&#123;&#125; for _,n := range nums1&#123; if _,ok := m[n];!ok &#123; m[n] = 1 &#125; &#125; for _,n := range nums2 &#123; if _,ok := m[n] ;ok&#123; if _,ok2 := ret_map[n]; !ok2&#123; ret_map[n]=1 &#125; &#125; &#125; for k := range ret_map&#123; ret = append(ret, k) &#125; return ret&#125; Runtime: 13 ms 10.53% L3501234567891011121314151617181920212223242526272829func intersect(nums1 []int, nums2 []int) []int &#123; m := map[int]int&#123;&#125; ret := map[int]int&#123;&#125; arr := []int&#123;&#125; for _,n := range nums1&#123; if _,ok := m[n];!ok &#123; m[n] = 1 &#125;else&#123; m[n] += 1 &#125; &#125; for _,n := range nums2 &#123; if _,ok := m[n];ok &#123; ret[n] += 1 &#125; &#125; for n,j := range ret&#123; k,_ := m[n] if k&gt;j &#123; k = j &#125; for i:=0;i&lt;k;i++ &#123; arr = append(arr, n) &#125; &#125; return arr&#125; Runtime: 12ms 15.38%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L448 Find All Numbers Disappeared in an Array]]></title>
    <url>%2F2018-01-15-L448-Find-All-Numbers-Disappeared-in-an-Array%2F</url>
    <content type="text"><![CDATA[题目描述Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: 12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] 解题思路 借助O(n)空间，使用arr表示各个a[i]对应的数是否存在，返回所有0的i+1 不借助额外空间，将a[i]对应的a[a[i]-1]设置为负，统计返回所有a[i]值为正的i+1 Go实现Go实现112345678910111213141516func findDisappearedNumbers(nums []int) []int &#123; arr := make([]int, len(nums)) for _,n := range nums&#123; arr[n-1] = 1 &#125; ret := []int&#123;&#125; for i,v := range arr&#123; if v == 0 &#123; ret = append(ret, i+1) &#125; &#125; return ret&#125; Runtime: 1308 ms 45.45% Go实现21234567891011121314151617181920func findDisappearedNumbers(nums []int) []int &#123; ret := []int&#123;&#125; for _,n := range nums&#123; if n&lt;0 &#123; n = -n &#125; val := n-1 if nums[val]&gt;0 &#123; nums[val] = - nums[val] &#125; &#125; for i,n := range nums&#123; if n &gt; 0&#123; ret = append(ret, i+1) &#125; &#125; return ret&#125; Runtime: 1516ms 18.18%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L654 Maximum Binary Tree]]></title>
    <url>%2F2018-01-10-L654-Maximum-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given an integer array with no duplicates. A maximum tree building on this array is defined as follow: The root is the maximum number in the array.The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.Construct the maximum tree by the given array and output the root node of this tree. Example 1: 12345678910Input: [3,2,1,6,0,5]Output: return the tree root node representing the following tree: 6 / \ 3 5 \ / 2 0 \ 1 Note:The size of the given array will be in the range [1,1000]. 解题思路 找出nums中的最大值以及idx，构建root节点 nums左部分递归生成左子树 nums右部分递归生成右子树 Go代码实现Go递归实现1234567891011121314151617181920212223242526func getMax(nums []int) (int, int) &#123; max := 0 idx := 0 for i,v := range nums&#123; if v&gt;max &#123; max = v idx = i &#125; &#125; return max, idx&#125;func constructMaximumBinaryTree(nums []int) *TreeNode &#123; if len(nums) == 0 &#123; return nil &#125; max, idx := getMax(nums) root := new(TreeNode) root.Val = max root.Left = constructMaximumBinaryTree(nums[0:idx]) root.Right = constructMaximumBinaryTree(nums[idx+1:]) return root&#125; Runtime: 130 ms 55.81% Go代码实现——使用low和high，避免数组分割12345678910111213141516171819202122232425func constructMaximumBinaryTree(nums []int) *TreeNode &#123; if len(nums) == 0 &#123; return nil &#125; return construct(nums, 0, len(nums))&#125;func construct(nums []int, low int, high int) *TreeNode &#123; if low&gt;high &#123; return nil &#125; mid := low for i:=low+1;i&lt;=high;i++&#123; if nums[i]&gt;nums[mid]&#123; mid = i &#125; &#125; root := new(TreeNode) root.Val = nums[mid] root.Left = construct(nums, low, mid-1) root.Right = construct(nums, mid+1, high) return root&#125; Runtime: 120 ms 65.12% 其他解法 http://www.cnblogs.com/grandyang/p/7513099.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L513 Find Bottom Left Tree Value]]></title>
    <url>%2F2018-01-10-L513-Find-Bottom-Left-Tree-Value%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, find the leftmost value in the last row of the tree. Example 1:123456789101112131415161718192021Input: 2 / \ 1 3Output:1Example 2: Input: 1 / \ 2 3 / / \ 4 5 6 / 7Output:7 Note: You may assume the tree (i.e., the given root node) is not NULL. 解题思路 深度递归遍历，记录各个层row节点信息，返回最深的第一个元素 深度递归遍历，不使用map 层次循环遍历，由左到右 层次遍历，由右到左，返回最后一个元素的val Go代码实现Go代码实现1——深度遍历，使用map12345678910111213141516171819202122232425262728func findBottomLeftValue(root *TreeNode) int &#123; m := map[int][]int&#123;&#125; maxDepth := 0 DFS(root, 0, &amp;maxDepth, m) return m[maxDepth][0]&#125;func DFS(root *TreeNode, level int, maxDepth *int, m map[int][]int) &#123; if root == nil &#123; return &#125; if _,ok := m[level];!ok&#123; m[level] = []int&#123;root.Val&#125; &#125;else&#123; m[level] = append(m[level], root.Val) &#125; if level&gt;*maxDepth &#123; *maxDepth = level &#125; DFS(root.Left, level+1, maxDepth, m) DFS(root.Right, level+1, maxDepth, m)&#125; Runtime: 22 ms 14.29% Go代码实现2——深度递归遍历，使用array123456789101112131415161718192021222324252627func findBottomLeftValue(root *TreeNode) int &#123; if root.Left == nil &amp;&amp; root.Right == nil&#123; return root.Val &#125; ret := []int&#123;&#125; maxDepth := 0 DFS(root, 0, &amp;maxDepth, &amp;ret) return ret[maxDepth-1]&#125;func DFS(root *TreeNode, level int, maxDepth *int, ret *[]int) &#123; if root == nil &#123; return &#125; if level&gt;*maxDepth &#123; *maxDepth = level if len(*ret)+1 == *maxDepth &#123; *ret = append(*ret, root.Val) &#125; &#125; DFS(root.Left, level+1, maxDepth, ret) DFS(root.Right, level+1, maxDepth, ret)&#125; Runtime: 32 ms 7.14% Go代码实现3——循环层次遍历，由左到右12345678910111213141516171819202122232425262728func findBottomLeftValue(root *TreeNode) int &#123; queue := []*TreeNode&#123;&#125; queue = append(queue, root) ret := root.Val for len(queue)&gt;0 &#123; n := len(queue) tmp := []*TreeNode&#123;&#125; for i:=0;i&lt;n;i++ &#123; current := queue[0] queue = queue[1:] if current.Left != nil &#123; tmp = append(tmp, current.Left) &#125; if current.Right != nil &#123; tmp = append(tmp, current.Right) &#125; if i==0 &#123; ret = current.Val &#125; &#125; queue = tmp &#125; return ret&#125; Runtime: 36 ms 7.14% Go代码实现4——层次遍历，由右到左12345678910111213141516171819func findBottomLeftValue(root *TreeNode) int &#123; queue := []*TreeNode&#123;&#125; queue = append(queue, root) current := root for len(queue)&gt;0 &#123; current = queue[0] queue = queue[1:] if current.Right != nil &#123; queue = append(queue, current.Right) &#125; if current.Left != nil &#123; queue = append(queue, current.Left) &#125; &#125; return current.Val&#125; Runtime: 19 ms 21.43%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L515 Find Largest Value in Each Tree Row]]></title>
    <url>%2F2018-01-10-L515-Find-Largest-Value-in-Each-Tree-Row%2F</url>
    <content type="text"><![CDATA[题目描述You need to find the largest value in each row of a binary tree. Example:123456789Input: 1 / \ 3 2 / \ \ 5 3 9 Output: [1, 3, 9] 解题思路 使用queue队列实现层次遍历，比较获取每层的最大值 深度递归实现，将各个level对应的最大值进行递归传递 Go代码实现Go代码实现——使用queue队列循环实现1234567891011121314151617181920212223242526272829303132333435363738func largestValues(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; ret := []int&#123;&#125; queue := []*TreeNode&#123;&#125; queue = append(queue, root) for len(queue)&gt;0 &#123; current := queue[0] max:=current.Val n := len(queue) tmp := []*TreeNode&#123;&#125; for i:=0;i&lt;n;i++ &#123; current = queue[0] queue = queue[1:] if current.Val &gt; max &#123; max = current.Val &#125; if current.Left!=nil &#123; tmp = append(tmp, current.Left) &#125; if current.Right != nil&#123; tmp = append(tmp, current.Right) &#125; &#125; queue = tmp ret = append(ret, max) &#125; return ret&#125; Runtime: 23 ms, 62.5% Go深度递归实现1234567891011121314151617181920212223242526func largestValues(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; ret := []int&#123;&#125; DFS(root, 0, &amp;ret) return ret&#125;func DFS(root *TreeNode, level int, ret *[]int) &#123; if root == nil &#123; return &#125; if len(*ret) &lt;= level &#123; *ret = append(*ret, root.Val) &#125;else&#123; if (*ret)[level] &lt;root.Val &#123; (*ret)[level] = root.Val &#125; &#125; DFS(root.Left, level+1, ret) DFS(root.Right, level+1, ret)&#125; Runtime: 23 ms, 62.5%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L450 Delete Node in a BST]]></title>
    <url>%2F2018-01-10-L450-Delete-Node-in-a-BST%2F</url>
    <content type="text"><![CDATA[题目描述Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove.If the node is found, delete the node.Note: Time complexity should be O(height of tree). Example: 1234567891011121314151617181920212223242526root = [5,3,6,2,4,null,7]key = 3 5 / \ 3 6 / \ \2 4 7Given key to delete is 3. So we find the node with value 3 and delete it.One valid answer is [5,4,6,2,null,null,7], shown in the following BST. 5 / \ 4 6 / \2 7Another valid answer is [5,2,6,null,4,null,7]. 5 / \ 2 6 \ \ 4 7 解题思路 二分遍历BST，发现对应的节点root，查找右子树最小的元素current，将root.left接到current.left上，返回root.right Go代码实现Go代码实现11234567891011121314151617181920212223242526272829303132333435func deleteNode(root *TreeNode, key int) *TreeNode &#123; if root == nil&#123; return root &#125; root = findDelete(root, key) return root&#125;func findDelete(root *TreeNode, key int)*TreeNode&#123; if root == nil &#123; return root &#125; if root.Val == key&#123; if root.Left == nil&#123; return root.Right &#125;else if root.Right == nil &#123; return root.Left &#125; current := root.Right for current.Left != nil &#123; current = current.Left &#125; current.Left = root.Left return root.Right &#125;else if root.Val&gt;key &#123; root.Left = findDelete(root.Left, key) &#125;else&#123; root.Right = findDelete(root.Right, key) &#125; return root&#125; Runtime: 1162 ms 27.78% 参考 https://leetcode.com/problems/delete-node-in-a-bst/discuss/93296/]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L449 Serialize and Deserialize BST]]></title>
    <url>%2F2018-01-10-L449-Serialize-and-Deserialize-BST%2F</url>
    <content type="text"><![CDATA[题目描述Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. 解题思路 使用前序遍历BST，然后按照前序遍历的结果生成二叉树 Python实现Python实现11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Definition for a binary tree node.import unittestclass TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ if not root: return "" data = "#" + str(root.val) data += self.serialize(root.left) data += self.serialize(root.right) return data def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ nums = [int(n) for n in data.split('#') if n != ''] root = self.initBST(nums) return root def initBST(self, nums): root = None for n in nums: root = self.insertNode(root, n) return root def insertNode(self, root, n): if not root: root = TreeNode(n) return root else: if root.val &gt; n: root.left = self.insertNode(root.left, n) else: root.right = self.insertNode(root.right, n) return rootclass Test(unittest.TestCase): code = Codec() def test_1(self): nums = [2, 1, 3] root = self.code.initBST(nums) data = self.code.serialize(root) t = self.code.deserialize(data) data1 = self.code.serialize(t) self.assertEqual(data, data1)if __name__ == '__main__': unittest.main() Runtime: 192 ms 15.49% 精简一下代码 123456789101112131415161718192021222324252627282930313233343536class Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ if not root: return "" data = "#" + str(root.val) data += self.serialize(root.left) data += self.serialize(root.right) return data def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ def doit(root, val): if not root: root = TreeNode(val) return root else: if root.val &gt; val: root.left = doit(root.left, val) else: root.right = doit(root.right,val) return root nums = [int(n) for n in data.split('#') if n != ''] root = None for val in nums: root = doit(root, val) return root Runtime: 173 ms 23.57% Python实现2— BST是BT的一种，故L297的方案解决此问题 https://dolphinsboy.github.io/2018-01-04-L297-Serialize-and-Deserialize-Binary-Tree/]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L437 Path Sum III]]></title>
    <url>%2F2018-01-10-L437-Path-Sum-III%2F</url>
    <content type="text"><![CDATA[题目描述You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. Example: 123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 解题思路思路1 前序递归遍历，记录每条路径以及其和curSum，判断curSum是否和target相同，相同的话加1 同时再判断path路径中是否有从给根开始的路径和等于target，相同的话再加1 思路2— 前序递归各个节点，判断各个节点上是否有路径和等于target 记录前一个节点的和，用于判断使用 Go代码实现Go代码实现1——前序递归遍历，记录路径12345678910111213141516171819202122232425262728func pathSum(root *TreeNode, sum int) int &#123; ret := 0 preOrder(root, []int&#123;&#125;, &amp;ret, 0, sum) return ret&#125;func preOrder(root *TreeNode, path []int, ret *int, curSum int, target int)&#123; if root == nil&#123; return &#125; curSum += root.Val path = append(path, root.Val) if curSum == target &#123; *ret += 1 &#125; t:= curSum for i:=0; i&lt;len(path)-1;i++ &#123; t -= path[i] if t == target &#123; *ret +=1 &#125; &#125; preOrder(root.Left, path, ret, curSum, target) preOrder(root.Right, path, ret, curSum, target)&#125; Go代码实现2——记录前一个节点的和以及递归判断各个节点123456789101112131415161718func pathSum(root *TreeNode, sum int) int &#123; if root == nil&#123; return 0 &#125; return preOrder(root, 0, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum)&#125;func preOrder(root *TreeNode, prev int, sum int) int&#123; if root == nil&#123; return 0 &#125; n := 0 cur := prev + root.Val if cur == sum&#123; n=1 &#125; return n+preOrder(root.Left, cur, sum)+preOrder(root.Right, cur, sum)&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L501 Find Mode in Binary Search Tree]]></title>
    <url>%2F2018-01-09-L501-Find-Mode-in-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.For example:1234567Given BST [1,null,2,2], 1 \ 2 / 2return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). 解题思路 使用map记录各个元素出现的次数，返回次数最多对应的元素list Go代码实现Go代码实现1——使用map123456789101112131415161718192021222324252627282930313233func findMode(root *TreeNode) []int &#123; m := map[int]int&#123;&#125; DFS(root, m) path := []int&#123;&#125; for _,v := range m&#123; path = append(path, v) &#125; sort.Ints(path) n:=len(path)-1 max:= path[n] ret := []int&#123;&#125; for k,v := range m&#123; if v==max &#123; ret = append(ret, k) &#125; &#125; return ret&#125;func DFS(root *TreeNode, m map[int]int) &#123; if root == nil &#123; return &#125; if _,ok := m[root.Val];!ok&#123; m[root.Val] = 1 &#125;else&#123; m[root.Val] += 1 &#125; DFS(root.Left, m) DFS(root.Right, m)&#125; Go代码实现2 https://www.cnblogs.com/grandyang/p/6436150.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L653 Two Sum IV Input is a BST]]></title>
    <url>%2F2018-01-08-L653-Two-Sum-IV-Input-is-a-BST%2F</url>
    <content type="text"><![CDATA[题目描述Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1:12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True Example 2:12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 28Output: False 解题思路解题思路1— 中序遍历生成有序数据组，然后使用二分法从有序数组中判断是否有两个数的和等于target 时间复杂度为O(N)+O(logN)，空间复杂度为O(N) 解题思路2 遍历BST，判断k-root.val是否这个BST中 时间复杂度为O(NlogN)，空间复杂度为O(1) Go代码实现Go代码实现——递归中序遍历、二分查找1234567891011121314151617181920212223242526272829func findTarget(root *TreeNode, k int) bool &#123; path := inOrder(root) low := 0 high := len(path)-1 for low&lt;high &#123; s:= path[low]+path[high] if s == k &#123; return true &#125;else if s&gt;k &#123; high-- &#125;else&#123; low++ &#125; &#125; return false&#125;func inOrder(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; path := []int&#123;&#125; path = append(path, inOrder(root.Left)...) path = append(path, root.Val) path = append(path, inOrder(root.Right)...) return path&#125; Runtime: 74 ms 29.41% Go代码实现——递归深度遍历+判断target是否在BST中12345678910111213141516171819202122232425262728293031func findTarget(root *TreeNode, k int) bool &#123; return find(root, root, k)&#125;func find(current *TreeNode,root *TreeNode, k int) bool &#123; if current == nil&#123; return false &#125; target := k - current.Val flag := target != current.Val &amp;&amp; isExistsBST(root, target) if flag &#123; return true &#125;else&#123; return find(current.Left, root, k) || find(current.Right, root, k) &#125;&#125;func isExistsBST(root *TreeNode, target int)bool &#123; if root == nil&#123; return false &#125; if target == root.Val &#123; return true &#125;else if target&gt;root.Val &#123; return isExistsBST(root.Right, target) &#125;else&#123; return isExistsBST(root.Left, target) &#125;&#125; Runtime:78ms, 23.53%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L671 Second Minimum Node In a Binary Tree]]></title>
    <url>%2F2018-01-08-L671-Second-Minimum-Node-In-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree. If no such second minimum value exists, output -1 instead. Example 1:12345678Input: 2 / \ 2 5 / \ 5 7Output: 5 Explanation: The smallest value is 2, the second smallest value is 5.Example 2:123456Input: 2 / \ 2 2Output: -1 Explanation: The smallest value is 2, but there isn’t any second smallest value. 解题思路 使用两个变量，一个表是最小，一个表示第二小，初始化为最大值 DFS遍历进行逐个比较 Go实现Go递归实现1234567891011121314151617181920212223242526272829func findSecondMinimumValue(root *TreeNode) int &#123; const MAX = 100000 first := MAX second := first-1 dfs(root, &amp;first, &amp;second) if second != MAX-1 &#123; return second &#125;else&#123; return -1 &#125;&#125;func dfs(root *TreeNode, first *int, second *int) &#123; if root == nil &#123; return &#125; if root.Val&lt;*first &#123; *first = root.Val &#125; if root.Val&lt;*second &amp;&amp; root.Val&gt;*first &#123; *second = root.Val &#125; dfs(root.Left, first, second) dfs(root.Right, first, second)&#125; Runtime: 2 ms 7.14%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L637 Average of Levels in Binary Tree]]></title>
    <url>%2F2018-01-06-L637-Average-of-Levels-in-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.Example 1:1234567Input: 3 / \ 9 20 / \ 15 7Output: [3, 14.5, 11] Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.Hence return [3, 14.5, 11].Note:The range of node’s value is in the range of 32-bit signed integer. 解题思路 使用BFS，利用队列循环实现 Go实现Go实现——BFS，队列循环实现1234567891011121314151617181920212223242526272829func averageOfLevels(root *TreeNode) []float64 &#123; if root == nil&#123; return []float64&#123;&#125; &#125; path := []float64&#123;&#125; queue := []*TreeNode&#123;&#125; queue = append(queue, root) for len(queue)&gt;0 &#123; n := len(queue) var s float64 for i:=0;i&lt;n ; i++ &#123; current := queue[0] queue = queue[1:] s+= float64(current.Val) if current.Left != nil &#123; queue = append(queue, current.Left) &#125; if current.Right != nil &#123; queue = append(queue, current.Right) &#125; &#125; path = append(path, s/float64(n)) &#125; return path&#125; Runtime: 44 ms 30.56%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L617 Merge Two Binary Trees]]></title>
    <url>%2F2018-01-06-L617-Merge-Two-Binary-Trees%2F</url>
    <content type="text"><![CDATA[题目描述Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1:1234567891011121314Input: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 Output: Merged tree: 3 / \ 4 5 / \ \ 5 4 7 Note: The merging process must start from the root nodes of both trees. 解题思路 同时递归先序遍历t1和t2 如果t1和t2都不为nil，将t1.val+=t2.val，返回t1 如果t1为nil, t2非nil，返回t2 其他返回t1 Go实现Go递归实现12345678910111213func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode &#123; if t1 != nil &amp;&amp; t2 != nil &#123; t1.Val += t2.Val t1.Left = mergeTrees(t1.Left, t2.Left) t1.Right = mergeTrees(t1.Right, t2.Right) return t1 &#125;else if t1 == nil &amp;&amp; t2 != nil&#123; return t2 &#125;else&#123; return t1 &#125;&#125; Runtime: 62 ms 72.46%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L606 Construct String from Binary Tree]]></title>
    <url>%2F2018-01-06-L606-Construct-String-from-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. Example 1:Input: Binary tree: [1,2,3,4]1234567891011121314151617181920212223 1 / \ 2 3 / 4 Output: &quot;1(2(4))(3)&quot;Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;, but you need to omit all the unnecessary empty parenthesis pairs. And it will be &quot;1(2(4))(3)&quot;.Example 2:Input: Binary tree: [1,2,3,null,4] 1 / \ 2 3 \ 4 Output: &quot;1(2()(4))(3)&quot;Explanation: Almost the same as the first example, except we can&apos;t omit the first parenthesis pair to break the one-to-one mapping relationship between the i 解题思路 先序遍历 判断如果左子树为nil，而右子树非nil，左子树作为()输出 Go实现Go实现——递归方法12345678910111213141516171819func tree2str(t *TreeNode) string &#123; if t == nil &#123; return "" &#125; s := "" s += strconv.Itoa(t.Val) if t.Left != nil &amp;&amp; t.Right != nil &#123; s += "(" + tree2str(t.Left) + ")" s += "(" + tree2str(t.Right) + ")" &#125; else if t.Left == nil &amp;&amp; t.Right != nil &#123; s += "()" s += "(" + tree2str(t.Right) + ")" &#125; else if t.Left != nil &amp;&amp; t.Right == nil &#123; s += "(" + tree2str(t.Left) + ")" &#125; return s&#125; Go实现——非递归方法 https://leetcode.com/problems/construct-string-from-binary-tree/discuss/103991]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L563. Binary Tree Tilt]]></title>
    <url>%2F2018-01-05-L563-Binary-Tree-Tilt%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes’ tilt. Example:12345678910Input: 1 / \ 2 3Output: 1Explanation: Tilt of node 2 : 0Tilt of node 3 : 0Tilt of node 1 : |2-3| = 1Tilt of binary tree : 0 + 0 + 1 = 1 Note:The sum of node values in any subtree won’t exceed the range of 32-bit integer.All the tilt values won’t exceed the range of 32-bit integer. 解题思路 使用后续遍历，计算每个节点左右节点之和，将两者差值的绝对值进行累加 Go代码实现Go递归实现123456789101112131415161718192021222324252627func findTilt(root *TreeNode) int &#123; if root == nil&#123; return 0 &#125; ret := 0 dfs(root, &amp;ret) return ret&#125;func dfs(root *TreeNode, ret *int) int &#123; if root == nil &#123; return 0 &#125; s := 0 sLeft :=dfs(root.Left, ret) sRight := dfs(root.Right, ret) s += root.Val+sLeft+sRight if sLeft &gt;sRight &#123; *ret += sLeft-sRight &#125;else&#123; *ret += sRight-sLeft &#125; return s&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L543 Diameter of Binary Tree]]></title>
    <url>%2F2018-01-05-L543-Diameter-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree12345 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 解题思路 使用深度遍历，计算各个节点左右节点的高度是否小于一个最大值max 返回这个max Go实现Go递归实现1234567891011121314151617181920212223242526func diameterOfBinaryTree(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; d := 0 height(root, &amp;d) return d&#125;func height(root *TreeNode, d *int) int &#123; if root == nil&#123; return 0 &#125; hLeft := height(root.Left, d) hRight := height(root.Right, d) if *d&lt;hLeft+hRight &#123; *d = hLeft + hRight &#125; if hLeft&gt;hRight &#123; return hLeft+1 &#125;else&#123; return hRight+1 &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L538. Convert BST to Greater Tree]]></title>
    <url>%2F2018-01-05-L538-Convert-BST-to-Greater-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: Input: The root of a Binary Search Tree like this:123 5 / \2 13 Output: The root of a Greater Tree like this:123 18 / \20 13 解题思路 使用类中序遍历（右中左） 先遍历右子树，将根节点加上右子树所有节点的和s，将根节点val修改为s 然后遍历左子树，将左子树每个节点加上s Go实现Go实现——递归12345678910111213141516func convertBST(root *TreeNode) *TreeNode &#123; s := 0 convert(root, &amp;s) return root&#125;func convert(root *TreeNode, s *int)&#123; if root == nil&#123; return &#125; convert(root.Right, s) root.Val += *s *s = root.Val convert(root.Left, s)&#125; Go实现——循环12345678910111213141516171819202122232425262728func convertNoRecursion(root *TreeNode) *TreeNode &#123; if root == nil &#123; return root &#125; stack := []*TreeNode&#123;&#125; stack = append(stack, root) s := 0 for len(stack)&gt;0 &#123; current := stack[len(stack)-1] for current != nil &#123; stack = append(stack, current.Right) current = current.Right &#125; stack = stack[0:len(stack)-1] if len(stack)&gt;0 &#123; current = stack[len(stack)-1] stack = stack[0:len(stack)-1] current.Val += s s=current.Val stack = append(stack,current.Left) &#125; &#125; return root&#125; Runtime: 535 ms 73.91% Go实现——O(n*n)时间复杂度 12345678910111213141516171819202122232425262728293031323334353637383940var all_path []intfunc convertBST(root *TreeNode) *TreeNode &#123; all_path = inOrder(root) DFS(root) return root&#125;func inOrder(root *TreeNode) []int &#123; if root == nil&#123; return []int&#123;&#125; &#125; path := []int&#123;&#125; path = append(path, inOrder(root.Left)...) path = append(path, root.Val) path = append(path, inOrder(root.Right)...) return path&#125;func greaterSum(val int) int &#123; s:=0 for _,v := range all_path&#123; if v&gt;val &#123; s+=v &#125; &#125; return s&#125;func DFS(root *TreeNode) &#123; if root == nil&#123; return &#125; root.Val += greaterSum(root.Val) DFS(root.Left) DFS(root.Right)&#125; Runtime: 782 ms 13.04%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L297. Serialize and Deserialize Binary Tree]]></title>
    <url>%2F2018-01-04-L297-Serialize-and-Deserialize-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. For example, you may serialize the following tree 12345 1 / \2 3 / \ 4 5 as “[1,2,3,null,null,4,5]”, just the same as how LeetCode OJ serializes a binary tree.You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. 解题思路 本题目完全使用Discuss https://discuss.leetcode.com/topic/28041/recursive-preorder-python-and-c-o-n Python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# Definition for a binary tree node.import unittestclass TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ def doit(node): if node: vals.append(str(node.val)) doit(node.left) doit(node.right) else: vals.append('#') vals = [] doit(root) n = len(vals) - 1 while vals[n] == '#': n -= 1 return ','.join(vals[0:n + 1]) def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ def doit(): try: val = next(vals) if val == '#': return None node = TreeNode(int(val)) node.left = doit() node.right = doit() return node except StopIteration: pass vals = iter(data.split(',')) return doit()class Test(unittest.TestCase): s = Codec() def test_case1(self): data = "1,2,3,#,#,4,5" root = self.s.deserialize(data) ret = self.s.serialize(root) self.assertEquals(ret, data) def test_case2(self): data = "1,2,3,#,#,4" root = self.s.deserialize(data) ret = self.s.serialize(root) self.assertEquals(ret, data) def test_case3(self): data = "5,2,3,#,#,2,4,3,1" ret = self.s.serialize(self.s.deserialize(data)) self.assertEquals(ret, data)]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L222 Count Complete Tree Nodes]]></title>
    <url>%2F2018-01-03-L222-Count-Complete-Tree-Nodes%2F</url>
    <content type="text"><![CDATA[题目描述Given a complete binary tree, count the number of nodes. Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.It can have between 1 and 2**h nodes inclusive at the last level h. 解题思路 使用深度遍历以及广度遍历都是执行超时，这些算法时间复杂度都是O(N) 使用二分法以及判断是否为满二叉树计算，时间复杂度为O(logN) 完全二叉树 满二叉树 Python代码实现——二分法Python代码实现——二分法递归1234567891011121314151617181920212223242526class Solution(object): def countNodes(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 hLeft= 0 hRight = 0 pLeft = root pRight = root while pLeft: hLeft+=1 pLeft = pLeft.left while pRight: hRight+=1 pRight = pRight.right if hLeft == hRight: return pow(2,hLeft)-1 else: return self.countNodes(root.left) + self.countNodes(root.right) + 1]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L129 Sum Root to Leaf Numbers]]></title>
    <url>%2F2018-01-02-L129-Sum-Root-to-Leaf-Numbers%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. For example, 123 1 / \2 3 The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13. Return the sum = 12 + 13 = 25. 解题思路 深度遍历，使用map保存parent信息，通过叶子节点回溯到root 深度遍历递归 深度遍历非递归 Go代码实现map保存parent信息123456789101112131415161718192021222324252627282930313233343536373839404142func sumNumbers(root *TreeNode) int &#123; parent := map[*TreeNode]*TreeNode&#123;&#125; parent[root] = nil ret := 0 sumPath(root, parent, &amp;ret) return ret&#125;func count(p *TreeNode, parent map[*TreeNode]*TreeNode) int &#123; path := []int&#123;&#125; for p != nil &#123; path = append(path, p.Val) p = parent[p] &#125; n := len(path)-1 ret := 0 for i:=n;i&gt;=0;i-- &#123; ret = ret*10 + path[i] &#125; return ret&#125;func sumPath(root *TreeNode, parent map[*TreeNode]*TreeNode, ret *int)&#123; if root == nil&#123; return &#125; if root.Left == nil &amp;&amp; root.Right==nil &#123; *ret += count(root, parent) &#125; if root.Left != nil &#123; parent[root.Left] = root sumPath(root.Left, parent, ret) &#125; if root.Right != nil &#123; parent[root.Right] = root sumPath(root.Right, parent, ret) &#125;&#125; 深度递归，使用path1234567891011121314151617181920212223242526272829func sumNumbers(root *TreeNode) int &#123; path2 := []int&#123;&#125; ret := 0 dfs(root, path2, &amp;ret) return ret&#125;func dfs(root *TreeNode, path []int, ret *int) &#123; if root == nil &#123; return &#125; path = append(path, root.Val) if root.Left == nil &amp;&amp; root.Right == nil &#123; s := 0 for i:=0;i&lt;len(path);i++ &#123; s = s*10 + path[i] &#125; *ret += s &#125; if root.Left != nil &#123; dfs(root.Left, path, ret) &#125; if root.Right != nil&#123; dfs(root.Right, path, ret) &#125;&#125; 深度遍历，非递归12345678910111213141516171819202122232425262728293031func sumNumbers(root *TreeNode) int&#123; if root == nil&#123; return 0 &#125; var stack []*TreeNode stack = append(stack,root) s := 0 for len(stack) &gt;0 &#123; current := stack[len(stack)-1] stack = stack[0:len(stack)-1] if current.Right != nil &#123; current.Right.Val += current.Val*10 stack = append(stack, current.Right) &#125; if current.Left != nil &#123; current.Left.Val += current.Val*10 stack = append(stack, current.Left) &#125; if current.Left == nil &amp;&amp; current.Right == nil &#123; s += current.Val &#125; &#125; return s&#125; 广度遍历，非递归12345678910111213141516171819202122232425262728293031323334353637func sumNumbers(root *TreeNode) int &#123; return bfsNoRecursion(root)&#125;func bfsNoRecursion(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue, root) s := 0 for len(queue)&gt;0 &#123; current := queue[0] queue = queue[1:] if current.Left != nil &#123; current.Left.Val += current.Val*10 queue = append(queue, current.Left) &#125; if current.Right != nil &#123; current.Right.Val += current.Val*10 queue = append(queue, current.Right) &#125; if current.Left == nil &amp;&amp; current.Right == nil &#123; s += current.Val &#125; &#125; return s&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Populating Next Right Pointers in Each Node I&II]]></title>
    <url>%2F2018-01-02-L116-Populating-Next-Right-Pointers-in-Each-Node%2F</url>
    <content type="text"><![CDATA[L116 Populating Next Right Pointers in Each Node题目描述Given a binary tree12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space.You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).For example,Given the following perfect binary tree, 12345 1 / \ 2 3 / \ / \4 5 6 7 After calling your function, the tree should look like:12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL 解题思路空间复杂度O(n) 深度遍历，将相同level节点保存到list中，然后遍历list设置next指针 广度遍历，将相同level节点保存到队列中，下一层的节点保存到临时队列中，然后遍历list设置next指针 这里两个思路都可以解决L117的问题 使用常量空间复杂度 使用两个指针,依赖于上层已经建立的next关系 通过上层的next指针访问到右兄弟 此方案适合完全二叉树 Python代码实现深度遍历，空间复杂度O(n)12345678910111213141516171819202122232425262728class Solution: # @param root, a tree link node # @return nothing def connect(self, root): m = &#123;&#125; self.levelOrder(root, m, 0) for i in m: n = len(m[i]) k = 0 head = m[i][0] while k&lt;n-1: head.next = m[i][k+1] k += 1 head = head.next head.next = None def levelOrder(self, root, m, level): if not root: return if level in m: m[level].append(root) else: m[level] = [root] self.levelOrder(root.left, m, level+1) self.levelOrder(root.right, m, level+1) 广度遍历，空间复杂度O(n)123456789101112131415161718192021class Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return root queue = [] queue.append(root) while len(queue): n = len(queue) tmp = [] for i in range(n): if i&lt;n-1: queue[i].next = queue[i+1] if queue[i].left: tmp.append(queue[i].left) if queue[i].right: tmp.append(queue[i].right) queue = tmp L117 Populating Next Right Pointers in Each Node II题目描述Follow up for problem “Populating Next Right Pointers in Each Node”. What if the given tree could be any binary tree? Would your previous solution still work? Note: You may only use constant extra space.For example,Given the following binary tree, 12345 1 / \ 2 3 / \ \4 5 7 After calling your function, the tree should look like: 12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \4-&gt; 5 -&gt; 7 -&gt; NULL 解题思路 使用上述的深度遍历和广度遍历都可以AC，但是空间复杂度为O(n) 使用层次遍历 Python实现1234567891011121314151617181920class Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return root while root: dummy = TreeLinkNode(0) t = dummy while root: if root.left: t.next = root.left t = t.next if root.right: t.next = root.right t = t.next root = root.next root = dummy.next]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L230 Kth Smallest Element in a BST]]></title>
    <url>%2F2018-01-01-L230-Kth-Smallest-Element-in-a-BST%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Follow up:What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently?How would you optimize the kthSmallest routine? 解题思路 使用中序遍历，然后将path保存，返回path[k-1]的元素 Go代码实现 中序遍历，然后path[k-1] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package L230/** * Definition for a binary tree node. */type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func initBST(nums []int) *TreeNode &#123; var root *TreeNode for _,v := range nums&#123; root = insertNode(root,v) &#125; return root&#125;func insertNode(root *TreeNode, n int) *TreeNode &#123; if root == nil &#123; root = new(TreeNode) root.Val = n &#125;else&#123; if root.Val&gt;n &#123; root.Left = insertNode(root.Left, n) &#125;else&#123; root.Right = insertNode(root.Right, n) &#125; &#125; return root&#125;func kthSmallest(root *TreeNode, k int) int &#123; var path []int inOrder(root, &amp;path) return path[k-1]&#125;func inOrder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; inOrder(root.Left, path) *path = append(*path, root.Val) inOrder(root.Right, path)&#125; Runtime: 22 ms 83.3% 123456789101112131415161718func kthSmallest(root *TreeNode, k int) int &#123; ret := 0 n := 0 inOrder(root, &amp;ret,&amp;n,k) return ret&#125;func inOrder(root *TreeNode, ret *int, n *int, k int) &#123; if root == nil &#123; return &#125; inOrder(root.Left, ret, n, k) *n += 1 if *n==k &#123; *ret = root.Val &#125; inOrder(root.Right, ret, n,k)&#125; Go代码实现——中序递归加入K个数判断1234567891011121314151617181920func kthSmallest(root *TreeNode, k int) int &#123; var path []int inOrder(root, &amp;path, k) return path[k-1]&#125;func inOrder(root *TreeNode, path *[]int, k int) &#123; if root == nil &#123; return &#125; inOrder(root.Left, path, k) if len(*path) &lt; k &#123; *path = append(*path, root.Val) &#125;else&#123; return &#125; inOrder(root.Right, path, k)&#125; Runtime: 44ms 效果反而更差了。 Go代码实现——中序循环迭代实现11234567891011121314151617181920212223func kthSmallest(root *TreeNode, k int) int &#123; var stack []*TreeNode stack = append(stack, root) path := []int&#123;&#125; for len(stack)&gt;0 &#123; current := stack[len(stack)-1] for current!=nil&#123; current = current.Left stack = append(stack, current) &#125; stack = stack[0:len(stack)-1] if len(stack)&gt;0 &#123; current = stack[len(stack)-1] stack = stack[0:len(stack)-1] path = append(path, current.Val) stack = append(stack, current.Right) &#125; &#125; return path[k-1]&#125; 12345678910111213141516171819202122232425262728func kthSmallest(root *TreeNode, k int) int &#123; var stack []*TreeNode ret := 0 stack = append(stack, root) for len(stack) &gt;0 &#123; current := stack[len(stack)-1] for current!=nil &#123; current = current.Left stack = append(stack, current) &#125; stack = stack[0:len(stack)-1] if len(stack)&gt;0 &#123; current = stack[len(stack)-1] stack = stack[0:len(stack)-1] k-- if k==0 &#123; ret = current.Val break &#125; stack = append(stack, current.Right) &#125; &#125; return ret&#125; Go代码实现——中序循环迭代实现21234567891011121314151617func kthSmallest(root *TreeNode, k int) int &#123; var stack []*TreeNode path := []int&#123;&#125; for root != nil || len(stack)&gt;0 &#123; if root != nil &#123; stack = append(stack, root) root = root.Left &#125;else&#123; root = stack[len(stack)-1] stack = stack[0:len(stack)-1] path = append(path, root.Val) root = root.Right &#125; &#125; return path[k-1]&#125; 1234567891011121314151617181920func kthSmallest(root *TreeNode, k int) int &#123; var stack []*TreeNode ret := 0 for root != nil || len(stack)&gt;0 &#123; if root != nil &#123; stack = append(stack, root) root = root.Left &#125;else&#123; root = stack[len(stack)-1] stack = stack[0:len(stack)-1] k-- if k==0 &#123; ret =root.Val break &#125; root = root.Right &#125; &#125; return ret&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L173 Binary Search Tree Iterator]]></title>
    <url>%2F2017-12-31-L173-Binary-Search-Tree-Iterator%2F</url>
    <content type="text"><![CDATA[题目描述Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.Calling next() will return the next smallest number in the BST.Note: next() and hasNext() should run in average O(1) time and uses O(h) memory,where h is the height of the tree. 解题思路解题思路1——保存中序遍历结果 二叉搜索树有序就是中序遍历，先将中序遍历保存到list中——空间复杂度为O(n) 解题思路2——实现O(h)空间复杂度 初始化的时候先中所有的left节点保存到stack中 next的时候stack栈顶元素，判断当前节点的right对应left节点压入栈。 Python代码实现Python实现——空间复杂度为O(n)12345678910111213141516171819202122232425262728class BSTIterator(object): def __init__(self, root): """ :type root: TreeNode """ self.nodes = [] self.preOrder(root, self.nodes) def preOrder(self, root, nodes): if not root: return self.preOrder(root.left, nodes) nodes.append(root.val) self.preOrder(root.right, nodes) def hasNext(self): """ :rtype: bool """ return len(self.nodes) &gt; 0 def next(self): """ :rtype: int """ if len(self.nodes): return self.nodes.pop(0) Python实现——空间复杂度为O(h)123456789101112131415161718192021222324252627class BSTIterator(object): def __init__(self, root): """ :type root: TreeNode """ self.stack = [] while root: self.stack.append(root) root = root.left def hasNext(self): """ :rtype: bool """ return len(self.stack) != 0 def next(self): """ :rtype: int """ current = self.stack[-1] left = current.right self.stack.pop(-1) while left: self.stack.append(left) left = left.left return current.val]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L199 Binary Tree Right Side View]]></title>
    <url>%2F2017-12-31-L199-Binary-Tree-Right-Side-View%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, imagine yourself standing on the right side of it,return the values of the nodes you can see ordered from top to bottom. For example:Given the following binary tree, 12345 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- You should return [1, 3, 4]. 解题思路深度遍历 深度遍历，将各个节点保存到属于同一个level的map中 按照level由小到大的顺序，返回各个level中最后一个节点 广度遍历 广度的遍历思想是使用队列 在广度遍历嵌套一个当前level的节点遍历，判断是当前level最后的一个节点则加入path中 Go代码实现Go代码实现——深度遍历记录各个level对应的节点并保存到map中1234567891011121314151617181920212223242526272829303132func rightSideView(root *TreeNode) []int &#123; m := map[int][]int&#123;&#125; h := travel(root, 0, m) path := []int&#123;&#125; for i:=0;i&lt;h; i++ &#123; arr := m[i] k := len(arr)-1 path = append(path,arr[k]) &#125; return path&#125;func travel(root *TreeNode, level int, m map[int][]int) int&#123; if root == nil &#123; return level &#125; if _, ok := m[level]; !ok &#123; m[level] = []int&#123;root.Val&#125; &#125; else &#123; m[level] = append(m[level], root.Val) &#125; l := travel(root.Left, level+1, m) r := travel(root.Right, level+1, m) if l&lt;r &#123; return r &#125;else&#123; return l &#125;&#125; Go代码实现——广度遍历123456789101112131415161718192021222324252627282930func rightSideView(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; var queue []*TreeNode queue = append(queue, root) path := []int&#123;&#125; for len(queue) &gt; 0 &#123; n := len(queue) for i := 0; i &lt; n; i++ &#123; current := queue[0] queue = queue[1:] if i == n-1 &#123; path = append(path, current.Val) &#125; if current.Left != nil &#123; queue = append(queue, current.Left) &#125; if current.Right != nil &#123; queue = append(queue, current.Right) &#125; &#125; &#125; return path&#125; Go代码实现——深度遍历高效的方法1234567891011121314151617181920212223func rightSideView(root *TreeNode) []int &#123; path := []int&#123;&#125; rightView(root, 0, &amp;path) return path&#125;func rightView(root *TreeNode, currentDepth int, path *[]int) &#123; if root == nil &#123; return &#125; if currentDepth == len(*path) &#123; *path = append(*path, root.Val) &#125; if root.Right != nil &#123; rightView(root.Right, currentDepth+1, path) &#125; if root.Left != nil &#123; rightView(root.Left, currentDepth+1, path) &#125;&#125; 深度遍历，右节点先遍历，判断当前currentDepth是否等于len(path)。注意前提条件是右节点先遍历。 参考资料本题目 https://www.geeksforgeeks.org/print-right-view-binary-tree-2/ https://leetcode.com/problems/binary-tree-right-side-view/discuss/56012/?page=1 Level遍历 https://www.geeksforgeeks.org/level-order-tree-traversal/ 广度遍历——使用队列12345678910111213141516171819202122232425func rightSideView(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; var queue []*TreeNode queue = append(queue, root) path := []int&#123;&#125; for len(queue) &gt; 0 &#123; current := queue[0] queue = queue[1:] path = append(path, current.Val) if current.Left != nil &#123; queue = append(queue, current.Left) &#125; if current.Right != nil &#123; queue = append(queue, current.Right) &#125; &#125; return path&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L236 Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2F2017-12-31-L236-Lowest-Common-Ancestor-of-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.According to the definition of LCA on Wikipedia:“The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” 1234567 _______3______ / \ ___5__ ___1__/ \ / \6 _2 0 8 / \ 7 4 For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3.Another example is LCA of nodes 5 and 4 is 5,since a node can be a descendant of itself according to the LCA definition. 解题思路 利用深度遍历，将各个节点的parent节点以及level保存在map 将p和q调整到同一个level，然后回溯其parent节点 Python代码实现Python基础代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ parent = &#123;&#125; level_map = &#123;&#125; self.dfs(root, parent, 0, level_map) if level_map[p] &gt; level_map[q]: p,q = q,p while level_map[q] &gt; level_map[p]: q = parent[q] while p != q: p = parent[p] q = parent[q] return p def initTree(self, root, nums, i, n): if i &lt; n: if nums[i] == -1: root = None return root else: root = TreeNode(nums[i]) root.left = self.initTree(root.left, nums, 2 * i + 1, n) root.right = self.initTree(root.right, nums, 2 * i + 2, n) return root return root def dfs(self, root, parent, level, level_map): if not root: return level_map[root] = level if root.left: parent[root.left] = root self.dfs(root.left, parent, level + 1, level_map) if root.right: parent[root.right] = root self.dfs(root.right, parent, level + 1, level_map) def preorder(self, root, path, nodes): if not root: return path.append(root.val) nodes.append(root) self.preorder(root.left, path,nodes) self.preorder(root.right, path,nodes) def printTree(self, root): path = [] self.preorder(root, path, []) return ' '.join([str(n) for n in path]) Runtime: 116 ms 44.69% Python测试用例12345678910111213141516171819class TestCase(unittest.TestCase): s = Solution() def test_1(self): nums = [3, 5, 1, 6, 2, 0, 8, -1, -1, 7, 4] root = self.s.initTree(None, nums, 0, len(nums)) ret = self.s.printTree(root) self.assertEqual(ret, "3 5 6 2 7 4 1 0 8") def test_2(self): nums = [3, 5, 1, 6, 2, 0, 8, -1, -1, 7, 4] root = self.s.initTree(None, nums, 0, len(nums)) nodes = [] self.s.preorder(root,[],nodes) lca_node = self.s.lowestCommonAncestor(root,nodes[1], nodes[-1]) self.assertEqual(lca_node, root)if __name__ == '__main__': unittest.main() 类似的题目 L235 其解题思路：利用二叉搜索树的顺序性 代码实现]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L404 Sum of Left Leaves]]></title>
    <url>%2F2017-12-29-L404-Sum-of-Left-Leaves%2F</url>
    <content type="text"><![CDATA[题目描述Find the sum of all left leaves in a given binary tree. Example: 12345 3 / \9 20 / \ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively.Return 24. 解题思路 使用深度遍历 记录前一个节点prev，判断prev.Left是否等于当前叶子节点，如果等于说明才是其左叶子节点。 递归和循环都实现一下 Go代码实现Go代码实现——递归1234567891011121314151617181920212223func sumOfLeftLeaves(root *TreeNode) int &#123; sum := 0 sumOfLeft(root, root, &amp;sum) return sum&#125;func sumOfLeft(root *TreeNode, prev *TreeNode, sum *int) &#123; if root == nil &#123; return &#125; if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; prev.Left == root &#123; *sum += root.Val &#125; if root.Left != nil &#123; sumOfLeft(root.Left, root, sum) &#125; if root.Right != nil &#123; sumOfLeft(root.Right, root, sum) &#125;&#125; Go代码实现——循环123456789101112131415161718192021222324252627282930func sumOfLeftLeaves(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; sum := 0 var stack []*TreeNode stack = append(stack, root) prev := root for len(stack)&gt;0 &#123; current := stack[len(stack)-1] stack = stack[0:len(stack)-1] if current.Left == nil &amp;&amp; current.Right == nil &amp;&amp; prev.Left == current &#123; sum += current.Val &#125; if current.Right != nil &#123; stack = append(stack, current.Right) prev = current &#125; if current.Left != nil &#123; stack = append(stack, current.Left) prev = current &#125; &#125; return sum&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L145 Binary Tree Postorder Traversal]]></title>
    <url>%2F2017-12-29-L145-Binary-Tree-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, return the postorder traversal of its nodes’ values. For example:Given binary tree {1,#,2,3},123451 \ 2 /3 return [3,2,1]. Note: Recursive solution is trivial, could you do it iteratively? 解题思路 后续递归，使用指针数组 后续递归，不使用指针数组 使用循环迭代 Go代码实现Go代码实现——后续递归，使用指针数组1234567891011121314151617181920func postorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; postOrder(root, &amp;path) return path&#125;func postOrder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; if root.Left != nil &#123; postOrder(root.Left, path) &#125; if root.Right != nil &#123; postOrder(root.Right, path) &#125; *path = append(*path, root.Val)&#125; Go代码实现——后续递归，不使用指针数组1234567891011func postorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; if root == nil &#123; return path &#125; path = append(path, postorderTraversal(root.Left)...) path = append(path, postorderTraversal(root.Right)...) path = append(path, root.Val) return path&#125; Go代码实现——使用stack循环迭代1234567891011121314151617181920212223242526272829303132func postorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; if root == nil &#123; return path &#125; var stack []*TreeNode stack = append(stack, root) head := root for len(stack)&gt;0 &#123; t := stack[len(stack)-1] if (t.Left == nil &amp;&amp; t.Right == nil) || t.Left == head || t.Right == head &#123; path = append(path, t.Val) stack = stack[0:len(stack)-1] head = t &#125;else&#123; if t.Right != nil &#123; stack = append(stack, t.Right) &#125; if t.Left != nil &#123; stack = append(stack, t.Left) &#125; &#125; &#125; return path&#125; Go代码实现——使用stack循环迭代，每个节点入栈2次12345678910111213141516171819202122232425262728293031func postorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; if root == nil &#123; return path &#125; var stack []*TreeNode stack = append(stack, root) stack = append(stack, root) for len(stack)&gt;0 &#123; current := stack[len(stack)-1] stack = stack[0:len(stack)-1] if len(stack)&gt;0 &amp;&amp; current == stack[len(stack)-1] &#123; if current.Right!=nil &#123; stack = append(stack, current.Right) stack = append(stack, current.Right) &#125; if current.Left != nil &#123; stack = append(stack, current.Left) stack = append(stack, current.Left) &#125; &#125;else &#123; path = append(path, current.Val) &#125; &#125; return path&#125; 保持栈的元素顺序为root.Left,root.Right,root(栈底)。对每个节点入栈2次，判断current是否为栈顶元素，如果是说明之前已经入栈过一次，无需再入栈了。 参考资料 http://www.cnblogs.com/grandyang/p/4251757.html http://www.cnblogs.com/rain-lei/p/3705680.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L144 Binary Tree Preorder Traversal]]></title>
    <url>%2F2017-12-29-L144-Binary-Tree-Preorder-Traversal%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, return the preorder traversal of its nodes’ values. For example:Given binary tree [1,null,2,3], 123451 \ 2 /3 return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 解题思路 前序遍历递归，使用指针数组 前序遍历递归，不使用指针数组 使用stack循环实现, 右节点先入栈，左节点后入栈 Go代码实现Go代码实现1——前序递归遍历，使用指针数组123456789101112131415func preorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; preorder(root, &amp;path) return path&#125;func preorder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; *path = append(*path, root.Val) preorder(root.Left, path) preorder(root.Right, path)&#125; Go代码实现2–前序递归遍历，不使用指针数组123456789101112func preorderTraversal(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; path := []int&#123;&#125; path = append(path, root.Val) path = append(path, preorderTraversal(root.Left)...) path = append(path, preorderTraversal(root.Right)...) return path&#125; Go代码实现3——使用stack循环实现123456789101112131415161718192021222324func preorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; if root == nil &#123; return path &#125; var stack []*TreeNode stack = append(stack, root) for len(stack)&gt;0 &#123; root := stack[len(stack)-1] stack = stack[0:len(stack)-1] path = append(path, root.Val) if root.Right != nil &#123; stack = append(stack, root.Right) &#125; if root.Left != nil &#123; stack = append(stack, root.Left) &#125; &#125; return path&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L572 Subtree of Another Tree]]></title>
    <url>%2F2017-12-29-L572-Subtree-of-Another-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given two non-empty binary trees s and t,check whether tree t has exactly the same structure and node values with a subtree of s.A subtree of s is a tree consists of a node in s and all of this node’s descendants.The tree s could also be considered as a subtree of itself. Example 1:Given tree s:12345 3 / \ 4 5 / \1 2 Given tree t:123 4 / \1 2 Return true, because t has the same structure and node values with a subtree of s.Example 2:Given tree s:1234567 3 / \ 4 5 / \1 2 / 0 Given tree t:123 4 / \1 2 Return false. 解题思路 先找到s和t的相同的节点，然后再比较s和t是否相同 如果当前子树不相同，再比较其他子树 Go实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package L572/** * Definition for a binary tree node. */ type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode &#125;func initTree(root *TreeNode, nums []int, index int, n int) *TreeNode &#123; if index&lt;n &#123; if nums[index] == -1 &#123; root = nil return root &#125;else&#123; root := new(TreeNode) root.Val = nums[index] root.Left = initTree(root.Left, nums, 2*index+1, n) root.Right = initTree(root.Right, nums, 2*index+2, n) return root &#125; &#125; return root&#125;func inorder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; inorder(root.Left, path) *path = append(*path, root.Val) inorder(root.Right, path)&#125;func isSubtree(s *TreeNode, t *TreeNode) bool &#123; if t == nil &#123; return true &#125; if s == nil &#123; return false &#125; result := false if s.Val == t.Val &#123; result = isSame(s, t) &#125; if !result&#123; result = isSubtree(s.Left, t) &#125; if !result &#123; result = isSubtree(s.Right, t) &#125; return result&#125;func isSame(s *TreeNode, t *TreeNode) bool &#123; if s!= nil &amp;&amp; t != nil &amp;&amp; s.Val == t.Val &#123; return isSame(s.Left, t.Left) &amp;&amp; isSame(s.Right, t.Right) &#125;else if s == nil &amp;&amp; t == nil&#123; return true &#125;else&#123; return false &#125;&#125; 这里判断两个TreeNode节点是否，是比较其Val是否相同。如果Val相同才有比较子树是否相同的可能。即使树中出现多个Val相同的情况，除非子树相同，否则就不会返回是子树。Runtime: 39 ms 80.00%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Combination Sum]]></title>
    <url>%2F2017-12-28-Combination-Sum%2F</url>
    <content type="text"><![CDATA[题目描述L39题目描述Given a set of candidate numbers (C) (without duplicates) and a target number (T),find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is:1234[ [7], [2, 2, 3]] L40题目描述Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is: 123456[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 解题思路 使用DFS遍历 引入三个变量，ret记录所有路径，path记录当前路径，index记录索引，t为target-nums[i] Go代码实现L39 Go实现12345678910111213141516171819202122232425262728293031323334package L39import "sort"func combinationSum(candidates []int, target int) [][]int &#123; ret :=[][]int&#123;&#125; sort.Ints(candidates) path := []int&#123;&#125; combination(&amp;ret,path, candidates, target, 0) return ret&#125;func combination(ret *[][]int, path []int, nums []int, target int, index int) &#123; for i:=index; i&lt;len(nums); i++ &#123; t := target - nums[i] if t&lt;0 &#123; return &#125;else&#123; path = append(path, nums[i]) if t == 0 &#123; tmp := make([]int, len(path)) copy(tmp, path) *ret = append(*ret, tmp) &#125;else&#123; combination(ret, path, nums, t, i) &#125; path = path[0:len(path)-1] &#125; &#125;&#125; L39是当前的元素可以被重复考虑Runtime: 6 ms 91.53% L40代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package L40import "sort"func combinationSum2(candidates []int, target int) [][]int &#123; ret :=[][]int&#123;&#125; sort.Ints(candidates) path := []int&#123;&#125; combination(&amp;ret,path, candidates, target, 0) return ret&#125;func isInArray(ret [][]int, arr []int) bool &#123; for _,v := range ret &#123; flag := true for j,n := range arr&#123; if v[j] != n &#123; flag = false break &#125; &#125; if flag &#123; return true &#125; &#125; return false&#125;func combination(ret *[][]int, path []int, nums []int, target int, index int) &#123; for i:=index; i&lt;len(nums); i++ &#123; t := target - nums[i] if t&lt;0 &#123; return &#125;else&#123; path = append(path, nums[i]) if t==0 &#123; tmp := make([]int, len(path)) copy(tmp, path) if isInArray(*ret, tmp) != true&#123; *ret = append(*ret, tmp) &#125; &#125;else &#123; combination(ret, path, nums, t, i+1); &#125; path = path[0:len(path)-1] &#125; &#125;&#125; 每个元素只能被计算一次，故在递归的时候，index设置为i+1。需要判断path是否在ret中出现。Runtime: 9 ms 38.4%。更进一步优化：如何去除数组是否存在的判断？ 12345678910111213141516171819202122232425262728293031323334package L40import "sort"func combinationSum2(candidates []int, target int) [][]int &#123; ret := [][]int&#123;&#125; sort.Ints(candidates) path := []int&#123;&#125; combination(&amp;ret, path, candidates, target, 0) return ret&#125;func combination(ret *[][]int, path []int, nums []int, target int, index int) &#123; for i:=index; i&lt;len(nums); i++ &#123; t := target - nums[i] if t&lt;0 &#123; return &#125;else if i == index || nums[i] != nums[i-1] &#123; #nums[i] != nums[i-1]相同的情况，跳过，避免重复计算 path = append(path, nums[i]) if t==0 &#123; tmp := make([]int, len(path)) copy(tmp, path) *ret = append(*ret, tmp) &#125;else &#123; combination(ret, path, nums, t, i+1) &#125; path = path[0:len(path)-1] &#125; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L33 Search in Rotated Sorted Array]]></title>
    <url>%2F2017-12-28-L33-Search-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[题目描述Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 解题思路 基本思想还是使用二分搜索的思路，但是二分思想是基于有序的数组 通过low++以及high–和target进行比较，将数组变成有序的，然后再进行二分 Go代码实现1234567891011121314151617181920212223242526272829package L33func search(nums []int, target int) int &#123; low := 0 high := len(nums) - 1 for low &lt;= high &#123; for low &lt;= high &amp;&amp; nums[high] &lt; target &#123; high-- &#125; for low &lt;= high &amp;&amp; nums[low] &gt; target &#123; low++ &#125; mid := (low + high) / 2 if nums[mid] == target &#123; return mid &#125; else if nums[mid] &gt; target &#123; high = mid - 1 &#125; else &#123; low = mid + 1 &#125; &#125; return -1&#125; Runtime: 9 ms 10.00%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L34 Search for a Range]]></title>
    <url>%2F2017-12-28-L34-Search-for-a-Range%2F</url>
    <content type="text"><![CDATA[题目描述Given an array of integers sorted in ascending order,find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 解题思路 题目明确使用O(log n)时间复杂度，故采用二分搜索的算法 因为需要找到start以及end，在nums[mid]和target匹配上之后，再进行递归迭代找到所有 Go代码实现Go代码实现——基础功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package L34func searchRange(nums []int, target int) []int &#123; if len(nums) == 0&#123; return []int&#123;-1,-1&#125; &#125; high := len(nums)-1 low := 0 start := high+1 end := -1 ret := []int&#123;&#125; binarySearch(nums, target,low, high, &amp;start, &amp;end) if start == high+1&#123; start = -1 &#125; ret = append(ret, start) ret = append(ret, end) return ret&#125;func binarySearch(nums []int, target int, low int, high int, start *int, end *int) &#123; var mid int for low&lt;=high &#123; mid = (low + high) / 2 if nums[mid] == target &#123; if mid &lt;*start &#123; *start = mid &#125; if mid &gt; *end &#123; *end = mid &#125; if low&lt;=mid-1 &#123; binarySearch(nums,target, low, mid-1, start, end) &#125; if mid+1&lt;=high&#123; binarySearch(nums, target,mid+1, high,start, end) &#125; return &#125; else if nums[mid] &gt; target &#123; high = mid - 1 &#125; else &#123; low = mid + 1 &#125; &#125;&#125; Runtime: 16 ms 61.11% Go代码实现——测试用例1234567891011121314151617181920212223242526272829303132package L34import ( "testing")func TestSearchRangeCase1(t *testing.T) &#123; nums := []int&#123;5, 7, 7, 8, 8, 10&#125; ret := searchRange(nums, 8) if ret[0] != 3 || ret[1] != 4 &#123; t.Error("Test SearchRange Case 1 failed") &#125;&#125;func TestSearchRangeCase2(t *testing.T) &#123; nums := []int&#123;1&#125; ret := searchRange(nums, 0) if ret[0] != -1 || ret[1] != -1 &#123; t.Error("Test SearchRange Case 2 failed") &#125;&#125;func TestSearchRangeCase3(t *testing.T) &#123; nums := []int&#123;&#125; ret := searchRange(nums, 0) if ret[0] != -1 || ret[1] != -1 &#123; t.Error("Test SearchRange Case 3 failed") &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L92 Reverse Linked List II]]></title>
    <url>%2F2017-12-27-L92-Reverse-Linked-List-II%2F</url>
    <content type="text"><![CDATA[题目描述Reverse a linked list from position m to n. Do it in-place and in one-pass. For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4, return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note:Given m, n satisfy the following condition:1 ≤ m ≤ n ≤ length of list. 解题思路 定位到m和n位置对应的节点p1和p2，链表在p2位置断开，这样将链表分为3个部分 将p1进行翻转之后，然后将3个部分链表拼接起来 注意点：p1是否为head Go代码实现Go代码实现——基础功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package L92import ( "strconv")/** * Definition for singly-linked list. */type ListNode struct &#123; Val int Next *ListNode&#125;func reverseBetween(head *ListNode, m int, n int) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; var p1 *ListNode var p2 *ListNode var p *ListNode var p3 *ListNode nList := lenOfList(head) prev := head next := head current := head idx := 1 for idx &lt; m &amp;&amp; idx &lt; nList &#123; prev = current current = current.Next idx++ &#125; p1 = current if p1 != head &#123; next = prev.Next prev.Next = nil current = next &#125; for idx &lt; n &amp;&amp; idx &lt; nList &#123; current = current.Next idx++ &#125; p2 = current p3 = current.Next p2.Next = nil p = reverse(p1) if p1 == head &#123; p1.Next = p3 return p &#125; else &#123; prev.Next = p p1.Next = p3 return head &#125;&#125;func reverse(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; newHead := reverse(head.Next) head.Next.Next = head head.Next = nil return newHead&#125;func lenOfList(head *ListNode) int &#123; n := 1 current := head for current != nil &#123; n++ current = current.Next &#125; return n&#125;func initList(nums []int) *ListNode &#123; head := new(ListNode) current := head for _, n := range nums &#123; node := new(ListNode) node.Val = n current.Next = node current = current.Next &#125; return head.Next&#125;func printList(head *ListNode) string &#123; ret := "" if head == nil &#123; return ret &#125; for head.Next != nil &#123; ret += strconv.Itoa(head.Val) + "-&gt;" head = head.Next &#125; ret += strconv.Itoa(head.Val) return ret&#125; Runtime: 0 ms 50.00% Go代码实现——测试用例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package L92import ( "testing")func TestInitList(t *testing.T) &#123; nums := []int&#123;1, 2, 3, 4&#125; head := initList(nums) ret := printList(head) if ret != "1-&gt;2-&gt;3-&gt;4" &#123; t.Error("Test init List failed") &#125;&#125;func TestReverseBetweenCase1(t *testing.T) &#123; nums := []int&#123;1, 2, 3, 4, 5&#125; head := initList(nums) head = reverseBetween(head, 2, 4) ret := printList(head) if ret != "1-&gt;4-&gt;3-&gt;2-&gt;5" &#123; t.Error("Test reverse between case1 failed") &#125;&#125;func TestReverseBetweenCase2(t *testing.T) &#123; nums := []int&#123;3, 5&#125; head := initList(nums) head = reverseBetween(head, 2, 2) ret := printList(head) if ret != "3-&gt;5" &#123; t.Error("Test reverse between case2 failed") &#125;&#125;func TestReverseBetweenCase3(t *testing.T) &#123; nums := []int&#123;3, 5&#125; head := initList(nums) head = reverseBetween(head, 1, 1) ret := printList(head) if ret != "3-&gt;5" &#123; t.Error("Test reverse between case3 failed") &#125;&#125;func TestReverseBetweenCase4(t *testing.T) &#123; nums := []int&#123;1, 2, 3&#125; head := initList(nums) head = reverseBetween(head, 1, 2) ret := printList(head) if ret != "2-&gt;1-&gt;3" &#123; t.Error("Test reverse between case4 failed") &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L143 Reorder List]]></title>
    <url>%2F2017-12-27-L143-Reorder-List%2F</url>
    <content type="text"><![CDATA[题目描述Given a singly linked list L:$L0&rarr;L1&rarr;&hellip;&rarr;Ln-1&rarr;Ln,$ reorder it to:$L0&rarr;Ln&rarr;L1&rarr;Ln-1&rarr;L2&rarr;Ln-2&rarr;&hellip;$ You must do this in-place without altering the nodes’ values. For example,Given {1,2,3,4}, reorder it to {1,4,2,3}. 解题思路 使用两个指针slow和fast，slow移动一次，fast移动两次，直到fast为最后一个元素 在slow的地方将链表断开，将slow之后的list翻转 将head和slow进行一一merge合并 Go实现12345678910111213141516171819202122232425262728293031323334353637383940func reorderList(head *ListNode) &#123; if head == nil || head.Next == nil&#123; return &#125; slow := head fast := head var prev *ListNode for fast != nil &amp;&amp; fast.Next != nil &#123; fast = fast.Next.Next prev = slow slow = slow.Next &#125; prev.Next = nil current1 := head current2 := reverseList(slow) for current1.Next != nil &amp;&amp; current2.Next != nil&#123; next1 := current1.Next current1.Next = current2 next2 := current2.Next current2.Next = next1 current1 = next1 current2 = next2 &#125; current1.Next = current2&#125;func reverseList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead&#125; Runtime: 25 ms 50.00%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L328 Odd Even Linked List]]></title>
    <url>%2F2017-12-27-L328-Odd-Even-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011121314Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.Note:The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ...Credits:Special thanks to @DjangoUnchained for adding this problem and creating all test cases. 解题思路 使用两个指针，一个表示odd，一个表示even 然后将event加到odd的最后一个 Go实现Go实现11234567891011121314151617181920212223242526272829func oddEvenList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; var odd_head *ListNode var even_head *ListNode current:= head idx := 1 for current != nil&#123; next := current.Next current.Next = nil if idx % 2 == 0 &#123; even_head = insertNode(even_head, current) &#125;else&#123; odd_head = insertNode(odd_head, current) &#125; current = next idx+=1 &#125; tail := odd_head for tail.Next != nil &#123; tail = tail.Next &#125; tail.Next = even_head return odd_head&#125; Runtime: 39 ms Go实现21234567891011121314151617181920212223242526272829303132333435363738func oddEvenList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; var odd_head *ListNode var odd_tail *ListNode var even_head *ListNode var event_tail *ListNode current := head idx := 1 for current != nil &#123; next := current.Next current.Next = nil if idx%2 == 0 &#123; if even_head == nil&#123; even_head = current event_tail = current &#125;else&#123; event_tail.Next = current event_tail = current &#125; &#125; else &#123; if odd_head == nil&#123; odd_head = current odd_tail = current &#125;else&#123; odd_tail.Next = current odd_tail = current &#125; &#125; current = next idx += 1 &#125; odd_tail.Next = even_head return odd_head&#125; 记录odd以及even的tail节点，直接在tail节点后面插入，而非每次插入节点都找到tail节点Runtime: 9 ms 10% Go程序——测试用例1234567891011121314151617181920212223242526272829303132333435package L328import ( "testing")func TestInitList(t *testing.T) &#123; nums := []int&#123;1, 2, 3, 4&#125; head := initList(nums) ret := printList(head) if ret != "1-&gt;2-&gt;3-&gt;4"&#123; t.Error("Test init List failed") &#125;&#125;func TestOddEvenListCase1(t *testing.T) &#123; nums := []int&#123;1,2,3,4,5&#125; head := initList(nums) head = oddEvenList(head) ret := printList(head) if ret != "1-&gt;3-&gt;5-&gt;2-&gt;4" &#123; t.Error("Test oddEvenList Case1 failed") &#125;&#125;func TestOddEvenListCase2(t *testing.T) &#123; nums := []int&#123;2,1,4,3,6,5,7,8&#125; head := initList(nums) head = oddEvenList(head) ret := printList(head) if ret != "2-&gt;4-&gt;6-&gt;7-&gt;1-&gt;3-&gt;5-&gt;8"&#123; t.Error("test oddEvenList Case2 failed") &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L725 Split Linked List in Parts]]></title>
    <url>%2F2017-12-26-L725-Split-Linked-List-in-Parts%2F</url>
    <content type="text"><![CDATA[题目描述12345678910111213141516171819Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list &quot;parts&quot;.The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.Return a List of ListNode&apos;s representing the linked list parts that are formed.Example 2:Input: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]Explanation:The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.Note:The length of root will be in the range [0, 1000].Each value of a node in the input will be an integer in the range [0, 999].k will be an integer in the range [1, 50]. 解题思路 题目描述很长，首先根据list的长度n以及k算好各个部分的长度，基数为n/k，按照n%k对前面的部分进行加1 遍历list，按照各个部分的长度进行切分 Go代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546func splitListToParts(root *ListNode, k int) []*ListNode &#123; ret := []*ListNode&#123;&#125; n := lenOfList(root) arr := getArr(n, k) current := root for i:=0; i&lt;k; i++ &#123; if current == nil &#123; ret = append(ret, nil) &#125;else&#123; head:= current for j:=0;j&lt;arr[i]-1;j++ &#123; current = current.Next &#125; next := current.Next current.Next = nil current = next ret = append(ret, head) &#125; &#125; return ret&#125;func getArr(n int, k int) []int &#123; delta:=n%k arr := make([]int, k) for i:=0; i&lt;k;i++ &#123; arr[i] = n/k &#125; for i:=0; i&lt;delta;i++ &#123; arr[i] += 1 &#125; return arr&#125;func lenOfList(head *ListNode) int &#123; n := 0 current := head for current != nil &#123; current = current.Next n++ &#125; return n&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L445 Add Two Numbers II]]></title>
    <url>%2F2017-12-26-L445-Add-Two-Numbers-II%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed.Example:Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 解题思路 将各自list转换为int，然后将int转换为list表示，在Go会遇到int越界问题 将各自list转换为array，然后计算两个array相加，并在加的时候生成list 代码实现Python实现1234567891011121314151617181920212223242526272829303132class Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ n1 = self.listToInt(l1) n2 = self.listToInt(l2) return self.intToList(n1+n2) def listToInt(self, head): n = 0 while head: n = n * 10 + head.val head = head.next return n def intToList(self, n): if n == 0: return ListNode(n) #在head前面插入新节点 head = None while n: node = ListNode(n%10) n = n/10 node.next = head head = node return head 需要增加如下的测试，l1=[0] 和l2=[0]的情况Runtime: 142 ms, 39.01.00% Go实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; nums1 := listToArr(l1) nums2 := listToArr(l2) return addTwoArr(nums1, nums2)&#125;func listToArr(head *ListNode) []int &#123; arr := []int&#123;&#125; for head != nil &#123; arr = append(arr, head.Val) head = head.Next &#125; return arr&#125;func addTwoArr(nums1 []int, nums2 []int) *ListNode &#123; n1 := len(nums1)-1 n2 := len(nums2)-1 var head *ListNode ret := 0 n:=0 for n1&gt;=0 || n2&gt;=0 &#123; if n1&gt;=0 &amp;&amp; n2&gt;=0 &#123; n = ret + nums1[n1] + nums2[n2] n1-- n2-- &#125;else if n1&gt;=0 &#123; n = ret + nums1[n1] n1-- &#125;else if n2&gt;=0&#123; n = ret + nums2[n2] n2-- &#125; ret = n/10 n = n % 10 node:= new(ListNode) node.Val = n node.Next = head head = node &#125; if ret &gt;0 &#123; node := new(ListNode) node.Val = ret node.Next = head head = node &#125; return head&#125; Runtime: 35 ms 23.53%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L148 Sort List]]></title>
    <url>%2F2017-12-26-L148-Sort-List%2F</url>
    <content type="text"><![CDATA[题目描述1Sort a linked list in O(n log n) time using constant space complexity. 解题思路 排序中O(nlogn)时间复杂度有快速排序、归并排序以及对堆排序 适合链表的只有归并排序 代码实现Go代码实现Go代码函数包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package L148import ( "strconv")/** * Definition for singly-linked list. */type ListNode struct &#123; Val int Next *ListNode&#125;func sortList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; slow := head fast := head prev := head for fast != nil &amp;&amp; fast.Next != nil &#123; fast = fast.Next.Next prev = slow slow = slow.Next &#125; prev.Next = nil return merge(sortList(head), sortList(slow))&#125;func merge(head1 *ListNode, head2 *ListNode) *ListNode &#123; if head1 == nil&#123; return head2 &#125; if head2 == nil &#123; return head1 &#125; if head1.Val&lt;head2.Val &#123; head1.Next = merge(head1.Next, head2) return head1 &#125;else&#123; head2.Next = merge(head1, head2.Next) return head2 &#125;&#125;func initList(nums []int) *ListNode &#123; head := new(ListNode) current := head for _, n := range nums &#123; node := new(ListNode) node.Val = n current.Next = node current = current.Next &#125; return head.Next&#125;func printList(head *ListNode) string &#123; ret := "" if head == nil&#123; return ret &#125; for head.Next != nil &#123; ret += strconv.Itoa(head.Val) + "-&gt;" head = head.Next &#125; ret += strconv.Itoa(head.Val) return ret&#125; Go函数测试用例12345678910111213141516171819202122232425262728293031323334353637package L148import ( "testing")func TestInitList(t *testing.T) &#123; nums := []int&#123;1, 2, 3, 4, 5&#125; head := initList(nums) ret := printList(head) if ret != "1-&gt;2-&gt;3-&gt;4-&gt;5" &#123; t.Error("Test Init failed") &#125;&#125;func TestMerge(t *testing.T) &#123; nums1 := []int&#123;1,3,5&#125; nums2 := []int&#123;2,4&#125; head1 := initList(nums1) head2 := initList(nums2) head := merge(head1, head2) ret := printList(head) if ret != "1-&gt;2-&gt;3-&gt;4-&gt;5" &#123; t.Error("Test Merge failed") &#125;&#125;func TestSort(t *testing.T)&#123; nums := []int&#123;5,4,3,2,1&#125; head := initList(nums) head = sortList(head) ret := printList(head) if ret != "1-&gt;2-&gt;3-&gt;4-&gt;5" &#123; t.Error("Test Sort failed") &#125;&#125; Runtime 26 ms Python实现 Python中使用上述相同的代码会遇到RuntimeError: maximum recursion depth exceeded。将merge部分的递归算法修改为使用循环的方式，可以解决这个问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head slow = head fast = head prev = head while fast and fast.next: fast = fast.next.next prev = slow slow = slow.next prev.next = None return self.merge(self.sortList(head), self.sortList(slow)) def merge(self, head1, head2): if not head1: return head2 if not head2: return head1 newHead = ListNode(0) current = newHead while head1 and head2: if head1.val &lt; head2.val: current.next = head1 head1 = head1.next else: current.next = head2 head2 = head2.next current = current.next if head1: current.next = head1 elif head2: current.next = head2 return newHead.next def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([5, 4, 3, 2, 1]) ret = self.s.printList(head) self.assertEqual(ret, "5-&gt;4-&gt;3-&gt;2-&gt;1") def test_2(self): head = self.s.initList([5, 4, 3, 2, 1]) head = self.s.sortList(head) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4-&gt;5") def test_3(self): head = self.s.initList([1, 2, 3, 4, 5]) head = self.s.sortList(head) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4-&gt;5") def test_4(self): head1 = self.s.initList([1, 3, 5]) head2 = self.s.initList([2, 4]) head = self.s.merge(head1, head2) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4-&gt;5")if __name__ == '__main__': unittest.main() Runtime 412 ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L86 Partition List]]></title>
    <url>%2F2017-12-23-L86-Partition-List%2F</url>
    <content type="text"><![CDATA[题目描述12345678Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions.For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 解题思路空间复杂度O(n)和时间复杂度O(n) 使用left和right两个指针，构建左右两个子链表，然后把两个子链表连接起来 不使用额外空间 首先计算节点个数以及最后一个节点tail 遍历链表，将节点值大于等于x的节点移动到tail后面 代码实现Python实现1-空间复杂度和时间复杂度都为O(n)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def partition(self, head, x): """ :type head: ListNode :type x: int :rtype: ListNode """ if not head: return head left = None right = None newHead = None newRight = None while head: if head.val&lt;x: if not left: left = ListNode(head.val) newHead = left else: left.next = ListNode(head.val) left = left.next else: if not right: right = ListNode(head.val) newRight = right else: right.next = ListNode(head.val) right = right.next head = head.next if left: left.next = newRight return newHead else: return newRight def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([1, 2, 3, 4]) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4") def test_2(self): head = self.s.initList([1, 4, 3, 2, 5, 2]) head = self.s.partition(head, 3) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5") def test_3(self): head = self.s.initList([1]) head = self.s.partition(head,0) ret = self.s.printList(head) print retif __name__ == '__main__': unittest.main() Runtime 46 ms, 22.16% Python实现-不使用额外空间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def partition(self, head, x): """ :type head: ListNode :type x: int :rtype: ListNode """ if not head or not head.next: return head tail = head n = 1 while tail.next: tail = tail.next n += 1 prev = ListNode(0) prev.next = head current = head tmp = tail idx = 0 while idx&lt;n and current.next: if current.val &gt;=x: if current == head: head = current.next prev.next = head else: prev.next = current.next tmp.next = current current.next = None current = prev.next tmp = tmp.next else: current = current.next prev = prev.next idx+=1 return head def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([1, 2, 3, 4]) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4") def test_2(self): head = self.s.initList([1, 4, 3, 2, 5, 2]) head = self.s.partition(head, 3) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5") def test_3(self): head = self.s.initList([1]) head = self.s.partition(head,0) ret = self.s.printList(head) self.assertEqual(ret, "1") def test_4(self): head = self.s.initList([2,3,4]) head = self.s.partition(head, 1) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;3-&gt;4") def test_5(self): head = self.s.initList([1,2]) head = self.s.partition(head, 2) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2") def test_6(self): head = self.s.initList([2,1]) head = self.s.partition(head, 1) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;1")if __name__ == '__main__': unittest.main()]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L24 Swap Nodes in Pairs]]></title>
    <url>%2F2017-12-23-L24-Swap-Nodes-in-Pairs%2F</url>
    <content type="text"><![CDATA[题目描述1234567Given a linked list, swap every two adjacent nodes and return its head.For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解题思路 使用三个指针进行处理，prev为前一个节点，p1和p2表示pair，将p1和p2指向进行交换 使用递归的方法,将newHead设置为head，递归head.next.next返回node，将newHead、head以及node的指针调整一下 Python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head p1 = head p2 = head.next newHead = None prev = ListNode(0) while p2: p1.next = p2.next p2.next = p1 prev.next = p2 if not newHead: newHead = prev prev = p1 p1 = p1.next if p1: p2 = p1.next else: break return newHead.next def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([1, 2, 3, 4]) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4") def test_2(self): head = self.s.initList([1, 2, 3, 4]) head = self.s.swapPairs(head) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;1-&gt;4-&gt;3") def test_3(self): head = self.s.initList([1,2]) head = self.s.swapPairs(head) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;1") def test_4(self): head = self.s.initList([1,2,3]) head = self.s.swapPairs(head) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;1-&gt;3")if __name__ == '__main__': unittest.main() Python递归实现123456789101112131415class Solution(object): def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head newHead = head.next node = self.swapPairs(head.next.next) newHead.next = head head.next = node return newHead]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L82 Remove Duplicates from Sorted List II]]></title>
    <url>%2F2017-12-23-L82-Remove-Duplicates-from-Sorted-List-II%2F</url>
    <content type="text"><![CDATA[题目描述123456Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 相似题目 L83 Remove Duplicates from Sorted List 解题思路 在L83中，是删除重复的节点，但是保留一个节点，本题目是不保留，所有都删除 在L83中是slow和fast两个指针就足够 在本题目需要使用3个指针，增加一个prev指针，记录slow前一个节点，slow和fast进行比较 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head slow = head fast = head.next prev = None while fast: flag = False while fast and fast.val == slow.val: slow.next = fast.next fast = fast.next flag = True if not flag: prev = slow else: if prev: prev.next = fast else: head = fast if fast: slow = slow.next fast = fast.next return head def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([1, 2, 3, 3, 4, 4, 5]) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5") def test_2(self): head = self.s.initList([1, 2, 3, 3, 4, 4, 5]) head = self.s.deleteDuplicates(head) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;5") def test_3(self): head = self.s.initList([1, 1, 1, 2, 3]) head = self.s.deleteDuplicates(head) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;3") def test_4(self): head = self.s.initList([1,1]) head = self.s.deleteDuplicates(head) ret = self.s.printList(head) self.assertEqual(ret, "")if __name__ == '__main__': unittest.main() Runtime: 49 ms, beats 67.2% of python submissions]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L61 Rotate List]]></title>
    <url>%2F2017-12-22-L61-Rotate-List%2F</url>
    <content type="text"><![CDATA[题目描述12345678Given a list, rotate the list to the right by k places, where k is non-negative.Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 解题思路解题思路1 计算链表的长度，重新设置k=k%n，保证k都比n小 使用slow和fast两个指针，初始化为head fast移动k步之后，判断fast是否为空，若为空，直接返回head 否则，将fast和slow都移动至fast为链表的最后一个节点 将fast.next指向head，然后slow.next为新的head，将slow.next断开 解题思路2 将链表收尾相连 从head开始走n-k%n步之后，将链表断开 代码实现Python实现1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not head: return head current = head n = 0 while current: current = current.next n += 1 k = k % n fast = head slow = head idx = 0 while fast and idx &lt; k: fast = fast.next idx += 1 if not fast: return head while fast.next: fast = fast.next slow = slow.next fast.next = head fast = slow.next slow.next = None return fast def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([1, 2, 3, 4, 5]) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4-&gt;5") def test_2(self): head = self.s.initList([1, 2, 3, 4, 5]) head = self.s.rotateRight(head, 2) ret = self.s.printList(head) self.assertEqual(ret, "4-&gt;5-&gt;1-&gt;2-&gt;3") def test_3(self): head = self.s.initList([1, 2, 3, 4, 5]) head = self.s.rotateRight(head, 4) ret = self.s.printList(head) print ret def test_4(self): head = self.s.initList([1]) head = self.s.rotateRight(head, 99) ret = self.s.printList(head) self.assertEqual(ret, "1") def test_5(self): head = self.s.initList([1, 2]) head = self.s.rotateRight(head, 1) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;1") def test_6(self): head = self.s.initList([1, 2, 3]) head = self.s.rotateRight(head, 2000000000) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;3-&gt;1")if __name__ == '__main__': unittest.main() Python实现212345678910111213141516171819202122232425262728class Solution(object): def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not head or not head.next: return head current = head n = 1 while current.next: current = current.next n += 1 current.next = head k = n - k % n current = head idx = 1 while idx &lt; k: current = current.next idx += 1 newHead = current.next current.next = None return newHead]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L23 Merge k Sorted Lists]]></title>
    <url>%2F2017-12-21-L23-Merge-k-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[题目描述12Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 解题思路 选择首个非空list作为head，将其他list的数据有序的插入到list中，时间复杂度O(n*k),空间复杂为O(1) 递归合并两个list，合并list算法使用O(m+n)=O(N)时间复杂度，再加上合并时间复杂度O(logK)，总的复杂度为O(N*logN) LeetCode上Discuss中有使用Python库实现的，更快的方法 https://discuss.leetcode.com/topic/10448/python-133ms-solution Python实现 O(n*k)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype: ListNode """ if not lists: return None head = lists[0] idx = 1 n = len(lists) while idx &lt; n: current = lists[idx] idx += 1 if not head: head = current continue else: while current: next = current.next head = self.insertNode(head, current) current = next return head def insertNode(self, head, node): if not head: return node current = head prev = head while current and node.val &gt; current.val: prev = current current = current.next if prev != current: prev.next = node node.next = current return head else: node.next = prev return node def initList(self, nums): if not nums: return None head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): str = "" if not head: return str while head.next: str += "%d-&gt;" % head.val head = head.next str += "%d" % head.val return strclass Test(unittest.TestCase): s = Solution() def test_1(self): lists = [self.s.initList([]), self.s.initList([-1, 5, 11]), self.s.initList([]), self.s.initList([6, 10])] head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, "-1-&gt;5-&gt;6-&gt;10-&gt;11") def test_2(self): lists = [self.s.initList([]), self.s.initList([])] head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, "") def test_3(self): lists = [self.s.initList([0]), self.s.initList([1])] head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, "0-&gt;1") def test_4(self): lists = [self.s.initList([1]), self.s.initList([0])] head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, "0-&gt;1")if __name__ == '__main__': unittest.main() 使用Python单元测试Runtime: Runtime: 6182 ms Python实现212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution(object): def mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype: ListNode """ if not lists: return None return self.partion(lists, 0, len(lists)-1) def partion(self, lists, low, high): if low == high: return lists[low] else: if low&lt;high: mid = (low+high)/2 node1 = self.partion(lists, low, mid) node2 = self.partion(lists, mid+1, high) return self.mergeList(node1, node2) else: return None def mergeList(self, p, q): if not p: return q if not q: return p head = None current = head while p and q: if not head: if p.val &lt; q.val: head = p p = p.next else: head = q q = q.next current = head else: if p.val &lt; q.val: current.next = p p = p.next else: current.next = q q = q.next current = current.next while p: current.next = p p = p.next current = current.next while q: current.next = q q = q.next current = current.next return head Runtime: 145 ms ###Python实现3-全部使用递归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def mergeKLists(self, lists): &quot;&quot;&quot; :type lists: List[ListNode] :rtype: ListNode &quot;&quot;&quot; if not lists: return None return self.partion(lists, 0, len(lists)-1) def partion(self, lists, low, high): if low == high: return lists[low] else: if low&lt;high: mid = (low+high)/2 node1 = self.partion(lists, low, mid) node2 = self.partion(lists, mid+1, high) return self.mergeList(node1, node2) else: return None def mergeList(self, p, q): if not p: return q if not q: return p if p.val &lt; q.val: p.next = self.mergeList(p.next, q) return p else: q.next = self.mergeList(p, q.next) return q def insertNode(self, head, node): if not head: return node current = head prev = head while current and node.val &gt; current.val: prev = current current = current.next if prev != current: prev.next = node node.next = current return head else: node.next = prev return node def initList(self, twoDArr): lists = [] for nums in twoDArr: if not nums: lists.append(None) continue head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node lists.append(head) return lists def printList(self, head): str = &quot;&quot; if not head: return str while head.next: str += &quot;%d-&gt;&quot; % head.val head = head.next str += &quot;%d&quot; % head.val return strclass Test(unittest.TestCase): s = Solution() def test_1(self): lists = self.s.initList([[], [-1, 5, 11], [], [6, 10]]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, &quot;-1-&gt;5-&gt;6-&gt;10-&gt;11&quot;) def test_2(self): lists = self.s.initList([[], []]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, &quot;&quot;) def test_3(self): lists = self.s.initList([[0], [1]]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, &quot;0-&gt;1&quot;) def test_4(self): lists = self.s.initList([[1], [0]]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, &quot;0-&gt;1&quot;) def test_5(self): lists = self.s.initList([[1, 2, 2], [1, 1, 2]]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, &quot;1-&gt;1-&gt;1-&gt;2-&gt;2-&gt;2&quot;) def test_6(self): lists = self.s.initList([[1], [2]]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) print ret if __name__ == &apos;__main__&apos;: unittest.main() 将测试用例修改下，输入为二维数组，但是全部递归的程序，触发RuntimeError: maximum recursion depth exceeded]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L19 Remove Nth Node From End of List]]></title>
    <url>%2F2017-12-20-L19-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[题目描述12345678910Given a linked list, remove the nth node from the end of list and return its head.For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Try to do this in one pass. 解题思路 先获取List的长度，获取需要删除的第n个节点的前一个节点 如果当前节点是head，返回head.next 否则，将prev.next设置为current.next Python实现11234567891011121314151617181920212223242526272829303132class Solution(object): def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ if not head: return None current = head length = 0 while current: length+=1 current = current.next if n&gt;=length: n = n%length else: n = length-n current = head idx = 0 prev = current while idx&lt;n: prev = current current = current.next idx+=1 if current != head: prev.next = current.next return head else: return head.next Runtime: 59 ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L326 Power of Three]]></title>
    <url>%2F2017-12-20-L326-Power-of-Three%2F</url>
    <content type="text"></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L203 Range Sum Query Immutable]]></title>
    <url>%2F2017-12-20-L303-Range-Sum-Query-Immutable%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.Example:Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3Note:You may assume that the array does not change.There are many calls to sumRange function. 解题思路 针对每次输入都计算直接使用sum 无需额外空间 计算sum值，根据index输入输出 需要空间 Python实现1123456789101112131415class NumArray(object): def __init__(self, nums): """ :type nums: List[int] """ self.nums = nums def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ return sum(self.nums[i:j+1]) Runtime: 959 ms Python实现212345678910111213141516171819202122class NumArray(object): def __init__(self, nums): """ :type nums: List[int] """ self.sums =[] s = 0 for n in nums: s+=n self.sums.append(s) print self.sums def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ if i==0: return self.sums[j] else: return self.sums[j]-self.sums[i-1] Runtime: 109 ms Python实现31234567891011121314151617class NumArray(object): def __init__(self, nums): """ :type nums: List[int] """ self.sums = [0]*(len(nums)+1) for i in xrange(1,len(nums)+1): self.sums[i] = self.sums[i-1]+nums[i-1] def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ return self.sums[j+1]-self.sums[i] Runtime: 62ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Word Pattern]]></title>
    <url>%2F2017-12-19-L290-Word-Pattern%2F</url>
    <content type="text"><![CDATA[L290题目描述1234567891011Given a pattern and a string str, find if str follows the same pattern.Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.Examples:pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot; should return true.pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot; should return false.pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot; should return false.pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot; should return false.Notes:You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. 解题思路 使用map进行判断，将pattern每个字符作为key，判断对应的str上字符串val 如果pattern中单个字符不在map中，判断对应的val是否已经存在 如果pattern中字符在map中，判断当前的val和map对应的val是否相同 Python实现12345678910111213141516171819202122232425262728293031class Solution(object): def wordPattern(self, pattern, str): """ :type pattern: str :type str: str :rtype: bool """ m = &#123;&#125; tmp_list = str.split() n = len(pattern) if len(pattern) != len(tmp_list): return False for i in range(n): k = pattern[i] v = tmp_list[i] if k not in m: if v in m.values(): return False else: m[k] = v elif m[k] != v: return False return Trues = Solution()print s.wordPattern("abba", "dog cat cat dog")print s.wordPattern("abba", "dog cat cat fish")print s.wordPattern("aaaa", "dog cat cat dog")print s.wordPattern("abba", "dog dog dog dog") Runtime: 32 ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L283 Move Zeroes]]></title>
    <url>%2F2017-12-19-L283-Move-Zeroes%2F</url>
    <content type="text"><![CDATA[题目描述1234567Given an array nums, write a function to move all 0&apos;s to the end of it while maintaining the relative order of the non-zero elements.For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. 解题思路 逐个判断，如果当前数为0，在其后面的数中一个不为0的数与其交换。时间复杂度O(n*2)，无额外空间 使用两个索引进行i,j 初始化i=0,j=1如果nums[i]和nums[j]两个数都为非0，i++,j++如果nums[i]为0，nums[j]非零，将i和j交换，i++,j++如果nums[i]非零，nums[j]为0，将i++如果nums[i]为0，nums[j]非零，将j++ 使用两个索引 初始化pos=0，i=0当遇到nums[i]不为0的时候，将nums[i]赋值给nums[pos]， pos++,i++如果遇到nums[i]为0的时候，将i++将pos到list尾部所有元素，赋值为0 Python实现O(n*2)1234567891011121314151617181920212223242526class Solution(object): def moveZeroes(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ n = len(nums) i = 0 while i&lt;n: if nums[i] == 0: k = i+1 while k&lt;n: if nums[k]: break k+=1 if k&lt;n and nums[k]: nums[i],nums[k] = nums[k], nums[i] i += 1s = Solution()#nums = [0,0,1]nums = [0,1,0,3,12]s.moveZeroes(nums)print nums Runtime: 423 ms Python实现-O(n)1234567891011121314151617181920212223242526272829class Solution(object): def moveZeroes(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ n = len(nums) i = 0 j = 1 while i&lt;n-1 and j&lt;n: if nums[i] and nums[j]: i+=1 j+=1 elif nums[i] == 0 and nums[j]: nums[i], nums[j] = nums[j], nums[i] i+=1 j+=1 elif nums[i] and nums[j] == 0: i+=1 else: j+=1s = Solution()#nums = [2,1]#nums = [0,1,0,3,12]nums = [4,2,4,0,0,3,0,5,1,0]s.moveZeroes(nums)print nums Runtime: 76 ms Python实现-赋值法O(n)123456789101112131415161718class Solution(object): def moveZeroes(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ n = len(nums) pos = 0 i = 0 while i&lt;n: if nums[i] != 0: nums[pos] = nums[i] pos+=1 i+=1 while pos&lt;n: nums[pos]=0 pos+=1 Runtime: 75 ms LeetCode上最优的方案1234567891011class Solution(object): def moveZeroes(self, nums): if nums == []: return pos = 0 for num in nums: if num != 0: nums[pos] = num pos += 1 for i in range(len(nums) - pos): nums[-i-1]=0 Runtime: 46 ms 使用range迭代的效果更高]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L263 Ugly Number]]></title>
    <url>%2F2017-12-18-L263-Ugly-Number%2F</url>
    <content type="text"><![CDATA[题目描述1234Write a program to check whether a given number is an ugly number.Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.Note that 1 is typically treated as an ugly number. 解题思路 判断n是否能被2，3，5整除，如果不可以直接返回false 如果可以将n替换为n/[2,3,5]后，再进行判断 Go实现1123456789101112131415161718192021222324func isUgly(num int) bool &#123; if num&lt;=0&#123; return false &#125; if num == 1 &#123; return true &#125; for num &gt;1 &#123; flag:= false for _,x := range []int&#123;2,3,5&#125;&#123; if num%x==0 &#123; num = num/x flag=true &#125; &#125; if !flag &#123; return false &#125; &#125; return true&#125; Go实现212345678910111213141516func isUgly(num int) bool &#123; if num&lt;=0&#123; return false &#125; if num == 1 &#123; return true &#125; for _,x := range []int&#123;2,3,5&#125;&#123; for num%x==0 &#123; num = num/x &#125; &#125; return num == 1&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L204 Count Primes]]></title>
    <url>%2F2017-12-18-L204-Count-Primes%2F</url>
    <content type="text"><![CDATA[题目描述1Count the number of prime numbers less than a non-negative number, n. 解题思路 遍历n-1到2判断其是否为prime，如果是进行count++。此算法在n&gt;=499979以上会出现超时。 使用数学算法 https://open.163.com/movie/2012/10/0/6/M99VJKUHC_M9ENDUB06.html Go实现——逐一判断123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "fmt" "math")func isPrime(n int) bool &#123; sqrt := int(math.Sqrt(float64(n))) if n==1 &#123; return false &#125; for sqrt&gt;1 &#123; if n%sqrt==0 &#123; return false &#125; sqrt-- &#125; return true&#125;func countPrimes(n int) int &#123; count := 0 n = n-1 for n&gt;0 &#123; if isPrime(n) &#123; count++ &#125; n-- &#125; return count&#125;func main() &#123; fmt.Println(isPrime(3)) //在MacAir测试执行时间会超过2s fmt.Println(countPrimes(499979))&#125; Go实现——埃拉托斯特尼筛法12345678910111213141516171819202122232425262728293031import ( "math")func countPrimes(n int) int &#123; if n&lt;=1&#123; return 0 &#125; count := 0 m :=make([]int, n+2) for i:=2; i&lt;=int(math.Sqrt(float64(n)));i++ &#123; k:=i j:=2 for k*j&lt;n &#123; if m[k*j] ==0 &#123; m[k*j] = 1 &#125; j++ &#125; &#125; for _,v :=range m[2:n]&#123; if v==0 &#123; count++ &#125; &#125; return count&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L235 Lowest Common Ancestor of a Binary Search Tree]]></title>
    <url>%2F2017-12-18-L235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112131415Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” _______6______ / \ ___2__ ___8__ / \ / \ 0 _4 7 9 / \ 3 5For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. 解题思路DFS+Level(适合通用的二叉树) 使用DFS遍历，将各个节点对应的父节点信息保存到map中 使用递归的前序遍历，将各个节点对应的level信息保存到map （由于没有想到如何从DFS遍历中获取level信息，故从新递归计算） 将p和q移动到同一个level，然后逐步回溯其父节点 利用二叉搜索树的特性 保持p.val&lt;q.val 如果p.val&gt;root.val，说明p和q都分布在root右边，向右遍历 如果q.val&lt;root.val，说明p和q都分布在root左边，向左遍历 如果root在p和q之间，这个root就是p和q的LCA 代码实现Python实现——DFS+Level12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Definition for a binary tree node.class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ #获取各个节点对应的parent stack = [] stack.append(root) parent = &#123;root: None&#125; level = &#123;&#125; n = 0 while len(stack)&gt;0: current = stack[len(stack)-1] stack = stack[0:-1] if current.right: stack.append(current.right) parent[current.right] = current if current.left: stack.append(current.left) parent[current.left] = current self.levelorder(root, level, 0) #保证p的level大于q if level[p] &lt; level[q]: p, q = q,p #将p和q移动同一个level while level[p] != level[q]: p = parent[p] #回溯父节点 while p!=q: p = parent[p] q = parent[q] return p def initTree(self, root, nums, i, n): if i &lt; n: if nums[i] == -1: root = None return root else: root = TreeNode(nums[i]) root.left = self.initTree(root.left, nums, 2*i+1, n) root.right = self.initTree(root.right, nums, 2*i+2, n) return root #获取各个节点对应的level def levelorder(self, root, level, n): if not root: return level[root] = n self.levelorder(root.left, level, n+1) self.levelorder(root.right, level, n+1) def preorder(self, root, path): if not root: return print "%d " % root.val, path.append(root) self.preorder(root.left, path) self.preorder(root.right, path)s = Solution()nums = [5,3,6,2,4,-1,-1,1]root = s.initTree(None, nums, 0, len(nums))path = []s.preorder(root, path)printret = s.lowestCommonAncestor(root, path[3],path[1])print ret.val Python实现——利用二叉查找树有序的特性(递归版)12345678910111213141516171819class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if p.val &gt; q.val: p, q = q, p if q.val &lt; root.val: return self.lowestCommonAncestor(root.left, p, q) elif p.val &gt; root.val: return self.lowestCommonAncestor(root.right, p, q) else: return root Python实现——利用二叉查找树有序的特性(非递归版)123456789101112131415class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; while root: if root.val &gt; p.val and root.val &gt; q.val: root = root.left elif root.val &lt; p.val and root.val &lt; q.val: root = root.right else: return root]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L268 Missing Number]]></title>
    <url>%2F2017-12-15-L268-Missing-Number%2F</url>
    <content type="text"><![CDATA[题目描述12345678910Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.Example 1Input: [3,0,1]Output: 2Example 2Input: [9,6,4,2,3,5,7,0,1]Output: 8 解题思路 使用额外数组表示每一个位，判断其是否为1 计算总和，然后通过减法获取缺失的数 Go实现——使用额外空间1234567891011121314151617func missingNumber(nums []int) int &#123; arr := make([]int, len(nums)+1) ret := 0 for _,v := range nums &#123; arr[v] = 1 &#125; for i,v := range arr &#123; if v==0 &#123; ret = i break &#125; &#125; return ret&#125; ###Go实现——使用n*(n-1)/2获取和，然后计算缺失的数 123456789101112131415161718192021222324252627func missingNumber(nums []int) int &#123; maxInt:=0 s :=0 for _,v:= range nums&#123; if maxInt &lt; v&#123; maxInt=v &#125; s += v &#125; if maxInt == len(nums)&#123; return maxInt*(maxInt+1)/2-s &#125;else&#123; return len(nums) &#125;&#125;func missingNumber(nums []int) (output int) &#123; l := len(nums) output = (l * (l + 1)) / 2 for _, n := range nums &#123; output -= n &#125; return&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L258 Add Digits]]></title>
    <url>%2F2017-12-14-L258-Add-Digits%2F</url>
    <content type="text"><![CDATA[题目描述12345678Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.For example:Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.Follow up:Could you do it without any loop/recursion in O(1) runtime? 解题思路 使用递归的方式，计算各个位数和s是否小于10，如果小于10返回，否则递归求s的各位数和 数根：使用数学公式https://en.wikipedia.org/wiki/Digital_root#Congruence_formula Go递归1234567891011121314func addDigits(num int) int &#123; s:=0 for num&gt;0 &#123; s += num%10 num /= 10 &#125; if s&lt;10 &#123; return s &#125;else&#123; return addDigits(s) &#125;&#125; Go实现O(1)算法123func addDigits(num int) int &#123; return 1 + (num - 1) % 9&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L257 Binary Tree Paths]]></title>
    <url>%2F2017-12-14-L257-Binary-Tree-Paths%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112Given a binary tree, return all root-to-leaf paths.For example, given the following binary tree: 1 / \2 3 \ 5All root-to-leaf paths are:[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;] 解题思路 递归深度遍历 使用循环深度遍历，通过map记录各个节点的父节点，当子节点为叶子节点，根据当前叶子节点和map回溯到root节点 Go递归遍历123456789101112131415161718192021222324252627282930func DFS(root *TreeNode, path []int, ret *[]string) &#123; if root == nil &#123; return &#125; path = append(path, root.Val) if root.Left == nil &amp;&amp; root.Right == nil &#123; s := "" n := len(path) for i:= 0; i&lt;n; i++&#123; if i&lt;n-1 &#123; s += strconv.Itoa(path[i]) + "-&gt;" &#125;else&#123; s += strconv.Itoa(path[i]) &#125; &#125; *ret = append(*ret, s) &#125; DFS(root.Left, path, ret) DFS(root.Right, path, ret)&#125;func binaryTreePaths(root *TreeNode) []string &#123; ret := []string&#123;&#125; path := []int&#123;&#125; DFS(root, path, &amp;ret) return ret&#125; Go循环实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556func getPath(current*TreeNode, parent map[*TreeNode]*TreeNode)string &#123; path := []int&#123;&#125; p := current for p!=nil &#123; path = append(path, p.Val) p = parent[p] &#125; n := len(path)-1 ret := "" for n&gt;=0 &#123; if n&gt;0 &#123; ret += strconv.Itoa(path[n]) + "-&gt;" &#125;else&#123; ret += strconv.Itoa(path[n]) &#125; n-- &#125; return ret&#125;func binaryTreePaths(root *TreeNode) []string &#123; ret := []string&#123;&#125; if root == nil &#123; return ret &#125; var stack []*TreeNode parent := map[*TreeNode]*TreeNode&#123;&#125; stack = append(stack, root) parent[root] = nil for len(stack)&gt;0 &#123; current := stack[len(stack)-1] stack = stack[0:len(stack)-1] if current.Left==nil &amp;&amp; current.Right==nil &#123; path := getPath(current, parent) ret = append(ret,path) &#125; if current.Right != nil &#123; stack = append(stack, current.Right) parent[current.Right] = current &#125; if current.Left != nil &#123; stack = append(stack, current.Left) parent[current.Left] = current &#125; &#125; return ret&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L242 Valid Anagram]]></title>
    <url>%2F2017-12-14-L242-Valid%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011Given two strings s and t, write a function to determine if t is an anagram of s.For example,s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.s = &quot;rat&quot;, t = &quot;car&quot;, return false.Note:You may assume the string contains only lowercase alphabets.Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? 解题思路 由于题目说明都是小写字母，使用两个26维数组代表a-z，初始化都是0 将字符串转换为对应的26维数组，将字母出现次进行累加统计 比较两个数组对应的数是否相同，不同则返回false，反之全部相同返回true Go实现12345678910111213141516171819202122232425func isAnagram(s string, t string) bool &#123; if len(s) != len(t) &#123; return false &#125; if len(s) == 0 &amp;&amp; len(s) == 0 &#123; return true &#125; s1 := make([]int, 26) t1 := make([]int, 26) for i:=0;i&lt;len(s);i++ &#123; s1[s[i]-'a'] += 1 t1[t[i]-'a'] += 1 &#125; for i:=0;i&lt;len(s1);i++ &#123; if s1[i] != t1[i] &#123; return false &#125; &#125; return true&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L234 Palindrome Linked List]]></title>
    <url>%2F2017-12-12-L234-Palindrome-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述1234Given a singly linked list, determine if it is a palindrome.Follow up:Could you do it in O(n) time and O(1) space? 解题思路 借助O(n)空间的话，先Linked List的元素转换为数组，然后通过low和high指针判断回文 将Linked List链表进行拆分，对后半部分的链表进行翻转，然后判断其是否相同 Go实现123456789101112131415161718192021222324252627282930313233343536373839404142434445func reverse(head *ListNode) *ListNode &#123; if head.Next == nil &#123; return head &#125; newHead := reverse(head.Next) head.Next.Next = head head.Next = nil return newHead&#125;func isPalindrome(head *ListNode) bool &#123; if head == nil&#123; return true &#125; tmp:=head n := 0 for tmp != nil &#123; n++ tmp = tmp.Next &#125; newHead := head if n%2==0 &#123; for i:=0;i&lt;=n/2-1 ;i++ &#123; newHead = newHead.Next &#125; &#125;else&#123; for i:=0;i&lt;n/2 ;i++ &#123; newHead = newHead.Next &#125; &#125; newHead = reverse(newHead) for newHead != nil &#123; if head.Val != newHead.Val&#123; return false &#125; head = head.Next newHead = newHead.Next &#125; return true&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L231 Power of Two]]></title>
    <url>%2F2017-12-12-L231-Power-of-Two%2F</url>
    <content type="text"><![CDATA[题目描述1Given an integer, write a function to determine if it is a power of two. 解题思路 n=n/2，算n%2获取的商是否为1，1的话返回true，其他返回false 判断其是否是2的幂，例如8对应的二进制表示为：1000，7对应的二进制表示是0111，8&amp;7==0 所以8是2的幂 Go实现1123456789101112131415func isPowerOfTwo(n int) bool &#123; if n&lt;=0 &#123; return false &#125; for n%2 == 0 &#123; n = n/2 &#125; if n == 1&#123; return true &#125;else&#123; return false &#125;&#125; Go实现212345678910func isPowerOfTwo(n int) bool &#123; if n&lt;=0 &#123; return false &#125; if n==1 &#123; return true &#125; return n&amp;(n-1) == 0&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L225 Implement Stack using Queues]]></title>
    <url>%2F2017-12-11-L225-Implement-Stack-using-Queues%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011Implement the following operations of a stack using queues.push(x) -- Push element x onto stack.pop() -- Removes the element on top of the stack.top() -- Get the top element.empty() -- Return whether the stack is empty.Notes:You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).` 解题思路 使用Go的list结构 使用Python实现 ###Go实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport ( "container/list" "fmt")type MyStack struct &#123; stack *list.List&#125;/** Initialize your data structure here. */func Constructor() MyStack &#123; mystack := MyStack&#123;&#125; mystack.stack = list.New() return mystack&#125;/** Push element x onto stack. */func (this *MyStack) Push(x int) &#123; this.stack.PushBack(x)&#125;/** Removes the element on top of the stack and returns that element. */func (this *MyStack) Pop() int &#123; front := this.stack.Front() this.stack.Remove(front) return front.Value.(int)&#125;/** Get the top element. */func (this *MyStack) Top() int &#123; if !this.Empty() &#123; front := this.stack.Back() return front.Value.(int) &#125;else&#123; panic("Empty") &#125;&#125;/** Returns whether the stack is empty. */func (this *MyStack) Empty() bool &#123; return this.stack.Len() == 0&#125;/** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */func main() &#123; obj := Constructor() obj.Push(1) obj.Push(1) obj.Push(2) fmt.Println(obj.Top())&#125; Python实现1234567891011121314151617181920212223242526272829303132333435363738394041class MyStack(object): def __init__(self): """ Initialize your data structure here. """ self.stack = [] def push(self, x): """ Push element x onto stack. :type x: int :rtype: void """ self.stack.append(x) def pop(self): """ Removes the element on top of the stack and returns that element. :rtype: int """ if not self.empty(): val = self.stack[-1] self.stack = self.stack[0:-1] return val def top(self): """ Get the top element. :rtype: int """ if not self.empty(): val = self.stack[-1] return val def empty(self): """ Returns whether the stack is empty. :rtype: bool """ return len(self.stack) == 0]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L226 Invert Binary Tree]]></title>
    <url>%2F2017-12-11-L226-Invert-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112131415161718Invert a binary tree. 4 / \ 2 7 / \ / \1 3 6 9to 4 / \ 7 2 / \ / \9 6 3 1Trivia:This problem was inspired by this original tweet by Max Howell:Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off. 解题思路 递归方式 非递归方式 Go递归实现12345678910111213func invertTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return root &#125; //将左右节点交换 root.Left, root.Right = root.Right, root.Left //递归访问root.Left root.Left = invertTree(root.Left) //递归访问root.right root.Right = invertTree(root.Right) return root&#125; Go非递归实现12345678910111213141516171819202122func invertTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return root &#125; var stack []*TreeNode stack = append(stack, root) for len(stack)&gt;0 &#123; current := stack[len(stack)-1] stack = stack[0:len(stack)-1] if current != nil&#123; //关键就是交换左右 current.Left, current.Right = current.Right, current.Left //这里先压入左或者先压入右一样 stack = append(stack, current.Right) stack = append(stack, current.Left) &#125; &#125; return root&#125; 思想很简单，从根节点遍历树，将左右节点交换后，然后将其压入栈]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L205 Isomorphic Strings]]></title>
    <url>%2F2017-12-11-L205-Isomorphic-Strings%2F</url>
    <content type="text"><![CDATA[题目描述12345678910111213141516Given two strings s and t, determine if they are isomorphic.Two strings are isomorphic if the characters in s can be replaced to get t.All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.For example,Given &quot;egg&quot;, &quot;add&quot;, return true.Given &quot;foo&quot;, &quot;bar&quot;, return false.Given &quot;paper&quot;, &quot;title&quot;, return true.Note:You may assume both s and t have the same length. 解题思路 使用map进行映射的判断，相同的字符是否映射相同 使用数组解决 Go实现——使用map12345678910111213141516171819202122232425262728293031323334func containsVal(m map[int]int, val int) bool&#123; for _,v := range m&#123; if val == v&#123; return true &#125; &#125; return false&#125;func isIsomorphic(s string, t string) bool &#123; if len(s) != len(t) &#123; return false &#125; m := map[int]int&#123;&#125; for i:=0;i&lt;len(s);i++ &#123; c1 := int(s[i]) c2 := int(t[i]) if _,ok:=m[c1]; ok&#123; if m[c1] != c2 &#123; return false &#125; &#125;else&#123; if containsVal(m, c2) &#123; return false &#125; m[c1] = c2 &#125; &#125; return true&#125; Go实现12345678910111213141516171819func isIsomorphic(s string, t string) bool &#123; if len(s) != len(t) &#123; return false &#125; m1 := make([]int, 256) m2 := make([]int, 256) for i:=0;i&lt;len(s); i++ &#123; if m1[s[i]] != m2[t[i]] &#123; return false &#125; m1[s[i]] = i+1 m2[t[i]] = i+1 &#125; return true&#125; 参考资料：http://www.cnblogs.com/grandyang/p/4465779.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L206 Reverse Linked List]]></title>
    <url>%2F2017-12-11-L206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述123Reverse a singly linked list.Hint:A linked list can be reversed either iteratively or recursively. Could you implement both? 解题思路 使用循环的方式，使用newHead保存新的链表，将newHead的位置插入current节点 使用递归的方式, 使用prev和current指针，初始prev为nil 使用递归方式，先递归到最后一个节点，调整head节点的next-&gt;next为head，将当前head的next设置为NULL，返回上一层 Go——循环方式12345678910111213141516func reverseList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; var newHead *ListNode current := head for current != nil&#123; next := current.Next current.Next = newHead newHead = current current = next &#125; return newHead&#125; Go——递归实现123456789101112131415161718func reverse(current *ListNode, prev *ListNode) *ListNode &#123; if current.Next == nil &#123; current.Next = prev return current &#125; node := current.Next current.Next = prev return reverse(node, current)&#125;func reverseList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; return reverse(head, nil)&#125; Go——递归实现2123456789func reverseList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L203 Remove Linked List Elements]]></title>
    <url>%2F2017-12-10-L203-Remove-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[题目描述12345Remove all elements from a linked list of integers that have value val.ExampleGiven: 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6Return: 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 解题思路 使用prev指针记录当前节点的前一个节点，current表示当前节点 需要判断当前节点是否为head节点 Go实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport "fmt"type ListNode struct &#123; Val int Next *ListNode&#125;func insertNode(head *ListNode,val int) *ListNode &#123; if head == nil &#123; head = new(ListNode) head.Val = val &#125;else&#123; tmp := head for tmp.Next!=nil &#123; tmp = tmp.Next &#125; node := new(ListNode) node.Val = val tmp.Next = node &#125; return head&#125;func removeElements(head *ListNode, val int) *ListNode &#123; if head == nil&#123; return nil &#125; current:=head prev := head for current != nil &#123; if current.Val == val &#123; if current == head&#123; prev = current.Next head = prev &#125;else&#123; prev.Next = current.Next &#125; &#125;else&#123; prev = current &#125; current = current.Next &#125; return head&#125;func printList(head *ListNode) &#123; for head != nil &#123; if head.Next!=nil &#123; fmt.Printf("%d -&gt; ", head.Val) &#125;else&#123; fmt.Println(head.Val) &#125; head = head.Next &#125;&#125;func main()&#123; //nums := []int&#123;1,2,6,3,4,5,6&#125;, val=6 //nums := []int&#123;1,2&#125;, val=1 //nums := []int&#123;1&#125;, val=1 //nums := []int&#123;1,1&#125;, val=1 //nums :=[]int&#123;1,2&#125;, val=2 nums := []int&#123;1,2,2,1&#125; var head *ListNode for _,v := range nums &#123; head = insertNode(head, v) &#125; printList(head) head=removeElements(head, 2) printList(head)&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L191 Number of 1 Bits]]></title>
    <url>%2F2017-12-08-L191-Number-of-1-Bits%2F</url>
    <content type="text"><![CDATA[题目描述123456Write a function that takes an unsigned integer and returns the number of ’1&apos; bits it has (also known as the Hamming weight).For example, the 32-bit integer ’11&apos; has binary representation 00000000000000000000000000001011, so the function should return 3. 解题思路 计算二进制，判断当前是否需要计数 使用n&amp;n-1 Python实现123456789101112class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ count = 0 while n&gt;0: if n%2: count +=1 n /= 2 return count Python实现12345678910111213class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ count = 0 while n&gt;0: n = n &amp;(n-1) count+=1 return count]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L190 Reverse Bits]]></title>
    <url>%2F2017-12-08-L190-Reverse-Bits%2F</url>
    <content type="text"><![CDATA[题目描述1234567Reverse bits of a given 32 bits unsigned integer.For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).Follow up:If this function is called many times, how would you optimize it? 解题思路解题思路1——使用list记录然后reverse重新计算10进制数值 先计算出n对应的二进制数保存到list中，对于不满足32位的数设置0 将list翻转后，再重新计算10进制数值 不使用List 先数值计算 然后判断位数是否小于32，进行左移位 使用bin和zfill函数 使用bin获取int对应的二进制 使用zfill补齐零 使用int计算二进制对应的十进制 Python实现——使用List1234567891011121314151617181920class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): ret = [] while n &gt; 0: ret.append(n%2) n = n/2 n = len(ret) while n &lt; 32: ret.append(0) n += 1 reversed(ret) v = 0 for bit in ret: v = v*2 + bit return vs = Solution()print s.reverseBits(43261596) Runtime: 38 ms Python实现——不使用List12345678910111213141516171819202122class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): idx = 0 s = 0 flag = False while n &gt; 0: if n % 2 == 0: idx+=1 else: flag = True idx +=1 if flag: s = s*2 + n%2 n /= 2 if idx&lt;32: s = s&lt;&lt;32-idx return ss = Solution()print s.reverseBits(43261596) Runtime: 55 ms 使用标准函数库123456class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): ret= bin(n)[2:].zfill(32)[::-1] return int(ret, 2) Runtime: 36 ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L189 Rotate Array]]></title>
    <url>%2F2017-12-07-L189-Rotate-Array%2F</url>
    <content type="text"><![CDATA[题目描述12345678910Rotate an array of n elements to the right by k steps.For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].Note:Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.测试案例：[1,2] 0 [1,2][1,2] 1 [2,1] 解题思路O(n)时间复杂度+ O(n)空间复杂度O(n*k)时间复杂度 + O(1)空间复杂度 将最后一个元素保存，然后从N-1开始将前面一个元素往后移动一个位置，然后将最后一个元素放在首位置 重复k次操作 冒泡排序的思想 O(n)时间复杂度 + O(1)空间复杂度 将nums[0:n-k]翻转，将nums[n-k:]翻转 再将nums翻转 问题的关键是n-k翻转，还是k翻转？ O(n)时间复杂度 + O(1)空间复杂度 将每个元素向后移动k个位置 Go实现-O(n)时间复杂度+ O(n) 空间复杂度1234567891011121314151617181920212223func rotate(nums []int, k int) &#123; n := len(nums) arr :=[]int&#123;&#125; for _,v := range nums&#123; arr = append(arr, v) &#125; for i:=0;i&lt;n;i++ &#123; nums[(i+k)%n] = arr[i] &#125;&#125;func rotate(nums []int, k int) &#123; n := len(nums) arr := make([]int, n) copy(arr, nums) for i:=0;i&lt;n ; i++ &#123; nums[(i+k)%n] = arr[i] &#125;&#125; Go实现-O(n*k)12345678910111213func rotate(nums []int, k int) &#123; n := len(nums) for i:=0;i&lt;k ;i++ &#123; t := nums[n-1] j := n-1 for j&gt;=1 &#123; nums[j] = nums[j-1] j-- &#125; nums[j] = t &#125;&#125; Runtime: 462 ms Go实现-翻转123456789101112131415161718192021222324func reverse(nums []int) &#123; n := len(nums) low := 0 high := n-1 for low&lt;high &#123; nums[low], nums[high] = nums[high], nums[low] low++ high-- &#125;&#125;func rotate(nums []int, k int) &#123; n:= len(nums) k = k%n if n==0 || k%n==0 &#123; return &#125; if k&lt;n &#123; reverse(nums[0:n-k]) reverse(nums[n-k:]) reverse(nums) &#125;&#125; Go实现-每个元素向后移动k个位置123456789101112131415161718192021func rotate(nums []int, k int) &#123; n := len(nums) if k == 0 || n == 0 &#123; return &#125; k = k % n idx := 0 distance := 0 cur := nums[0] for i:=0; i&lt;n; i++ &#123; idx = (idx+k) % n nums[idx], cur = cur, nums[idx] distance = (distance+k) % n if distance == 0 &#123; idx = (idx+1) % n cur = nums[idx] &#125; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L172 Factorial Trailing Zeroes]]></title>
    <url>%2F2017-12-07-L172-Factorial-Trailing-Zeroes%2F</url>
    <content type="text"><![CDATA[题目描述123Given an integer n, return the number of trailing zeroes in n!.Note: Your solution should be in logarithmic time complexity. 解题思路 先不考虑时间复杂度，最简单的方法是计算出n的阶乘值，然后再计算出尾部0的个数 使用非O(n)的算法 N N的阶乘值 结果 1 1 0 5 5*2 1 9 5*2 1 10 10,5*2 2 11 10,5*2 2 15 10,152, 54 3 19 10, 152, 54 3 20 20,10,152, 54 4 30 30,20,10,25=55(52,54),156,5*8 7 Go实现-计算阶乘12345678910111213141516171819202122232425package mainimport "fmt"func factorial(n int) int &#123; if n==0 || n==1 &#123; return 1 &#125;else&#123; return n*factorial(n-1) &#125;&#125;func trailingZeroes(n int) int &#123; f := factorial(n) ret := 0 for f%10==0 &#123; f = f/10 ret++ &#125; return ret&#125;func main() &#123; fmt.Println(trailingZeroes(30))&#125; 使用阶乘的方法计算，在30!的时候会出现数越界，导致其结果输出为0 Go实现1234567891011121314151617func trailingZeroes(n int) int &#123; ret := 0 for n&gt;0 &#123; ret += n/5 n = n/5 &#125; return ret&#125;func main() &#123; nums := []int&#123;1, 5, 9, 10, 11, 15, 20,25,30&#125; for _,v := range nums &#123; fmt.Println(trailingZeroes(v)) &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel Sheet]]></title>
    <url>%2F2017-12-07-Excel-Sheet%2F</url>
    <content type="text"><![CDATA[题目描述L168. Excel Sheet Column Title1234567891011Given a positive integer, return its corresponding column title as appear in an Excel sheet.For example: 1 -&gt; A 2 -&gt; B 3 -&gt; C ... 26 -&gt; Z 27 -&gt; AA 28 -&gt; AB L171. Excel Sheet Column Number12345678910111213Related to question [Excel Sheet Column Title](https://leetcode.com/problems/excel-sheet-column-title/description/)Given a column title as appear in an Excel sheet, return its corresponding column number.For example: A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 解题思路 26进制计算 注意从1开始 Go实现123456789101112131415161718192021222324252627282930313233343536373839package mainimport "fmt"func convertToTitle(n int) string &#123; ret:="" for n&gt;0 &#123; ret = string('A'+(n-1)%26) + ret n = (n-1)/26 &#125; return ret&#125;func titleToNumber(s string) int &#123; ret := 0 n := len(s) for i:=0;i&lt;n;i++ &#123; ret = ret*26 + int(s[i] - 'A') + 1 &#125; return ret&#125;func main() &#123; fmt.Println(convertToTitle(26)) fmt.Println(convertToTitle(27)) fmt.Println(convertToTitle(28)) fmt.Println(convertToTitle(52)) fmt.Println(convertToTitle(53)) fmt.Println(titleToNumber("A")) fmt.Println(titleToNumber("AA")) fmt.Println(titleToNumber("AB")) fmt.Println(titleToNumber("AZ")) fmt.Println(titleToNumber("BA"))&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L169 Majority Element]]></title>
    <url>%2F2017-12-06-L169-Majority%2F</url>
    <content type="text"><![CDATA[题目描述12Given an array of size n, find the majority element. The majority element is the element that appears more than [n/2] times.You may assume that the array is non-empty and the majority element always exist in the array. 解题思路 将数组排序，计算连续出现数的个数是否大于n/2，如果是则返回该元素 使用map做计数，需要额外的空间 如何通过不排序进行解决呢？基于一个前提：这个元素的个数超过n/2向下取整 Go实现1-使用排序1234567891011121314151617181920212223242526272829303132333435package mainimport ( "fmt" "sort")func majorityElement(nums []int) int &#123; sort.Ints(nums) n := len(nums) ret := nums[0] for i:=0;i&lt;n;i++ &#123; count :=1 for i+1&lt;n &amp;&amp; nums[i+1] == nums[i] &#123; i++ count++ &#125; if count&gt;n/2 &#123; ret = nums[i] break &#125; &#125; return ret&#125;func main()&#123; //nums := []int&#123;1,1,1,1,2,3,3&#125; nums := []int&#123;1&#125; //nums :=[]int&#123;2,2&#125; fmt.Println(majorityElement(nums))&#125; Go实现2-无排序123456789101112131415161718 majorityElement(nums []int) int &#123; var count = 0 var num int for _, v := range nums &#123; if count==0 &#123; num = v count = 1 &#125;else&#123; if num == v &#123; count++ &#125;else&#123; count-- &#125; &#125; &#125; return num&#125; 这个算法成立的前提是这个元素超过一半以上，例如下面的案例[1 2 1 2 3 2 3 2 2 3]此算法输出的结果为3，而实际上更多的元素是2]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L167 Two Sum II]]></title>
    <url>%2F2017-12-06-L167-Two-Sum-II%2F</url>
    <content type="text"><![CDATA[题目描述12345678Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution and you may not use the same element twice.Input: numbers=&#123;2, 7, 11, 15&#125;, target=9Output: index1=1, index2=2 解题思路 使用两个索引，判断其和和target关系 比target大，low++ 比target小，high– Go实现1234567891011121314151617181920212223242526272829303132package mainimport "fmt"func twoSum(numbers []int, target int) []int &#123; low := 0 high := len(numbers)-1 for low&lt;high &#123; sum := numbers[low] + numbers[high] if sum &lt; target &#123; low++ &#125;else if sum &gt; target &#123; high-- &#125;else&#123; break &#125; &#125; ret :=[]int&#123;&#125; ret = append(ret, low+1) ret = append(ret, high+1) return ret&#125;func main() &#123; nums := []int&#123;2, 7, 11, 15&#125; target := 9 fmt.Println(twoSum(nums, target))&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L160 Intersection of Two Linked Lists]]></title>
    <url>%2F2017-12-06-L160-Intersection-of-Two-Linked-Lists%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112131415161718192021Write a program to find the node at which the intersection of two singly linked lists begins.For example, the following two linked lists:A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3begin to intersect at node c1.Notes:If the two linked lists have no intersection at all, return null.The linked lists must retain their original structure after the function returns.You may assume there are no cycles anywhere in the entire linked structure.Your code should preferably run in O(n) time and use only O(1) memory.Credits:Special thanks to @stellari for adding this problem and creating all test cases. 解题思路计算长度，起点对齐 先遍历两个链表，获取各自的长度LenA和LenB 遍历到最后一个节点，如果两个节点相同，说明存在交叉节点，否则返回None 对于较长的链表先行，移动到两者相同的长度 两个链表同时移动，遇到相同的节点时候就是交叉点，直接返回 交换head，起点对齐 主要补充图说明 两者的时间复杂度相同，只是第二种代码简洁些。 Python实现112345678910111213141516171819202122232425262728293031323334353637class Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None lenA = 0 lenB = 0 tmpA = headA tmpB = headB while tmpA.next: lenA += 1 tmpA = tmpA.next while tmpB.next: lenB += 1 tmpB = tmpB.next if tmpA is tmpB: if lenA&gt;lenB: lenA, lenB = lenB, lenA headA, headB = headB, headA while lenB&gt;lenA: lenB -= 1 headB = headB.next while headA is not headB: headA = headA.next headB = headB.next return headA else: return None Run Time 408ms Python实现212345678910111213141516class Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None p_a = headA p_b = headB while p_a is not p_b: p_a = headB if p_a is None else p_a.next p_b = headA if p_b is None else p_b.next return p_a Run Time 408ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min Stack]]></title>
    <url>%2F2017-12-06-Min-Stack%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112131415Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.push(x) -- Push element x onto stack.pop() -- Removes the element on top of the stack.top() -- Get the top element.getMin() -- Retrieve the minimum element in the stack.Example:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 解题思路 使用数组保存所有元素 一个len记录stack中元素数目 Go实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport "fmt"type MinStack struct &#123; stack []int len int&#125;/** initialize your data structure here. */func Constructor() MinStack &#123; s := new(MinStack) return *s&#125;func (this *MinStack) Push(x int) &#123; this.stack = append(this.stack, x) this.len++&#125;func (this *MinStack) Pop() &#123; this.len-- this.stack = this.stack[0:this.len]&#125;func (this *MinStack) Top() int &#123; if this.len&gt;0&#123; return this.stack[this.len-1] &#125;else&#123; panic("stack empty") &#125;&#125;func (this *MinStack) GetMin() int &#123; minVal := 2147483647 n := this.len-1 for n &gt;=0 &#123; if this.stack[n] &lt; minVal&#123; minVal = this.stack[n] &#125; n-- &#125; return minVal&#125;func main() &#123; s := new(MinStack) s.Push(-2) s.Push(0) s.Push(-3) fmt.Println(s.GetMin()) s.Pop() fmt.Println(s.Top()) fmt.Println(s.GetMin())&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linked List Cycle]]></title>
    <url>%2F2017-12-04-Linked-List-Cycle%2F</url>
    <content type="text"><![CDATA[题目描述L1411234Given a linked list, determine if it has a cycle in it.Follow up:Can you solve it without using extra space? L142123456Given a linked list, return the node where the cycle begins. If there is no cycle, return null.Note: Do not modify the linked list.Follow up:Can you solve it without using extra space? 解题思路解题思路步骤 使用两个指针slow和fast slow每次移动一次，fast每次移动二次，直到两者相遇（可以从示例中看到当前相遇的节点不一定是cycle开始的节点） 将slow移动到head，fast和slow每次移动一次，直到两者相遇 示例说明示例1 示例2 如何保证slow和fast一定会相遇呢？ 公式说明 L1为H到E的距离 L2为M到E的距离 C为环的周长 n为快慢指针首次相遇，快指针在环中绕行的次数 慢指针的路径长度为L1+L2 快指针的路径长度为L1+L2+n*C 由于快指针是慢指针进行距离的2倍，因此： $$(L1 + L2)*2 = L1 + L2 + n * C =&gt; L1 + L2 = n * C =&gt; L1 = (n - 1) * C + (C - L2)$$ 参考文档：http://bookshadow.com/weblog/2015/07/10/leetcode-linked-list-cycle-ii/ L141 Python 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return False prev = head next = prev while prev and next: prev = prev.next if next.next: next = next.next.next else: break if prev == next: return True return Falsedef insertNode(head, v): if not head: head = ListNode(v) else: current=head while current.next: current = current.next node = ListNode(v) current.next = node return heads = Solution()nums = [3,2,0,-4]head = Nonefor v in nums: head = insertNode(head, v)#tmp = head## while tmp.next:# tmp = tmp.next# tmp.next = headprint s.hasCycle(head) L142 Python 实现123456789101112131415161718192021222324252627class Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return None slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow is fast: break if not fast or not fast.next: return None slow = head while fast is not slow: fast = fast.next slow = slow.next return slow]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo相关使用]]></title>
    <url>%2F2017-12-01-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo使用数学公式在hexo安装目录下执行 1npm install hexo-math --save 然后编辑站点根目录下的_config.yml，添加 123456math: engine: &apos;mathjax&apos; # or &apos;katex&apos; mathjax: src: custom_mathjax_source config: # MathJax config 之后进入theme的目录，编辑主题的_config.yml，找到mathjax字段。NexT 5.0.1中默认mathjax是禁用，需要改成 12mathjax: enable: true 最后hexo g，就可以部署或者运行server查看效果了。 几个测试例子使用$的一行代码： 123&#123;% math %&#125;Simple inline $a = b + c$.&#123;% endmath %&#125; Simple inline $a = b + c$. 参考资料：http://zjubank.com/2016/08/16/hexo-use-mathjax/]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L136_Single_Number]]></title>
    <url>%2F2017-12-01-L136-Single-Number%2F</url>
    <content type="text"><![CDATA[题目描述1234Given an array of integers, every element appears twice except for one. Find that single one.Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解题思路 先将数组排序，然后前后比较，如果相同则都跳过，如果不同，则返回前者 使用Map 使用位运算 Go实现-排序比较12345678910111213141516171819202122232425262728293031package mainimport ( "fmt" "sort")func singleNumber(nums []int) int &#123; sort.Ints(nums) n := len(nums) ret:=0 for i:=0; i&lt;n;i++ &#123; if i&lt;n-1 &amp;&amp; nums[i] == nums[i+1] &#123; i++ &#125;else if i==n-1 &#123; ret = nums[i] &#125;else&#123; ret = nums[i] break &#125; &#125; return ret&#125;func main() &#123; nums := []int&#123;1,1,2,2,3&#125; fmt.Println(singleNumber(nums))&#125; 时间复杂度O(nlogn)+O(n) Go实现-Map12345678910111213141516171819func singleNumber(nums []int) int &#123; m := map[int]int&#123;&#125; for _,v := range nums&#123; if _,ok := m[v];!ok &#123; m[v] = 1 &#125;else&#123; m[v] += 1 &#125; &#125; for k := range m&#123; if m[k] == 1 &#123; return k &#125; &#125; return 0&#125; 时间复杂度O(n)，空间复杂度O(n) 使用位运算 某个数和0进行异或运算，其返回值为这个数 $a ⊕ $0 = a 相同的两个数异或运算，其返回值为0 $a ⊕ $a = 0 $a ⊕ $b ⊕ $a = ($a ⊕ $a) ⊕ $b = 0 ⊕ $b = $b 12345678func singleNumber(nums []int) int &#123; ret := 0 for _, v := range nums&#123; ret = ret ^ v &#125; return ret&#125; 时间复杂度O(n),空间复杂度O(1)]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L125 Valid Palindrome]]></title>
    <url>%2F2017-12-01-L125-Valid-Palindrome%2F</url>
    <content type="text"><![CDATA[题目描述12345678910Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.For example,&quot;A man, a plan, a canal: Panama&quot; is a palindrome.&quot;race a car&quot; is not a palindrome.Note:Have you consider that the string might be empty? This is a good question to ask during an interview.For the purpose of this problem, we define empty string as valid palindrome. 解题思路 使用low和high两个指针进行判断 如果遇到非alphanumeric字符，进行跳过处理 Go实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( "fmt")func isAlphanumeric(char uint8) bool &#123; if (char &gt;= 'A' &amp;&amp; char &lt;='Z') || (char&gt;='a' &amp;&amp; char&lt;='z')|| (char &gt;='0' &amp;&amp; char&lt;='9') || char=='_'&#123; return true &#125;else&#123; return false &#125;&#125;func lower(char uint8) uint8 &#123; if char &gt;='a' &amp;&amp; char&lt;='z' &#123; char = char-'a'+'A' &#125; return char&#125;func isPalindrome(s string) bool &#123; if len(s) == 0 || len(s) == 1&#123; return true &#125; low:=0 high := len(s)-1 for low&lt;high &#123; if !isAlphanumeric(s[low]) &#123; low++ &#125;else if !isAlphanumeric(s[high]) &#123; high-- &#125;else &#123; if lower(s[low]) == lower(s[high]) &#123; low++ high-- &#125;else&#123; return false &#125; &#125; &#125; return true&#125;func main() &#123; //fmt.Println(isPalindrome("A man, a plan, a canal: Panama")) //fmt.Println(isPalindrome("race a car")) fmt.Println(isPalindrome("0P")) fmt.Println(isPalindrome("a.")) //fmt.Println(len("."))&#125; Python实现 使用基本比较 123456789101112131415161718192021222324class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if not s: return True low = 0 high = len(s) - 1 while low &lt; high: if not str.isalnum(str(s[low])): low += 1 elif not str.isalnum(str(s[high])): high -= 1 else: if str.lower(str(s[low])) == str.lower(str(s[high])): low += 1 high -= 1 else: return False return True 遇到的错误信息: 123Runtime Error Message:Line 14: TypeError: descriptor &apos;isalnum&apos; requires a &apos;str&apos; object but received a &apos;unicode&apos;Last executed input: &quot;a.&quot; 使用库函数 123456789class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ newString = re.sub("[^0-9a-zA-Z]+", "", s) return newString.lower() == newString.lower()[::-1]]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock]]></title>
    <url>%2F2017-11-30-Best-Time-to-Buy-and-Sell-Stock%2F</url>
    <content type="text"><![CDATA[题目描述L121123456789101112131415Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)Example 2:Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 找出数组中的和其前面的数据之差为正整数的最大值 L122解题思路 O(n*2)的算法：2次循环遍历获取差值，与max进行比较 O(n)的算法：记录最小值，将当期元素与最小值进行差值，然后与maxVal进行比较 Go实现O(n*2)时间复杂度1234567891011121314func maxProfit(prices []int) int &#123; maxVal :=0 n := len(prices) for i:=1;i&lt;n;i++ &#123; for j:=0;j&lt;i; j++ &#123; delta := prices[i]- prices[j] if delta&gt;0 &amp;&amp; delta&gt;maxVal &#123; maxVal = delta &#125; &#125; &#125; return maxVal&#125; O(n)时间复杂度12345678910111213141516171819202122func maxProfit(prices []int) int &#123; maxVal :=0 n:=len(prices) if n==0 &#123; return maxVal &#125; minElement := prices[0] for i:=1;i&lt;len(prices);i++&#123; if minElement&gt;prices[i] &#123; minElement = prices[i] &#125; delta:=prices[i]-minElement if delta &gt; 0 &amp;&amp; delta&gt;maxVal&#123; maxVal = delta &#125; &#125; return maxVal&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L98 Validate Binary Search Tree]]></title>
    <url>%2F2017-11-30-L98-Validate-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011121314151617Given a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows:The left subtree of a node contains only nodes with keys less than the node&apos;s key.The right subtree of a node contains only nodes with keys greater than the node&apos;s key.Both the left and right subtrees must also be binary search trees.Example 1: 2 / \ 1 3Binary tree [2,1,3], return true.Example 2: 1 / \ 2 3Binary tree [1,2,3], return false. 判断一个二叉树是否为二叉搜索树 解题思路 使用中序遍历这个二叉树，然后生成一个数组 判断这个数据是否有序 Go递归实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport "fmt"/** * Definition for a binary tree node. */type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func initTree(root *TreeNode, nums []int, i int, n int) *TreeNode &#123; if i&lt;n &#123; if nums[i] == -1 &#123; root = nil &#125;else &#123; root = new(TreeNode) root.Val = nums[i] root.Left = initTree(root.Left, nums, 2*i+1, n) root.Right = initTree(root.Right, nums, 2*i+2, n) &#125; &#125; return root&#125;func inorder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; inorder(root.Left, path) *path = append(*path, root.Val) inorder(root.Right, path)&#125;func isValidBST(root *TreeNode) bool &#123; path := []int&#123;&#125; inorder(root, &amp;path) n := len(path) //for i:=0;i&lt;n-1;i++ &#123; // for j:=i+1;j&lt;n ;j++ &#123; // if path[i]&gt;=path[j] &#123; // return false // &#125; // &#125; //&#125; //判断数组是否有序O(n)算法 for i:=0;i&lt;n-1;i++ &#123; if path[i]&gt;=path[i+1] &#123; return false &#125; &#125; return true&#125;func main() &#123; nums :=[]int&#123;10,5,15,-1,-1,6,20&#125; root := initTree(nil, nums, 0, len(nums)) fmt.Println(isValidBST(root))&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unique Binary Search Trees]]></title>
    <url>%2F2017-11-30-Unique-Binary-Search-Trees%2F</url>
    <content type="text"><![CDATA[题目描述L951234567891011Given n, how many structurally unique BST&apos;s (binary search trees) that store values 1...n?For example,Given n = 3, there are a total of 5 unique BST&apos;s. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 L961234567891011Given an integer n, generate all structurally unique BST&apos;s (binary search trees) that store values 1...n.For example,Given n = 3, your program should return all 5 unique BST&apos;s shown below. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 L95只需要给出这些二叉搜索树对应的总数即可，而L96需要给出这些二叉搜索树 解题思路 通过排列算法给出分组，然后构建BST，通过前序遍历这些树，然后判断树是否唯一 Go解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182type TreeNode struct&#123; Val int Left *TreeNode Right *TreeNode&#125;func Perm(nums []int, k int, n int, path *[]int, ret *[]*TreeNode)&#123; if k==n &#123; s:=0 root := createBST(nil, nums) preorder(root,&amp;s) tag := true for _,v := range *path &#123; if v == s &#123; tag = false break &#125; &#125; if tag &#123; *path = append(*path, s) *ret = append(*ret, root) &#125; &#125;else&#123; for i:=k; i&lt;=n;i++ &#123; nums[i], nums[k] = nums[k], nums[i] Perm(nums, k+1, n, path, ret) nums[i], nums[k] = nums[k], nums[i] &#125; &#125;&#125;func insertNode(root *TreeNode, val int) *TreeNode &#123; if root == nil &#123; root = new(TreeNode) root.Val = val return root &#125; if root.Val&gt;val &#123; root.Left = insertNode(root.Left, val) &#125;else&#123; root.Right = insertNode(root.Right, val) &#125; return root&#125;func createBST(root *TreeNode, nums []int) *TreeNode&#123; if len(nums) == 0 &#123; return root &#125; for _,v := range nums &#123; root = insertNode(root, v) &#125; return root&#125;func preorder(root *TreeNode, s *int) &#123; if root == nil &#123; return &#125; //fmt.Printf("%d ", root.Val) *s = *s*10+root.Val preorder(root.Left, s) preorder(root.Right, s)&#125;func generateTrees(n int) []*TreeNode &#123; nums := []int&#123;&#125; path := []int&#123;&#125; ret := []*TreeNode&#123;&#125; for i:=1; i&lt;=n ; i++ &#123; nums = append(nums, i) &#125; Perm(nums, 0, len(nums)-1, &amp;path, &amp;ret) return ret&#125; 此算法针对L95有超时的问题]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L94 Binary Tree Inorder Traversal]]></title>
    <url>%2F2017-11-28-L94-Binary-Tree-Inorder-Traversal%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112Given a binary tree, return the inorder traversal of its nodes&apos; values.For example:Given binary tree [1,null,2,3], 1 \ 2 / 3return [1,3,2].Note: Recursive solution is trivial, could you do it iteratively? 解题思路 使用递归 使用栈进行循环 Go递归实现1123456789101112131415func inorder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; inorder(root.Left, path) *path = append(*path, root.Val) inorder(root.Right, path)&#125;func inorderTraversal(root *TreeNode) []int &#123; path :=[]int&#123;&#125; inorder(root, &amp;path) return path&#125; Go递归实现2123456789func inorderTraversal(root *TreeNode) []int &#123; if root == nil&#123; return []int&#123;&#125; &#125; path:=inorderTraversal(root.Left) path = append(path, root.Val) return append(path, inorderTraversal(root.Right)...)&#125; Go非递归实现11234567891011121314151617181920212223func inorderTraversal(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var stack []*TreeNode path :=[]int&#123;&#125; for root!=nil || len(stack)&gt;0 &#123; if root!=nil &#123; stack = append(stack, root) root = root.Left &#125;else&#123; root = stack[len(stack)-1] stack = stack[0:len(stack)-1] path = append(path, root.Val) root = root.Right &#125; &#125; return path&#125; Go非递归实现21234567891011121314151617181920212223242526272829303132func inorderTraversal(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var stack []*TreeNode path :=[]int&#123;&#125; stack = append(stack, root) for len(stack)&gt;0 &#123; current := stack[len(stack)-1] //向左走到尽头 for current!=nil &#123; stack = append(stack, current.Left) current = current.Left &#125; //空指针退栈 stack = stack[0:len(stack)-1] if len(stack)&gt;0 &#123; current = stack[len(stack)-1] stack = stack[0:len(stack)-1] //访问节点 path = append(path, current.Val) //将右节点压入栈 stack = append(stack, current.Right) &#125; &#125; return path&#125; 不使用栈非递归方法 http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pascal_Triangle]]></title>
    <url>%2F2017-11-28-L118-Pascal-Triangle%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112Given numRows, generate the first numRows of Pascal&apos;s triangle.For example, given numRows = 5,Return[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 杨辉三角，第5行的4为例，其等于第四行的1+3。 解题思路使用递归在numRows = 1 为[1]在numRows = 2 为[1,1]在numsRows =N, 其相对N-1进行三角加和 Go递归实现1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport "fmt"func pascal(n int) []int &#123; if n==0 &#123; ret :=[]int&#123;1&#125; return ret &#125; if n==1 &#123; ret:=[]int&#123;1,1&#125; return ret &#125; tmp := pascal(n-1) ret :=[]int&#123;&#125; for i:=0; i&lt;n; i++ &#123; k:=i-1 s:=0 if k&lt;0 &#123; s=tmp[i] &#125;else&#123; s = tmp[i] + tmp[k] &#125; ret = append(ret, s) &#125; ret = append(ret, 1) return ret&#125;func generate(numRows int) [][]int &#123; ret := [][]int&#123;&#125; for i:=0; i&lt;numRows; i++ &#123; ret = append(ret, pascal(i)) &#125; return ret&#125;func main() &#123; fmt.Println(generate(5))&#125; 此思路，也可以解决L119 Pascal’s Triangle II Go非递归实现1234567891011121314151617181920212223242526272829303132func generate(numRows int) [][]int &#123; ret := [][]int&#123;&#125; if numRows == 0 &#123; return ret &#125;else if numRows == 1 &#123; tmp:=[]int&#123;1&#125; ret = append(ret,tmp) return ret &#125; ret = append(ret, []int&#123;1&#125;) ret = append(ret,[]int&#123;1,1&#125;) for n:=2; n&lt;numRows; n++ &#123; preTmp := ret[n-1] tmp :=[]int&#123;&#125; for i:=0; i&lt;n; i++ &#123; k:=i-1 s:=0 if k&lt;0 &#123; s=preTmp[i] &#125;else&#123; s = preTmp[i] + preTmp[k] &#125; tmp = append(tmp, s) &#125; tmp = append(tmp, 1) ret = append(ret, tmp) &#125; return ret&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L114_Flatten Binary Tree to Linked List]]></title>
    <url>%2F2017-11-28-L114-Flatten-Binary-Tree-to-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述12345678910111213141516171819202122Given a binary tree, flatten it to a linked list in-place.For example,Given 1 / \ 2 5 / \ \ 3 4 6The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 解题思路非递归解题思路 通过DFS遍历，首先将root压入stack stack.pop设置为current，将current的right先压入栈，left后压入栈 设置current.left为nil,current的right为栈的最后一个元素 遍历到最后一个元素的时候，如果栈为空，将current的right设置为nil 如果栈为空，完成所有操作 递归解题思路以如下树为例： 12345 2 / \3 4 \ 7 当前root为2的时候，先保存left[3]和right[4] 将root[2]对应的left设置为nil，root[2]对应的right设置为3 遍历right的right直到为right为nil，将right[4]设置为当前节点的right Go非递归实现12345678910111213141516171819202122232425262728293031323334func preOrder(root *TreeNode) &#123; if root == nil &#123; return &#125; var stack []*TreeNode stack = append(stack, root) for len(stack)&gt;0 &#123; current :=stack[len(stack)-1] stack = stack[0:len(stack)-1] if current.Right!=nil &#123; stack = append(stack, current.Right) &#125; if current.Left!=nil &#123; stack = append(stack, current.Left) &#125; current.Left = nil if len(stack) == 0 &#123; current.Right = nil &#125;else&#123; current.Right = stack[len(stack)-1] &#125; &#125;&#125;func flatten(root *TreeNode) &#123; preOrder(root)&#125; Go递归实现123456789101112131415161718func flatten(root *TreeNode)&#123; if root == nil &#123; return &#125; flatten(root.Left) flatten(root.Right) left := root.Left right := root.Right root.Left = nil root.Right = left for root.Right!=nil &#123; root = root.Right &#125; root.Right = right&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L108 Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2017-11-27-L108-Convert-Sorted-Array-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011Given an array where elements are sorted in ascending order, convert it to a height balanced BST.Input:[0,1,2,3,4,5]Ouput: 3 / \ 1 5 / / 2 4 解题思路通过定位中间数作为根节点，然后二分迭代。 Go 递归实现12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport "fmt"/** * Definition for a binary tree node. */ type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func insertNode(root *TreeNode, nums []int, start int, end int) *TreeNode &#123; if start&gt;end&#123; return nil &#125; p := (start+end)/2 root = new(TreeNode) root.Val = nums[p] root.Left = insertNode(root.Left, nums, start, p-1) root.Right = insertNode(root.Right, nums, p+1, end) return root&#125;func sortedArrayToBST(nums []int) *TreeNode &#123; root := insertNode(nil, nums, 0, len(nums)-1) return root&#125;func main() &#123; var root *TreeNode //nums := []int&#123;1,3,5,7,9&#125; nums :=[]int&#123;0,1,2,3,4,5&#125; root = sortedArrayToBST(nums) fmt.Println(root)&#125; 相似题目 [L109]Convert Sorted List to Binary Search Tree 方案1：遍历链表生成数组 1234567891011func sortedListToBST(head *ListNode) *TreeNode &#123; nums :=[]int&#123;&#125; for head!=nil &#123; nums = append(nums, head.Val) head = head.Next &#125; root := insertNode(nil, nums, 0, len(nums)-1) return root&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L105_Construct_Binary_Tree]]></title>
    <url>%2F2017-11-27-L105-Construct-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述L105通过preorder以及inorder构建二叉树 12preorder = [1,2,4,3,5]inorder = [4,2,1,3,5] L106通过postorder以及inorder构建二叉树 12postorder = [4,2,5,3,1]inorder = [4,2,1,3,5] 通过preorder以及postorder无法构建二叉树，原因在于无法定位根节点。 解题思路首先找到根节点，然后在inorder找到其他的index，[0,index-1]为左子树，[index+1,]为右子树。递归左子树部分，通过左子树的inorder以及preorder生成左子树。同理右子树也如此。 Go递归实现通过preorder以及inorder生成二叉树123456789101112131415161718192021222324252627282930313233func build(preorder []int, inorder []int, inStart int, inEnd int, preIndex *int)*TreeNode &#123; if inStart&gt;inEnd &#123; return nil &#125; node := new(TreeNode) node.Val = preorder[*preIndex] *preIndex += 1 if inStart == inEnd &#123; return node &#125; inIndex := search(inorder, inStart, inEnd, node.Val) node.Left = build(preorder, inorder, inStart, inIndex-1, preIndex) node.Right = build(preorder, inorder, inIndex+1, inEnd, preIndex) return node&#125;func search(inorder []int, inStart int, inEnd int, val int) int &#123; for i:=inStart;i&lt;=inEnd ;i++ &#123; if inorder[i] == val &#123; return i &#125; &#125; return -1&#125;func buildTree(preorder []int, inorder []int) *TreeNode &#123; preIndex:=0 return build(preorder, inorder, 0, len(inorder)-1, &amp;preIndex)&#125; 参考链接：http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/ 通过postorder以及inorder生成二叉树1234567891011121314151617181920212223242526272829303132333435func build(inorder []int, postorder []int, inStart int, inEnd int, postIndex *int)*TreeNode &#123; if inStart&gt;inEnd &#123; return nil &#125; node := new(TreeNode) node.Val = postorder[*postIndex] *postIndex -= 1 if inStart == inEnd&#123; return node &#125; inIndex := search(inorder, inStart, inEnd, node.Val) node.Right = build(inorder, postorder,inIndex+1, inEnd, postIndex) node.Left = build(inorder, postorder,inStart, inIndex-1, postIndex) return node&#125;func search(inorder []int, inStart int, inEnd int, val int) int &#123; var i int for i=inStart;i&lt;=inEnd ;i++ &#123; if inorder[i] == val &#123; break &#125; &#125; return i&#125;func buildTree(inorder []int, postorder []int) *TreeNode &#123; postIndex:=len(postorder)-1 return build(inorder, postorder, 0, len(inorder)-1, &amp;postIndex)&#125; 参考链接：http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/ 通过postorder和inorder生成二叉树，是先递归生成右子树，然后再是左子树。中心思想是先定位根节点。 以postorder为例说明:[4,2,5,3,1] 12345 1 / \ 2 3 / \4 5 postorder[4]为根节点postorder[3]为根节点的右节点 同样preorder为例说明:[1,2,4,3,5] preorder[0]为根节点preorder[1]为根节点的左节点]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L113 Path Sum II]]></title>
    <url>%2F2017-11-24-L113-Path-Sum-II%2F</url>
    <content type="text"><![CDATA[题目描述12345678910111213141516Given a binary tree and a sum, find all root-to-leaf paths where each path&apos;s sum equals the given sum.For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1return[ [5,4,11,2], [5,8,4,5]] 解题思路题目和L112 Path Sum思路相同，通过DFS遍历获取路径。不同的是需要通过数组保存路径。 Go递归实现12345678910111213141516171819202122232425262728293031func DFS(root *TreeNode, target int, sum int, path []int, ret *[][]int) &#123; if root == nil&#123; return &#125; sum += root.Val tmp := append(path, root.Val) path = tmp[:] if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp;sum == target&#123; //*ret = append(*ret, path) tmp :=[]int&#123;&#125; for _,v:= range path &#123; tmp = append(tmp, v) &#125; *ret = append(*ret, tmp) &#125; DFS(root.Left, target, sum, path, ret) DFS(root.Right, target, sum, path, ret)&#125;func pathSum(root *TreeNode, sum int) [][]int &#123; path :=[]int&#123;&#125; ret :=[][]int&#123;&#125; DFS(root, sum, 0, path, &amp;ret) return ret&#125; 这里的path不能直接append，而是进行值的拷贝 Go循环实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263func judge(current *TreeNode, parent map[*TreeNode]*TreeNode, target int) []int &#123; var stack []*TreeNode path :=[]int&#123;&#125; sum := 0 for current!=nil &#123; stack = append(stack, current) sum += current.Val current = parent[current] &#125; if sum == target &#123; k := len(stack)-1 for k &gt;=0&#123; path = append(path, stack[k].Val) k-- &#125; return path &#125;else&#123; return nil &#125;&#125;func dfsNoRecursion(root *TreeNode, target int) [][]int &#123; if root == nil&#123; return nil &#125; var stack []*TreeNode ret :=[][]int&#123;&#125; stack = append(stack, root) parent := make(map[*TreeNode]*TreeNode, 0) parent[root] = nil var current *TreeNode for len(stack)&gt;0 &#123; current = stack[len(stack)-1] stack = stack[0:len(stack)-1] if current.Left == nil &amp;&amp; current.Right==nil &#123; path :=judge(current, parent,target) if path !=nil &#123; ret = append(ret, path) &#125; &#125; if current.Right !=nil &#123; stack = append(stack, current.Right) parent[current.Right] = current &#125; if current.Left != nil &#123; stack = append(stack, current.Left) parent[current.Left] = current &#125; &#125; return ret&#125;func pathSum(root *TreeNode, sum int) [][]int &#123; ret:=dfsNoRecursion(root, sum) return ret&#125; 需要记录节点的父亲节点信息，用于路径的回溯 参考的链接:http://www.geeksforgeeks.org/print-root-leaf-path-without-using-recursion/ Python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849__author__ = 'guosong'# Definition for a binary tree node.class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ path = [] ret = [] self.dfs(root, sum, 0, path, ret) return ret def initTree(self, root, nums, i, n): if i &lt; n: if nums[i] == -1: root = None else: node = TreeNode(nums[i]) root = node root.left = self.initTree(root.left, nums, 2*i+1, n) root.right = self.initTree(root.right, nums, 2*i+2, n) return root def dfs(self, root, target, s,path, ret): if not root: return s += root.val path = path + [root.val] #path.append(root.val) if not root.left and not root.right and s == target: ret.append(path) self.dfs(root.left, target, s, path, ret) self.dfs(root.right, target,s, path, ret)s = Solution()nums = [5,4,8,11,-1,13,4,7,2,-1,-1,-1,-1,5,1]root = Noneroot = s.initTree(root, nums,0,len(nums))print s.pathSum(root, 22) 注意点：path的追加方式不是通过path.append(root.val)，而是path=path+[root.val]的方式。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L112 Path Sum]]></title>
    <url>%2F2017-11-23-L112-Path-Sum%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 解题思路使用深度遍历的方式进行解决。 Go实现12345678910111213141516171819func travel(root *TreeNode, target int, sum int) bool&#123; if root == nil &#123; return false &#125; sum += root.Val if root.Left==nil &amp;&amp; root.Right==nil &#123; if sum == target &#123; return true &#125;else&#123; return false &#125; &#125; return travel(root.Left, target, sum) || travel(root.Right, target, sum)&#125;func hasPathSum(root *TreeNode, sum int) bool &#123; return travel(root, sum, 0)&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L111 Minimum Depth of Binary Tree]]></title>
    <url>%2F2017-11-22-L111-Minimum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.Example: 1 / 2Output:2 解题思路和104题目的解题思路相同 不同的是将depth设置为一个比较大的数，和level+1进行比较，如果出现更小的就替换。 Go实现1234567891011121314151617181920212223242526func travel(root *TreeNode, depth *int, level int) &#123; if root==nil &#123; return &#125; if root.Left == nil &amp;&amp; root.Right==nil &#123; if *depth&gt;level+1 &#123; *depth = level+1 &#125; return &#125; travel(root.Left, depth, level+1) travel(root.Right, depth, level+1)&#125;func minDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; var depth int depth=10000 travel(root, &amp;depth, 0) return depth&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L104 Maximum Depth of Binary Tree]]></title>
    <url>%2F2017-11-21-L104-Maximum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述1234Given a binary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解题思路将maxDepth设置为0， 判断当面节点的depth是否大于maxDepth，如果是就替换。 Go实现1234567891011121314151617func travel(root *TreeNode, depth *int, level int)&#123; if root == nil&#123; if *depth &lt; level&#123; *depth = level &#125; return &#125;else&#123; travel(root.Left, depth, level+1) travel(root.Right, depth, level+1) &#125;&#125;func maxDepth(root *TreeNode) int &#123; var depth int travel(root, &amp;depth, 0) return depth&#125; 这个方法遍历了两边，是否可以减少遍历 1234567891011121314func maxDepth(root *TreeNode) int &#123; if root == nil&#123; return 0 &#125; leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) if leftDepth &gt;rightDepth&#123; return leftDepth+1 &#125;else &#123; return rightDepth+1 &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Traceroute]]></title>
    <url>%2F2017-11-20-Traceroute%2F</url>
    <content type="text"><![CDATA[背景用户反馈使用移动4G以及wifi访问公司业务有问题，使用电信没有问题，故需要获取用户网络相关访问信息。traceroute工具是第一选择。 Traceroute使用说明通过traceroute可以知道信息从计算机到互联网另一端的访问路径。traceroute通过发送小的数据包到目的设备直到其返回，来测量其需多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次的测试时间、设备名称（有的话）以及其IP地址。 Traceroute APP小白用户无法使用traceroute命令，况且需要在手机上traceroute，针对这个问题有traceroute APP。推荐腾讯云诊断APP，可以将针对结果通过QQ和微信分享。 其诊断信息包括： Http Net Ping NSLookup TraceRoute Device信息 PortScan Mtuscan Host 如下是腾讯云诊断APP的结果展示: 参考文档 https://www.cnblogs.com/peida/archive/2013/03/07/2947326.html]]></content>
      <tags>
        <tag>Linux Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L110 Balanced Binary Tree]]></title>
    <url>%2F2017-11-20-L110-Balanced-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述123Given a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 判断一个二叉树是否为平衡二叉树。平衡的定义是左右子树树的高度相差小于等于1。 解题思路使用前序遍历树，然后其对应的左右子树高度是否小于等于1。 Go实现12345678910111213141516171819202122232425262728293031func height(root *TreeNode, maxDepth *int, level int) &#123; if root == nil&#123; return &#125; if *maxDepth &lt;level &#123; *maxDepth = level &#125; height(root.Left, maxDepth, level+1) height(root.Right, maxDepth, level+1)&#125;func preOrder(root *TreeNode) bool &#123; var leftDepth=0 var rightDepth=0 if root == nil&#123; return true &#125; height(root.Left, &amp;leftDepth, 1) height(root.Right, &amp;rightDepth, 1) delta := leftDepth-rightDepth if delta&gt;=-1 &amp;&amp; delta&lt;=1 &#123; return preOrder(root.Left) &amp;&amp; preOrder(root.Right) &#125;else&#123; return false &#125;&#125;func isBalanced(root *TreeNode) bool &#123; return preOrder(root)&#125; 注意这里的level在root为非nil的时候设置为1 计算树的高度算法1234567func findDepth(root *TreeNode) int &#123; if nil == root &#123; return 0 &#125; return maxInt(findDepth(root.Left), findDepth(root.Right)) + 1&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L107 Binary Tree Level Order Traversal II]]></title>
    <url>%2F2017-11-19-L107-Binary-Tree-Level-Order-Traversal-II%2F</url>
    <content type="text"><![CDATA[题目描述12345678910111213141516Given a binary tree, return the bottom-up level order traversal of its nodes values.(ie, from left to right, level by level from leaf to root).For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its bottom-up level order traversal as:[ [15,7], [9,20], [3]] 层次遍历树节点，并按照层次的逆序输出 解题思路使用前序遍历的方法，将各个节点对应的level打印出来，然后level进行归类。 Go实现-递归1234567891011121314151617181920212223242526272829303132333435363738394041424344import ( "sort")func preorder(root *TreeNode, ret *[]int, levelList *[]int, level int) &#123; if root == nil&#123; return &#125; *ret = append(*ret, root.Val) *levelList = append(*levelList, level) preorder(root.Left, ret, levelList, level+1) preorder(root.Right, ret, levelList, level+1)&#125;func levelOrderBottom(root *TreeNode) [][]int &#123; if root == nil&#123; return nil &#125; r :=[][]int&#123;&#125; ret :=[]int&#123;&#125; levelList :=[]int&#123;&#125; preorder(root, &amp;ret, &amp;levelList,0) m := map[int][]int&#123;&#125; for i,v:=range levelList &#123; m[v] = append(m[v], ret[i]) &#125; keys :=[]int&#123;&#125; for k := range m&#123; keys = append(keys, k) &#125; sort.Ints(keys) n := len(keys) - 1 for n&gt;=0 &#123; r = append(r, m[keys[n]]) n-- &#125; return r&#125; 前序遍历比较简单，主要代码在于结果的处理。 相似题目L102其输出的顺序是层次遍历二叉树，根节点先出，最后是叶子节点. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport "fmt"/** * Definition for a binary tree node. */type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func initTree(root *TreeNode, nums []int, i int, n int) *TreeNode &#123; var node *TreeNode if i &lt; n &#123; if nums[i] == -1 &#123; root = nil &#125; else &#123; node = new(TreeNode) node.Val = nums[i] root = node root.Left = initTree(root.Left, nums, 2*i+1, n) root.Right = initTree(root.Right, nums, 2*i+2, n) &#125; &#125; return root&#125;func travel(root *TreeNode, level int, m map[int][]int) &#123; if root == nil &#123; return &#125; if _, ok := m[level]; !ok &#123; m[level] = []int&#123;root.Val&#125; &#125; else &#123; m[level] = append(m[level], root.Val) &#125; travel(root.Left, level+1, m) travel(root.Right, level+1, m)&#125;func levelOrder(root *TreeNode) [][]int &#123; m := make(map[int][]int, 0) ret := [][]int&#123;&#125; travel(root, 0, m) maxDepth := 0 for k, _ := range m &#123; if maxDepth &lt; k &#123; maxDepth = k &#125; &#125; for i := 0; i &lt;= maxDepth; i++ &#123; ret = append(ret, m[i]) &#125; return ret&#125;func main() &#123; var root *TreeNode nums := []int&#123;3, 9, 20, -1, -1, 15, 7&#125; root = initTree(root, nums, 0, len(nums)) ret := levelOrder(root) fmt.Println(ret)&#125; 相似题目L103通过深度遍历，记录各个节点的level，然后以zigzag的方式输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func travel(root *TreeNode, level int, m map[int][]int) &#123; if root == nil &#123; return &#125; if _, ok := m[level]; !ok &#123; m[level] = []int&#123;root.Val&#125; &#125; else &#123; m[level] = append(m[level], root.Val) &#125; travel(root.Left, level+1, m) travel(root.Right, level+1, m)&#125;func reverse(nums []int) []int &#123; s:=0 e:=len(nums)-1 for s&lt;e&#123; nums[s], nums[e] = nums[e], nums[s] s++ e-- &#125; return nums&#125;func zigzagLevelOrder(root *TreeNode) [][]int &#123; m := make(map[int][]int, 0) ret := [][]int&#123;&#125; if root == nil&#123; return ret &#125; travel(root, 0, m) maxDepth := 0 for k, _ := range m &#123; if maxDepth &lt; k &#123; maxDepth = k &#125; &#125; for i := 0; i &lt;= maxDepth; i++ &#123; if i%2==1 &#123; ret = append(ret, reverse(m[i])) &#125;else&#123; ret = append(ret, m[i]) &#125; &#125; return ret&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L101_Symmetric_Tree]]></title>
    <url>%2F2017-11-17-L101-Symmetric-Tree%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112131415161718Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \3 4 4 3But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3Note:Bonus points if you could solve it both recursively and iteratively. 解题思路此题目可以转化为L100_Same_Tree的解题思路。L100是判断两颗树是否相同，比较Left和Right是否相同，对两个数进行中序遍历。此题目可以对root的Left进行中左右遍历，对root的Right进行中右左遍历。 Go实现-递归123456789101112131415161718192021222324func judge(left *TreeNode, right *TreeNode) bool &#123; if left == nil &amp;&amp; right == nil&#123; return true &#125; if (left == nil &amp;&amp; right !=nil) || (left !=nil &amp;&amp; right == nil)&#123; return false &#125; if left.Val == right.Val &#123; return judge(left.Left, right.Right) &amp;&amp; judge(left.Right, right.Left) &#125;else&#123; return false &#125;&#125;func isSymmetric(root *TreeNode) bool &#123; if root == nil&#123; return true &#125; return judge(root.Left, root.Right)&#125; NOTE:如果root节点为nil，返回值为true 去除重复的逻辑判断后的代码 123456789101112131415161718func judge(left *TreeNode, right *TreeNode) bool &#123; if left == nil &amp;&amp; right == nil&#123; return true &#125; if left == nil || right !=nil&#123; return false &#125; return (left.Val == right.Val) &amp;&amp; judge(left.Left, right.Right) &amp;&amp; judge(left.Right, right.Left) &#125;func isSymmetric(root *TreeNode) bool &#123; return judge(root, root)&#125; Go非递归实现使用非递归遍历的方法将左右子树节点放在数组中，然后比较这两个数组的数据是否相同。注意点：对于不存在的节点，其对应的值为-1，例如下面的例子: 12345 1 / \2 2 \ \ 3 3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758func order(root *TreeNode, flag bool) (t_list[]int) &#123; var stack []*TreeNode var p *TreeNode p = root for p != nil || len(stack)!=0 &#123; for p!=nil &#123; t_list = append(t_list, p.Val) stack = append(stack, p) if flag &#123; p = p.Left &#125;else &#123; p = p.Right &#125; &#125; t_list = append(t_list, -1) if len(stack)!=0 &#123; p = stack[len(stack)-1] stack = stack[0:len(stack)-1] if flag &#123; p = p.Right &#125;else&#123; p = p.Left &#125; &#125; &#125; return&#125;func judge(t1 *TreeNode, t2 *TreeNode) bool &#123; if t1 == nil &amp;&amp; t2 == nil&#123; return true &#125; if t1 == nil || t2 ==nil&#123; return false &#125; var t1_list []int var t2_list []int t1_list = order(t1.Left, true) t2_list = order(t2.Right, false) if len(t1_list) != len(t2_list) &#123; return false &#125; for i:=0;i&lt;len(t1_list);i++ &#123; if t1_list[i] != t2_list[i] &#123; return false &#125; &#125; return true&#125;func isSymmetric(root *TreeNode) bool &#123; return judge(root, root)&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L100_SameTree]]></title>
    <url>%2F2017-11-17-L100-SameTree%2F</url>
    <content type="text"><![CDATA[题目描述判断两个二叉树是否相同 1234567891011121314151617181920212223242526272829303132Given two binary trees, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical and the nodes have the same value.Example 1:Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: trueExample 2:Input: 1 1 / \ 2 2 [1,2], [1,null,2]Output: falseExample 3:Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]Output: false 解题思路中序遍历二叉树 Go实现123456789101112131415161718192021func isSameTree(p *TreeNode, q *TreeNode) bool &#123; if p==nil &amp;&amp; q ==nil&#123; return true &#125; if (p==nil &amp;&amp; q !=nil)||(p!=nil &amp;&amp; q==nil) &#123; return false &#125; if p.Val==q.Val &#123; flag:=isSameTree(p.Left, q.Left) if flag &#123; flag=isSameTree(p.Right, q.Right) &#125;else&#123; return false &#125; return flag &#125;else&#123; return false &#125;&#125; 将flag部分去掉，改进的写法: 123456789101112131415func isSameTree(p *TreeNode, q *TreeNode) bool &#123; if p==nil &amp;&amp; q ==nil&#123; return true &#125; if (p==nil &amp;&amp; q !=nil)||(p!=nil &amp;&amp; q==nil) &#123; return false &#125; if p.Val==q.Val &#123; return isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right,q.Right) &#125;else&#123; return false &#125;&#125; 问题难点在完成这道题目的时候，直接submit的，没有进行测试，难点在于如何构建这个二叉树。 使用后续遍历的方式生成二叉树。 Go代码实现 12345678910111213141516func initTree(root *TreeNode, nums []int, i int, n int) *TreeNode &#123; var node *TreeNode if i&lt;n &#123; if nums[i] == -1&#123; node = nil &#125;else&#123; node = new(TreeNode) node.Val = nums[i] root = node root.Left = initTree(root.Left, nums, 2*i+1, n) root.Right = initTree(root.Right, nums, 2*i+2, n) &#125; &#125; return root&#125; 参考来源：http://www.geeksforgeeks.org/construct-complete-binary-tree-given-array/ 测试 使用中序遍历1234567func inOrder(root *TreeNode) &#123; if root!=nil &#123; inOrder(root.Left) fmt.Println(root.Val) inOrder(root.Right) &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L83_Merge_Sorted_Array]]></title>
    <url>%2F2017-11-16-L83-Merge-Sorted-Array%2F</url>
    <content type="text"><![CDATA[题目描述12345Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 解题思路nums1有足够的空间可以容纳2个数组的数据，故解题思路前提是不额外申请空间。遍历nums2数据对nums1进行插入排序。 Go实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport "fmt"func merge(nums1 []int, m int, nums2 []int, n int) &#123; if m == 0 &#123; for k:=0;k&lt;n;k++ &#123; nums1[k] = nums2[k] &#125; &#125; if n == 0 &#123; return &#125; j:=0 for j&lt;n &#123; i:=0 for i&lt;m &amp;&amp; nums1[i]&lt;nums2[j] &#123; i++ &#125; if i&gt;=m &#123; nums1[i] = nums2[j] j++ &#125;else &#123; t := nums1[i] nums1[i] = nums2[j] for i&lt;m &#123; t1 :=nums1[i+1] nums1[i+1] = t t = t1 i++ &#125; j++ &#125; m +=1 &#125;&#125;func main() &#123; nums1 := make([]int,10) //[]int&#123;1,3,5&#125; nums1[0] = 1 nums1[1] = 0 nums2 :=[]int&#123;2&#125; m := 1 n := 1 merge(nums1, m, nums2, n) fmt.Println(nums1[0:m+n])&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L83_从有序链表中删除重复的数据]]></title>
    <url>%2F2017-11-16-LeetCode-L83-%E4%BB%8E%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[题目描述12345Given a sorted linked list, delete all duplicates such that each element appear only once.For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 从有序链表中删除重复的数据 解题思路 使用两个指针prev，next变量链表 判断next的val是否和prev的val相同 如果相同，将prev的next设置为next.next，删除next节点 如果不同，将prev以及next都往后移动 Go 循环实现增加Insert以及printNode两个函数便于测试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport "fmt"/** * Definition for singly-linked list.*/type ListNode struct &#123; Val int Next *ListNode&#125;func Insert(vals...int) *ListNode&#123; var head *ListNode current := head for _,v := range vals &#123; n := new(ListNode) n.Val = v if head == nil &#123; head = n current = head &#125;else&#123; current.Next = n current = n &#125; &#125; return head&#125;func printNode(head *ListNode) &#123; for head!=nil &#123; fmt.Println(head.Val) head = head.Next &#125;&#125;func deleteDuplicates(head *ListNode) *ListNode &#123; if head == nil&#123; return nil &#125; prev := head next := head.Next for next !=nil &#123; if next.Val == prev.Val &#123; prev.Next = next.Next &#125;else&#123; prev = next &#125; next = next.Next &#125; return head&#125;func main() &#123; //1-&gt;1-&gt;2-&gt;3-&gt;3 head :=Insert(1,1,2,3,3) deleteDuplicates(head) printNode(head)&#125; Go递归实现123456789101112func deleteDuplicates(head *ListNode) *ListNode&#123; if head == nil || head.Next == nil&#123; return head &#125; if head.Val == head.Next.Val&#123; return deleteDuplicates(head.Next) &#125;else&#123; head.Next = deleteDuplicates(head.Next) return head &#125;&#125; 递归实现的核心思想 如果head节点和head.Next出现重复，将head往重复的节点移动，按照再判断以此节点为head的链表去除情况。 如果head的后面节点没有和head相同，对head的Next节点为新的head进行去重判断。head节点维持不变。 Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445__author__ = 'guosong'# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or head.next == None: return head if head.val == head.next.val: return self.deleteDuplicates(head.next) else: head.next = self.deleteDuplicates(head.next) return head def insert(self, vals): head = None current = None for v in vals: n = ListNode(v) if not head: head = n current = head else: current.next = n current = current.next return head def printNode(self, head): while head: print head.val head = head.nexts = Solution()head = s.insert([1,1,2,3])head = s.deleteDuplicates(head)s.printNode(head)]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L66_PlusOne]]></title>
    <url>%2F2017-11-14-Leetcode-L66-PlusOne%2F</url>
    <content type="text"><![CDATA[题目描述12345Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.You may assume the integer do not contain any leading zero, except the number 0 itself.The digits are stored such that the most significant digit is at the head of the list. 大体意思是给一个数组表示一个非负数，这个非负数加上1，结果还返回一个数组 解题思路倒叙遍历数组，判断是否需要进位。 Go 版本1234567891011121314151617181920212223242526272829303132func plusOne(digits []int) []int &#123; n := len(digits) ret :=[]int&#123;&#125; s :=1 for i:=n-1; i&gt;=0; i-- &#123; s += digits[i] if s&gt;9&#123; ret = append(ret, s%10) s = s/10 &#125;else &#123; ret = append(ret,s) s = 0 &#125; &#125; if s &gt; 0&#123; ret = append(ret, s) &#125; n = len(ret) i:=0 j:=n-1 for i&lt;j&#123; ret[i], ret[j] = ret[j], ret[i] i++ j-- &#125; return ret&#125; Python版本在Go的版本临时申请一个数组保存结果，通过append函数在尾部进行追加，最后返回这个数组的倒序结果。 Python版本中不借助额外的空间，使用insert函数在头部插入。 1234567891011121314151617181920class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ n = len(digits) - 1 carry = 1 while n&gt;=0: digits[n] += carry if digits[n] &gt; 9: carry = digits[n]/10 digits[n] %= 10 else: carry = 0 n-=1 if carry: digits.insert(0,1) return digits]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L15_3sum]]></title>
    <url>%2F2017-11-13-leetcode-L15-3sum%2F</url>
    <content type="text"><![CDATA[题目描述Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 1234567For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 解题思路首先将数组进行排序，排序后使用3个索引进行sum的判断 Go版本1234567891011121314151617181920212223242526272829303132333435363738import ( "sort")func threeSum(nums []int) [][]int &#123; l := len(nums) r := [][]int&#123;&#125; sort.Ints(nums) for i:=0; i&lt;l-2;i++ &#123; j := i+1 k := l-1 for j&lt;k &#123; s := nums[i] + nums[j] + nums[k] if s&gt;0&#123; k-- &#125;else if s&lt;0 &#123; j++ &#125;else &#123; row:=[]int&#123;nums[i],nums[j], nums[k]&#125; flag := true for _, v := range r&#123; if v[0]==row[0] &amp;&amp;v[1] == row[1] &amp;&amp; v[2] == row[2] &#123; flag = false break &#125; &#125; if flag &#123; r = append(r,row) &#125; j++ k-- &#125; &#125; &#125; return r&#125; Python版本123456789101112131415161718192021222324252627class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ r = [] nums = sorted(nums) l = len(nums) for i in range(l): j = i + 1 k = l - 1 while j &lt; k: s = nums[i] + nums[j] + nums[k] if s &gt; 0: k -= 1 elif s &lt; 0: j += 1 else: t = [nums[i], nums[j], nums[k]] if t not in r: r.append(t) j += 1 k -= 1 return r]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcollector源码功能解读]]></title>
    <url>%2F2017-03-22-tcollectoryuan-ma-gong-neng-jie-du%2F</url>
    <content type="text"><![CDATA[简介 tcollector包括如下python学习点，强烈推荐阅读 参数解析 log日志 信号量 目录结构遍历 多线程以及多线程之间的数据共享 队列 定时任务 rpm打包 collector采集 程序兼容以及动态（collectors的动态更新，程序如何兼容） subprocess执行脚本 socket通信 正则表达式 守护进程 PYTHONPATH 设置 yield 迭代实现 单元测试以及mock 源码剖析]]></content>
  </entry>
  <entry>
    <title><![CDATA[AWS boto3]]></title>
    <url>%2F2017-02-08-aws-boto3%2F</url>
    <content type="text"><![CDATA[1.根据机器名称获取instance1234567ec2 = boto3.resource("ec2")instances = ec2.instances.filter(¦ ¦ Filters = [&#123;'Name': 'tag-value', 'Values':['service-test1']&#125;])for instance in instances:¦ print instance 2.获取所有机器的信息1234ec2 = boto3.resource("ec2")instances = ec2.instances.filter()for instance in instances:print instance 3.通过instance_id获取机器信息123ec2 = boto3.resource("ec2")instance = ec2.Instance('i-d8d0c8e1')print instance.instance_type 通过方法1和方法3获取信息所需要时间差不多，方法2获取所需要时间多。]]></content>
      <categories>
        <category>AWS API</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在AWS EC2搭建Hadoop2.6集群]]></title>
    <url>%2F2016-12-23-zai-aws-ec2da-jian-hadoop2-dot-6ji-qun%2F</url>
    <content type="text"><![CDATA[升级Java版本Hadoop2.X版本需要JDK1.8版本，故首要任务就先升级JDK 1234sudo yum install java-1.8.0-openjdk.x86_64#生成jpssudo yum install java-1.8.0-openjdk-devel.x86_64sudo alternatives --config java 安装hadoophttp://www.powerxing.com/install-hadoop-cluster/ 1234hdfs namenode -format # 首次运行需要执行初始化，之后不需要start-dfs.shstart-yarn.shmr-jobhistory-daemon.sh start historyserver 安装zookeeperhttp://blog.csdn.net/huwei2003/article/details/49101269 安装hbasehttp://www.cnblogs.com/nexiyi/p/hbase_intro_94.html 安装Hivehttp://kevin12.iteye.com/blog/2280777 问题汇总 找不到java驱动将java-connector-driver放在lib下 Terminal initialization failed; falling back to unsupported原因是hadoop目录下存在老版本jline： 12/hadoop-2.5.2/share/hadoop/yarn/lib：-rw-r--r-- 1 root root 87325 Mar 10 18:10 jline-0.9.94.jar 解决方法是：将hive下的新版本jline的JAR包拷贝到hadoop下： 1234cp /hive/apache-hive-1.1.0-bin/lib/jline-2.12.jar .//hadoop-2.5.2/share/hadoop/yarn/lib：-rw-r--r-- 1 root root 87325 Mar 10 18:10 jline-0.9.94.jar.bak-rw-r--r-- 1 root root 213854 Mar 11 22:22 jline-2.12.jar IntelliJIDE配置Maven库 使用私有的maven库12org.apache.hadoop.ipc.RemoteException: Server IPC version 9 cannot communicaite with client version 4 log4j:WARN No appenders could be found for logger (org.apache.hadoop.metrics2.lib.MutableMetricsFactory). Permission denied: user=guosong 写HDFS无权限[hadoop@hbase-test-00 ~]$ hdfs dfs -chown -R guosong:guosong /user/guosong[hadoop@hbase-test-00 ~]$ hdfs dfs -ls /user/guosong https://github.com/ljdursi/hadoop-for-hpcers-tutorial/blob/master/presentation/presentation.md Cannot run program “map.py”: error=2, No such file or directory 错误的命令 1hadoop jar ./hadoop-2.6.4/share/hadoop/tools/lib/hadoop-streaming-2.6.4.jar -input input/ncdd.txt -output output -mapper map.py -reducer reduce.py 正确的命令 1hadoop jar ./hadoop-2.6.4/share/hadoop/tools/lib/hadoop-streaming-2.6.4.jar -input input/ncdd.txt -output output -mapper map.py -file ./map.py -reducer reduce.py -file ./reduce.py https://wiki.apache.org/hadoop/HadoopStreaming Error: Could not find or load main class StreamCompressor 正确的方式： 1234567891011[hadoop@hbase-test-00 StreamCompressor]$ lltotal 4-rw-r--r-- 1 hadoop hadoop 1831 Jan 4 17:26 StreamCompressor.class[hadoop@hbase-test-00 StreamCompressor]$ echo $HADOOP_CLASSPATH/home/hadoop/code/StreamCompressor:[hadoop@hbase-test-00 StreamCompressor]$ pwd/home/hadoop/code/StreamCompressor[hadoop@hbase-test-00 StreamCompressor]$ echo &quot;TestDDDDDDDDDDD&quot; | hadoop StreamCompressor org.apache.hadoop.io.compress.GzipCodec |gunzip17/01/04 18:05:36 INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library17/01/04 18:05:37 INFO compress.CodecPool: Got brand-new compressor [.gz]TestDDDDDDDDDDD 引申问题 HDFS块为什么设置128M？ namenode和datanode的区别？ namenode的HA方式？ Hadoop如何动态增加DataNode节点？]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Group Replication]]></title>
    <url>%2F2016-12-22-mysql-group-replication%2F</url>
    <content type="text"><![CDATA[1.前言2016年12月12日 MySQL5.7的Group Replication功能GA啦，一时间在微博、微信都有很多提起，主要看了如下一些分享： MySQL开发组的宋利兵分享的High Aavialability with Group Replication 云和恩墨团队以前同事分享的GR的基础知识 本文主要是基于MySQL5.7.17版本，参照MySQL5.7手册Group Replication部分进行实践。 2.Group Replication配置2.1 编译MySQL5.7.17 下载带有boost库版本的源码 cmake编译 1234cmake -DCMAKE_INSTALL_PREFIX=/home/guosong/mysql5717 \-DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_general_ci -DDOWNLOAD_BOOST=0 \-DWITH_BOOST=./boost/boost_1_59_0/ make &amp;&amp; make install 创建etc、tmp、log目录放置配置文件、日志文件以及socket等文件 初始化DB 1./bin/mysql_install_db --defaults-file=./etc/my5717.cnf --datadir=./data --lc-messages-dir=./share/ 2.2 Group Replication 基本配置 123456789server_id=XXXgtid_mode=ONenforce_gtid_consistency=ONmaster_info_repository=TABLErelay_log_info_repository=TABLEbinlog_checksum=NONElog_slave_updates=ONlog_bin=binlogbinlog_format=ROW Group Replication配置 123456transaction_write_set_extraction=XXHASH64loose-group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"loose-group_replication_start_on_boot=offloose-group_replication_local_address= "10.30.6.217:5718"loose-group_replication_group_seeds= "10.30.6.217:5718,10.30.6.184:5718,10.30.6.183:5718"loose-group_replication_bootstrap_group= off &gt;Line1 表示服务器记录每个事务基于XXHASH64算法对应的hahs值Line2 表示 group 名称Line3 表示插件在server启动后是否自动启动，此处设置不启动Line4 表示插件使用的IP地址10.30.6.217，端口5718为和其他成员连接使用，此处设置MySQL端口加1的Line5 表示组内成员所有的连接地址Line6 表示是否启动bootstrap 启动插件以及设置用户权限 12345678910111213141516INSTALL PLUGIN group_replication SONAME 'group_replication.so';mysql&gt; show plugins ;+----------------------------+----------+--------------------+----------------------+---------+| Name | Status | Type | Library | License |+----------------------------+----------+--------------------+----------------------+---------+| binlog | ACTIVE | STORAGE ENGINE | NULL | GPL || group_replication | ACTIVE | GROUP REPLICATION | group_replication.so | GPL |+----------------------------+----------+--------------------+----------------------+---------+mysql&gt; show grants for 'replica'@'%';+---------------------------------------------------------------------+| Grants for replica@% |+---------------------------------------------------------------------+| GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'replica'@'%' |+---------------------------------------------------------------------+1 row in set (0.00 sec) 启动Group Replication 123456CHANGE MASTER TO MASTER_USER='rpl_user', MASTER_PASSWORD='rpl_pass' \\FOR CHANNEL 'group_replication_recovery';SET GLOBAL group_replication_bootstrap_group=ON;START GROUP_REPLICATION;SET GLOBAL group_replication_bootstrap_group=OFF; 在三台server进行相关设置，全部开启Group_replication 状态校验 12345678mysql&gt; select * from performance_schema.replication_group_members;+---------------------------+--------------------------------------+---------------+-------------+--------------+| CHANNEL_NAME | MEMBER_ID | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE |+---------------------------+--------------------------------------+---------------+-------------+--------------+| group_replication_applier | 2a22f682-c378-11e6-bb00-0277185a730c | service-test2 | 5717 | ONLINE || group_replication_applier | 2bc442e4-c2b9-11e6-8c5b-02b39697b809 | service-test1 | 5717 | ONLINE || group_replication_applier | 3010a1a8-c378-11e6-b610-02870604bd20 | service-test3 | 5717 | ONLINE |+---------------------------+--------------------------------------+---------------+-------------+--------------+ 写入数据测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950mysql&gt; insert into t1 values(3,'Test');Query OK, 1 row affected (0.01 sec)mysql&gt; select * from t1;+----+---------+| c1 | c2 |+----+---------+| 1 | Luis || 2 | Guosong || 3 | Test |+----+---------+3 rows in set (0.00 sec)mysql&gt; show binlog events in 'mysql-bin.000004';+------------------+------+----------------+-----------+-------------+-------------------------------------------------------------------------+| Log_name | Pos | Event_type | Server_id | End_log_pos | Info |+------------------+------+----------------+-----------+-------------+-------------------------------------------------------------------------+| mysql-bin.000004 | 4 | Format_desc | 19795717 | 123 | Server ver: 5.7.17-log, Binlog ver: 4 || mysql-bin.000004 | 123 | Previous_gtids | 19795717 | 150 | || mysql-bin.000004 | 150 | Gtid | 19795717 | 211 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1' || mysql-bin.000004 | 211 | Query | 19795717 | 270 | BEGIN || mysql-bin.000004 | 270 | View_change | 19795717 | 409 | view_id=14823763458501488:1 || mysql-bin.000004 | 409 | Query | 19795717 | 474 | COMMIT || mysql-bin.000004 | 474 | Gtid | 19795717 | 535 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2' || mysql-bin.000004 | 535 | Query | 19795717 | 625 | create database test || mysql-bin.000004 | 625 | Gtid | 19795717 | 686 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3' || mysql-bin.000004 | 686 | Query | 19795717 | 809 | use `test`; create table t1(c1 int primary key, c2 text not null) || mysql-bin.000004 | 809 | Gtid | 19795717 | 870 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4' || mysql-bin.000004 | 870 | Query | 19795717 | 938 | BEGIN || mysql-bin.000004 | 938 | Table_map | 19795717 | 981 | table_id: 219 (test.t1) || mysql-bin.000004 | 981 | Write_rows | 19795717 | 1023 | table_id: 219 flags: STMT_END_F || mysql-bin.000004 | 1023 | Xid | 19795717 | 1050 | COMMIT /* xid=31 */ || mysql-bin.000004 | 1050 | Gtid | 19795717 | 1111 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:5' || mysql-bin.000004 | 1111 | Query | 19795717 | 1170 | BEGIN || mysql-bin.000004 | 1170 | View_change | 19795717 | 1349 | view_id=14823763458501488:2 || mysql-bin.000004 | 1349 | Query | 19795717 | 1414 | COMMIT || mysql-bin.000004 | 1414 | Gtid | 19795717 | 1475 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:6' || mysql-bin.000004 | 1475 | Query | 19795717 | 1534 | BEGIN || mysql-bin.000004 | 1534 | View_change | 19795717 | 1713 | view_id=14823763458501488:3 || mysql-bin.000004 | 1713 | Query | 19795717 | 1778 | COMMIT || mysql-bin.000004 | 1778 | Gtid | 19815717 | 1839 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:7' || mysql-bin.000004 | 1839 | Query | 19815717 | 1898 | BEGIN || mysql-bin.000004 | 1898 | Table_map | 19815717 | 1941 | table_id: 219 (test.t1) || mysql-bin.000004 | 1941 | Write_rows | 19815717 | 1986 | table_id: 219 flags: STMT_END_F || mysql-bin.000004 | 1986 | Xid | 19815717 | 2013 | COMMIT /* xid=75 */ || mysql-bin.000004 | 2013 | Gtid | 19795717 | 2074 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1000006' || mysql-bin.000004 | 2074 | Query | 19795717 | 2147 | BEGIN || mysql-bin.000004 | 2147 | Table_map | 19795717 | 2190 | table_id: 219 (test.t1) || mysql-bin.000004 | 2190 | Write_rows | 19795717 | 2232 | table_id: 219 flags: STMT_END_F || mysql-bin.000004 | 2232 | Xid | 19795717 | 2259 | COMMIT /* xid=93 */ |+------------------+------+----------------+-----------+-------------+-------------------------------------------------------------------------+ 2.2 数据冲突测试 从这里可以在两个不同的member对同一行数据进行update操作时候，没有任何限制，结果到时节点数据存在不一致的问题。具体配置错误的地方还在找，进一步研究。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Inception源码修改阅读]]></title>
    <url>%2F2016-11-03-inceptionyuan-ma-xiu-gai-yue-du%2F</url>
    <content type="text"><![CDATA[Inception介绍去哪儿开源的Inception是一个集审核、执行、备份以及生成回滚语句集一身的MySQL自动化运维工具，其是基于MySQL5.6.10版本进行修改的。本博文主要研究其修改以及增加的相关代码。 增加Inception关键字相关命令修改lex.h增加INCEPTION关键字123456789static SYMBOL symbols[] = &#123;... &#123; "INCEPTION", SYM(INCEPTION_SYM)&#125;, &#123; "INCEPTION_MAGIC_START", SYM(INCEPTION_START_SYM)&#125;, &#123; "INCEPTION_MAGIC_COMMIT", SYM(INCEPTION_COMMIT_SYM)&#125;,... &#123; "OSC_PERCENT", SYM(OSC_PERCENT_SYM)&#125;, &#123; "OSC", SYM(OSC_SYM)&#125;,&#125; INCEPTION INCEPTION 表示以inception开头相关的命令 INCEPTION_MAGIC_START，类似begin INCEPTION_MAGIC_COMMIT，类似commit 以下是相关的SQL举例：1234567inception_magic_start;use &lt;database name&gt;;&lt;any SQL statement&gt;inception_magic_commit;inception show tables;inception show variables like "%read_only%"; OSCInception集中OSC OSC_PERCENT，查询osc进度相关 OSC 执行和osc相关的操作 12inception get osc_percent &apos;当前执行的SQL语句以及一些基本信息生成的SHA1哈希值&apos;inception get osc processlist; 在sql_lex.h中增加Inception相关12345678/*引入symbol头文件*/#include &quot;lex_symbol.h&quot;/*增加Inception命令类型*/uint inception_cmd_type;/*增加新函数*/SYMBOL *get_hash_symbol(const char *s, unsigned int len,bool function); 修改sql_cmd.h增加新的SQL_COMMAND123456enum enum_sql_command &#123;...SQLCOM_INCEPTION_START, SQLCOM_INCEPTION_COMMIT,SQLCOM_INCEPTION,...&#125; 修改sql_yacc.yy添加相关tokensql_yacc.yy中主要修改部分如下: 添加inception相关token 注释掉和replication相关、spatial index相关 注释掉prepare预编译相关 增加inception相关语法逻辑 添加token123456789101112131415161718192021%token INCEPTION_START_SYM /* SQL-2003-R */%token INCEPTION_COMMIT_SYM /* SQL-2003-R */%token INCEPTION_SYM...%token OSC_PERCENT_SYM%token OSC_SYM%type &lt;lex_str&gt; ... /* 增加opt_variables_name */ opt_constraint constraint opt_ident opt_variables_name%type &lt;item&gt; ... update_set_expr_or_default update_set_expr%type &lt;NONE&gt; ...inception_magic_start inception_magic_commit begin commit rollback savepoint release inception... 解析INCEPTION_相关命令Inception相关命令SQL举例1234567inception_magic_startinception_magic_commitinception get variables;inception get variables 'variable_name';inception set [session] variables_name=value;inception get osc_percent '当前执行的SQL语句以及一些基本信息生成的SHA1哈希值';inception get processlist; Inception相关SQL逻辑 inception_magic_start 12345verb_clause: statement | begin | inception_magic_start ; inception_magic_commit 和inception 1234567891011121314/* Verb clauses, except begin */statement: alter | analyze | binlog_base64_event | call | change | check | checksum | commit | inception_magic_commit ... | inception ; opt_variables_name Inception参数相关完成修改无需用户名和密码登陆的认证 修改文件sql/sql_acl.cc:acl_authenticate 源码文件变动比较sql目录下各个文件存在如下129个文件有修改变动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129binlog.ccCMakeLists.txtderror.ccderror.hevent_data_objects.ccevent_db_repository.ccevents.ccfield.ccfield.hfilesort.ccgen_lex_hash.cchandler.cchostname.ccitem.ccitem_cmpfunc.ccitem_create.ccitem_func.ccitem.hitem_strfunc.ccitem_strfunc.hitem_subselect.ccitem_subselect.hitem_sum.cclex.hlock.cclog.cclog_event.cclog_event.hlog_event_old.ccmf_iocache.ccmysqld.ccmysqld.hnet_serv.ccopt_range.ccopt_range.hopt_trace2server.ccopt_trace.hpartition_info.ccprotocol.ccrpl_gtid_execution.ccrpl_gtid_mutex_cond_array.ccrpl_gtid_state.ccrpl_info_factory.ccrpl_info_factory.hrpl_injector.ccrpl_master.ccrpl_mi.ccrpl_mi.hrpl_rli.ccrpl_rli.hrpl_rli_pdb.ccrpl_slave.ccrpl_slave.hrpl_utility.ccrpl_utility.hset_var.ccset_var.hsignal_handler.ccsp.ccsp_head.ccsp_instr.ccsp_rcontext.ccsql_acl.ccsql_acl.hsql_admin.ccsql_alter.ccsql_alter.hsql_analyse.ccsql_audit.hsql_base.ccsql_base.hsql_builtin.cc.insql_cache.ccsql_class.ccsql_class.hsql_cmd.hsql_connect.ccsql_const.hsql_cursor.ccsql_db.ccsql_delete.ccsql_derived.ccsql_do.ccsql_error.hsql_executor.ccsql_handler.ccsql_help.ccsql_insert.ccsql_lex.ccsql_lex.hsql_load.ccsql_locale.ccsql_parse.ccsql_parse.hsql_partition_admin.ccsql_partition.ccsql_planner.ccsql_plugin.ccsql_prepare.ccsql_profile.ccsql_reload.ccsql_rename.ccsql_resolver.ccsql_rewrite.ccsql_select.ccsql_select.hsql_servers.hsql_show.ccsql_show.hsql_string.hsql_table.ccsql_tmp_table.ccsql_tmp_table.hsql_trigger.ccsql_truncate.ccsql_union.ccsql_update.ccsql_view.ccsql_yacc.ccsql_yacc.hsql_yacc.yysys_vars.ccsys_vars.htable_cache.cctable.cctable.htransaction.ccunireg.ccunireg.h]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql添加新的操作命令]]></title>
    <url>%2F2016-10-26-mysqltian-jia-xin-de-cao-zuo-ming-ling%2F</url>
    <content type="text"><![CDATA[添加新的SQL命令（以SHOW DISK_USAGE为例）修改lex.h添加相关Token12345678910static SYMBOL symbols[] = &#123;...&#123; "DISK", SYM(DISK_SYM)&#125;,/*BEGIN GUOSONG MODIFICATION*//* Reason for Modification: *//* Tokens for the SHOW DISK_USAGE command*/&#123;"DISK_USAGE", SYM(DISK_USAGE_SYM)&#125;,/*END GUOSONG MODIFICATION*/&#123; "DISTINCT", SYM(DISTINCT)&#125;,... 修改sql_lex.h添加相关新命令123456789enum enum_sql_command &#123;...SQLCOM_SHOW_TRIGGERS,/*BEGIN GUOSONG MODIFICATION: *//*Reason for this modification: *//*Add SQLCOM_SHOW_DISK_USAGE reference*/SQLCOM_SHOW_DISK_USAGE,/*END GUOSONG MODIFICATION*/... 在MySQL5.6.27版本修改sql_cmd.h文件 12345678enum enum_sql_command &#123; .... SQLCOM_SHOW_TRIGGERS, /*BEGIN GUOSONG MODIFICATION: */ /*Reason for this modification: */ /*Add SQLCOM_SHOW_DISK_USAGE reference*/ SQLCOM_SHOW_DISK_USAGE, /*END GUOSONG MODIFICATION*/ 修改sql_yacc.yy添加相关token添加token 1234567%token DISK_SYM/*BEGIN GUOSONG MODIFICATION*//*Reasion for this modification:/*/*Add DISK_USAGE_SYM */%token DISK_USAGE_SYM/*END GUOSONG MODIFICATION*/%token DISTINCT /* SQL-2003-R */ 解析SHOW DISK_USAGE命令 12345678910111213141516171819202122show: SHOW &#123; LEX *lex=Lex; lex-&gt;wild=0; lex-&gt;lock_option= TL_READ; mysql_init_select(lex); lex-&gt;current_select-&gt;parsing_place= SELECT_LIST; bzero((char*) &amp;lex-&gt;create_info,sizeof(lex-&gt;create_info)); &#125;...show_param: /*BEGIN GUOSONG MODIFICATION*/ /*Reasion for this modification:*/ /*Add DISK_USAGE_SYM */ ¦ ¦ DISK_USAGE_SYM &#123; LEX *lex = Lex; lex-&gt;sql_command = SQLCOM_SHOW_DISK_USAGE; &#125; ¦ | DATABASES wild_and_where /*END GUOSONG MODIFICATION*/ 注意是在show databases 前面添加，故在DATABASES前面需要添加|这个竖线 添加SHOW DISK_USAGE命令的case在sql/sql_parser.cc文件中ysql_execute_command函数中添加123456789101112case SQLCOM_SHOW_AUTHORS:res= mysqld_show_authors(thd);break;/*BEGIN GUOSONG MODIFICATION*//*Reason for this modification*//*Add SQLCOM_SHOW_DISK_USAGE case statement*/case SQLCOM_SHOW_DISK_USAGE:&#123; res = mysqld_show_disk_usage(thd); break;&#125;/*END GUOSONG MODIFICATION*/ 添加函数声明，目前修改sql_show.h文件添加 12345/*BEGIN GUOSONG MODIFICATION*//*Reason for Modification*//*Declared mysqld_show_disk_usage function*/bool mysqld_show_disk_usage(THD *thd);/*END GUOSONG MODIFICATION*/ 在sql_show.cc中添加mysqld_show_disk_usage1234567891011121314151617181920212223242526/*BEGIN GUOSONG MODIFICATION*//*Reason for Modification*//*Add show disk uage method*//*****************************************************************************List all database disk usage***************************************************************************/bool mysqld_show_disk_usage(THD *thd)&#123; List&lt;Item&gt; field_list; Protocol *protocol = thd-&gt;protocol; DBUG_ENTER("mysqld_show_disk_usage"); field_list.push_back(new Item_empty_string("Database",50)); field_list.push_back(new Item_empty_string("Size_in_bytes", 30)); if(protocol-&gt;send_fields(&amp;field_list, Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF)) DBUG_RETURN(TRUE); /*sending test data*/ protocol-&gt;prepare_for_resend(); protocol-&gt;store("test_row", system_charset_info); protocol-&gt;store("1024", system_charset_info); if(protocol-&gt;write()) DBUG_RETURN(TRUE); my_eof(thd); DBUG_RETURN(FALSE);&#125;/*END GUSONG MODIFICATION*/ 在MySQL5.6.27中有些不同: 1234567891011121314151617181920212223242526/*BEGIN GUOSONG MODIFICATION*//*Reason for Modification*//*Add show disk uage method*//*****************************************************************************List all database disk usage***************************************************************************/bool mysqld_show_disk_usage(THD *thd)&#123; List&lt;Item&gt; field_list; Protocol *protocol = thd-&gt;protocol; DBUG_ENTER("mysqld_show_disk_usage"); field_list.push_back(new Item_empty_string("Database",50)); field_list.push_back(new Item_empty_string("Size_in_bytes", 30)); if(protocol-&gt;send_result_set_metadata(&amp;field_list, Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF)) DBUG_RETURN(TRUE); /*sending test data*/ protocol-&gt;prepare_for_resend(); protocol-&gt;store("test_row", strlen("test_row"),system_charset_info); protocol-&gt;store("1024", strlen("1024"), system_charset_info); if(protocol-&gt;write()) DBUG_RETURN(TRUE); my_eof(thd); DBUG_RETURN(FALSE);&#125;/*END GUSONG MODIFICATION*/ 通过bison以及gen_lex_hash生成相关语法123bison -y -p MYSQL -d sql_yacc.yy[guosong@dev-00 11:18:52 sql]$ll y.tab.y.tab.c y.tab.h 使用y.tab.c和y.tab.h替换sql_yacc.cc和sql_yacc.h 12mv y.tab.c sql_yacc.ccmv y.tab.h sql_yacc.h 通过gen_lex_hash命令生成新的lex_hash.h文件 12 在源码的sql目录下./gen_lex_hash &gt; lex_hash.h make install遇到错误12../include/my_global.h:482:53: error: size of array ‘compile_time_assert’ is negative__attribute__ ((unused)); 修改mysqld.cc文件 123456/*BEGIN GUOSONG MODIFICATION*//*Reason for Modification*//*Solve make error*/compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==¦ ¦ ¦ ¦ ¦SQLCOM_END + 8-1);/*END GUOSONG MODIFICATION*/ 测试12345678910111213141516171819202122232425262728[guosong@dev-00 18:40:48 mysql5627]$mysql5627Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.6.27-debug-log Source distributionCopyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; select version();+------------------+| version() |+------------------+| 5.6.27-debug-log |+------------------+1 row in set (0.00 sec)mysql&gt; show disk_usage;+----------+---------------+| Database | Size_in_bytes |+----------+---------------+| test_row | 1024 |+----------+---------------+1 row in set (0.00 sec) 增加统计数据库文件大小的真实统计代码真实统计代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/*BEGIN GUOSONG MODIFICATION*//*Reason for Modification*//*Add show disk uage method*//*****************************************************************************List all database disk usage***************************************************************************/bool mysqld_show_disk_usage(THD *thd)&#123; List&lt;Item&gt; field_list; List&lt;LEX_STRING&gt; dbs; LEX_STRING *db_name; char *path; MY_DIR *dirp; FILEINFO *file; longlong fsizes = 0; longlong total_sizes = 0; longlong lsizes = 0; Protocol *protocol = thd-&gt;protocol; DBUG_ENTER("mysqld_show_disk_usage"); field_list.push_back(new Item_empty_string("Database",50)); field_list.push_back(new Item_return_int("Size_in_bytes", 7, MYSQL_TYPE_LONGLONG)); if(protocol-&gt;send_result_set_metadata(&amp;field_list, Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF)) DBUG_RETURN(TRUE); /* get database directories*/ find_files_result res = find_files(thd, &amp;dbs, NULL,mysql_data_home, NULL, 1, NULL); if (res != FIND_FILES_OK) DBUG_RETURN(1); List_iterator_fast&lt;LEX_STRING&gt; it_dbs(dbs); path = (char*)my_malloc(PATH_MAX, MYF(MY_ZEROFILL)); dirp = my_dir(mysql_data_home, MYF(MY_WANT_STAT)); fsizes = 0; for(int i = 0; i&lt; (int)dirp-&gt;number_off_files;i++) &#123; file = dirp-&gt;dir_entry + i; if (strncasecmp(file-&gt;name, "ibdata", 6) == 0) fsizes = fsizes + file-&gt;mystat-&gt;st_size; else if (strncasecmp(file-&gt;name, "ib", 2) == 0) lsizes = lsizes + file-&gt;mystat-&gt;st_size; &#125; total_sizes += fsizes; total_sizes += lsizes; /* send Innodb data to client*/ protocol-&gt;prepare_for_resend(); protocol-&gt;store("InnoDB TableSpace", system_charset_info); protocol-&gt;store((longlong)fsizes); if (protocol-&gt;write()) DBUG_RETURN(TRUE); protocol-&gt;prepare_for_resend(); protocol-&gt;store("InnoDB logs", system_charset_info); protocol-&gt;store((longlong)lsizes); if (protocol-&gt;write()) DBUG_RETURN(TRUE); /*now send database name and sizes of the databases*/ while((db_name = it_dbs++)) &#123; fsizes = 0; strcpy(path, mysql_data_home); strcat(path, "/"); strcat(path, db_name-&gt;str); dirp = my_dir(path, MYF(MY_WANT_STAT)); for(int i=0; i&lt;(int)dirp-&gt;number_off_files;i++) &#123; file = dirp-&gt;dir_entry + i; fsizes = fsizes + file-&gt;mystat-&gt;st_size; &#125; protocol-&gt;prepare_for_resend(); protocol-&gt;store(db_name-&gt;str, system_charset_info); protocol-&gt;store((longlong)fsizes); if (protocol-&gt;write()) DBUG_RETURN(TRUE); total_sizes += fsizes; &#125; protocol-&gt;prepare_for_resend(); protocol-&gt;store("TotalSize", system_charset_info); protocol-&gt;store((longlong)total_sizes); if (protocol-&gt;write()) DBUG_RETURN(TRUE); my_eof(thd); /*free memory*/ my_free(path); my_dirend(dirp); DBUG_RETURN(FALSE);&#125;/*END GUSONG MODIFICATION*/ 测试1234567891011121314151617181920212223242526[guosong@dev-00 22:39:55 mysql5627]$mysql5627Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.6.27-debug-log Source distributionCopyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; show disk_usage;+--------------------+---------------+| Database | Size_in_bytes |+--------------------+---------------+| InnoDB TableSpace | 104857600 || InnoDB logs | 3145728000 || mysql | 1647392 || orchestrator | 6047749 || performance_schema | 493639 || test | 8257 || TotalSize | 3258782637 |+--------------------+---------------+7 rows in set (0.01 sec) 其他版本测试 添加自定义命令 show disk_usage 5.6.27版本 添加自定义命令 show disk_usage 5.1.45版本 添加新的引擎]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[innodb buffer dump and load]]></title>
    <url>%2F2016-08-25-innodb-buffer-dump-and-load%2F</url>
    <content type="text"><![CDATA[预热Innodb Buffer Pool针对线上运行的MySQL Server，如果重启不设置预热的话直接提供服务，会产生很多Disk IO导致性能严重下降。 在MySQL5.6 版本之后引入Buffer Pool的dump以及load功能。 Dump扫描Buffer Pool将相关table_id以及page_id写入文件中(默认在data目录下ib_buffer_pool文件中)。 1set global innodb_buffer_pool_dump_at_shutdown = 1; ib_buffer_pool内容如下: 1234567891011[root@service-test1 data]# head -n 10 ib_buffer_pool92,1768292,13163192,6182692,6508092,11175992,11436492,9641092,13163292,9449592,131633 Load动态实现load 1set global innodb_buffer_pool_load_now=1; 122016-08-25 16:23:06 7fdd367fc700 InnoDB: Loading buffer pool(s) from .//ib_buffer_pool2016-08-25 16:23:36 7fdd367fc700 InnoDB: Buffer pool(s) load completed at 160825 16:23:36 123456789101112131415mysql&gt; show global status like '%load%';+--------------------------------+--------------------------+| Variable_name | Value |+--------------------------------+--------------------------+| Innodb_buffer_pool_load_status | Loaded 16769/54873 pages |+--------------------------------+--------------------------+mysql&gt; show global status like '%load%';+--------------------------------+--------------------------------------------------+| Variable_name | Value |+--------------------------------+--------------------------------------------------+| Com_load | 0 || Com_preload_keys | 0 || Innodb_buffer_pool_load_status | Buffer pool(s) load completed at 160825 16:23:36 |+--------------------------------+--------------------------------------------------+ Load过程不影响启动，不是一定得load完成之后才响应相关请求。Load中如果发现对应的table_id以及page_id已经在buffer中，将直接跳过。 相关参考 https://blog.marceloaltmann.com/en-warm-up-innodb-buffer-pool-pt-esquentando-o-innodb-buffer-pool/ https://dev.mysql.com/doc/refman/5.6/en/innodb-preload-buffer-pool.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[How to install Yii2]]></title>
    <url>%2F2016-04-18-how-to-install-yii2%2F</url>
    <content type="text"><![CDATA[1. Install From Archived FileEdit file /var/www/basic/config/web.php, set cookieValidationKey 1&apos;cookieValidationKey&apos; =&gt; &apos;chuchujie&apos; 2. Call to undefined function mb_strlen1Fatal error: Call to undefined function mb_strlen() yum install php55-mbstring module. Version is import. 3. The directory is not writable by the Web process1234567ec2-user 13898 0.0 0.1 393312 20952 ? S 19:47 0:00 /usr/sbin/httpdec2-user 13900 0.0 0.1 395592 22116 ? S 19:47 0:00 /usr/sbin/httpdec2-user 13901 0.0 0.1 393048 20048 ? S 19:47 0:00 /usr/sbin/httpdec2-user 13975 0.0 0.1 392024 19528 ? S 19:47 0:00 /usr/sbin/httpdec2-user 14493 0.0 0.1 396096 23296 ? S 19:48 0:00 /usr/sbin/httpdec2-user 14494 0.0 0.1 392024 19396 ? S 19:48 0:00 /usr/sbin/httpdec2-user 14495 0.0 0.0 389784 14824 ? S 19:48 0:00 /usr/sbin/httpd 1chown -R ec2-user.ec2-user /var/www/basic http://www.g-loaded.eu/2008/12/09/making-a-directory-writable-by-the-webserver/ 4. Class ‘PDO’ not foundcould not find driver Caused by: PDOException 12yum install php55-pdo.x86_64 -yyum install php-ZendFramework-Db-Adapter-Pdo-Mysql.noarch -y 5. Yii2 Gii Forbidden code 403 You are not allowed to access this pageEdit config/web.php 1234$config['modules']['gii'] = ['class' =&gt; 'yii\gii\Module','allowedIPs' =&gt; ['127.0.0.1', '::1', '10.3xxxx'],]; Due to company vpn , choose the ip by Apache access log. http://jeepxiaozi.github.io/yii2xue-xi-bi-ji-xi-lie-6-generating-code-with-giishi-yong-giisheng-cheng-dai-ma.html 6. Yii2 Programing Stylehttps://github.com/yii2-chinesization/yii2-zh-cn/blob/master/internals-zh-CN/core-code-style.md 7. Referencehttps://github.com/forecho/awesome-yii2 8. Tree Managerhttp://demos.krajee.com/tree-manager#comment-2288987974]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis info memory研究]]></title>
    <url>%2F2016-04-15-redis-info-memoryyan-jiu%2F</url>
    <content type="text"><![CDATA[info memory输出信息12345678910info memory Memoryused_memory:5198608840used_memory_human:4.84Gused_memory_rss:11156660224used_memory_peak:9816601560used_memory_peak_human:9.14Gused_memory_lua:36864mem_fragmentation_ratio:2.15mem_allocator:libc http://www.cnblogs.com/mushroom/p/4738170.html 对应的代码： 123456789101112131415161718192021222324252627282930313233343536/* Memory */if (allsections || defsections || !strcasecmp(section,"memory")) &#123;char hmem[64];char peak_hmem[64];size_t zmalloc_used = zmalloc_used_memory();/* Peak memory is updated from time to time by serverCron() so it* may happen that the instantaneous value is slightly bigger than* the peak value. This may confuse users, so we update the peak* if found smaller than the current memory usage. */if (zmalloc_used &gt; server.stat_peak_memory)server.stat_peak_memory = zmalloc_used;bytesToHuman(hmem,zmalloc_used);bytesToHuman(peak_hmem,server.stat_peak_memory);if (sections++) info = sdscat(info,"\r\n");info = sdscatprintf(info,"# Memory\r\n""used_memory:%zu\r\n""used_memory_human:%s\r\n""used_memory_rss:%zu\r\n""used_memory_peak:%zu\r\n""used_memory_peak_human:%s\r\n""used_memory_lua:%lld\r\n""mem_fragmentation_ratio:%.2f\r\n""mem_allocator:%s\r\n",zmalloc_used,hmem,server.resident_set_size,server.stat_peak_memory,peak_hmem,((long long)lua_gc(server.lua,LUA_GCCOUNT,0))*1024LL,zmalloc_get_fragmentation_ratio(server.resident_set_size),ZMALLOC_LIB);&#125; used_memory]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL性能排查案例1]]></title>
    <url>%2F2016-04-11-mysqlxing-neng-pai-cha-an-li-1%2F</url>
    <content type="text"><![CDATA[1、简单查询问题排查12345678910111213 Scores: V/M = 0.14 Attribute pct total min max avg 95% stddev median ============ === ======= ======= ======= ======= ======= ======= ======= Count 2 5 Exec time 4 27s 4s 6s 5s 6s 878ms 6s Lock time 4 246us 43us 64us 49us 63us 7us 44us Rows sent 0 0 0 0 0 0 0 0 Rows examine 0 5 1 1 1 1 0 1 Query size 3 583 116 117 116.60 112.70 0 112.70UPDATE `cc_product_skus` SET `stock`='578' WHERE ( `id` = '20081272' ) AND ( `product_id` = '100122171387' ) LIMIT 1\G Converted for EXPLAIN EXPLAIN /*!50100 PARTITIONS*/select `stock`='578' from `cc_product_skus` where ( `id` = '20081272' ) AND ( `product_id` = '100122171387' ) LIMIT 1 \G 通过pt-query-digest的可以看出上面简单的update语句耗时会在4s-6s之间。 问题1-Lock_time是否包括innodb wait lock呢？http://lists.mysql.com/commits/115766MySQL 5.5.6版本之后已经改进这个问题。 目前线上使用MySQL 5.6.19版本，且通过下面的实验进行验证： 通过2个session，1个session持有锁，另外一个session等待这个锁，模拟innodb wait lock，对应的慢查询如下： 2、在慢查询里面看到Commit提交慢12345678910111213 Time: 160411 2:02:51 User@Host: shop2[shop2] @ [10.30.11.253] Id: 5888814786 Query_time: 7.139016 Lock_time: 0.000000 Rows_sent: 0 Rows_examined: 0SET timestamp=1460340171;COMMIT; User@Host: shop2[shop2] @ [10.30.10.50] Id: 5888814819 Query_time: 7.052946 Lock_time: 0.000000 Rows_sent: 0 Rows_examined: 0SET timestamp=1460340171;COMMIT; User@Host: shop2[shop2] @ [10.30.9.251] Id: 5888814800 Query_time: 7.089021 Lock_time: 0.000000 Rows_sent: 0 Rows_examined: 0SET timestamp=1460340171;COMMIT; 根据thread_id查看整个连接做了哪些操作： 123456789101112160411 2:02:44 5888814800 Connect shop2@10.xx.xxx.xxx on shop160411 2:02:44 5888814800 Query SET NAMES 'utf8'160411 2:02:44 5888814800 Query SET sql_mode=''160411 2:02:44 5888814800 Query SELECT * FROM `cc_order_user` WHERE ( `order_sn` = 'xxx' ) LIMIT 1160411 2:02:44 5888814800 Query SELECT * FROM `cc_order_products_user` WHERE ( `order_id` = 'xxx' )160411 2:02:44 5888814800 Query SELECT * FROM `cc_refund_order` WHERE ( `order_sn` = 'xxx' ) AND ( `status` = 0 ) ORDER BY id desc LIMIT 0,10160411 2:02:44 5888814800 Query SET AUTOCOMMIT=0160411 2:02:44 5888814800 Query UPDATE `cc_order_user` SET `shipping_sn`='1xxx',`shipping_company_id`='yxxx',`status_delivery`=2,`delivery_time`=1460340164 WHERE ( `order_sn` = 'xxxx' )160411 2:02:44 5888814800 Query COMMIT160411 2:02:51 5888814800 Query SET AUTOCOMMIT=1160411 2:02:51 5888814800 Quit 可以看到COMMIT就耗时7s 2.1 COMMIT的时候做了哪些操作呢？undolog日志 redlog日志 1234567m3306:shangcheng-m1 &gt;show variables like '%flush_log%';+--------------------------------+-------+| Variable_name | Value |+--------------------------------+-------+| innodb_flush_log_at_timeout | 1 || innodb_flush_log_at_trx_commit | 2 |+--------------------------------+-------+ 关于innodb_flush_log_at_trx_commit参数的含义如下图解释： 2.2 查看redo log更新的情况innodb_log_file_size参数大小 1234567891011121314m3306:shangcheng-m1 &gt;show variables like '%innodb_log_file%';+---------------------------+-----------+| Variable_name | Value |+---------------------------+-----------+| innodb_log_file_size | 134217728 || innodb_log_files_in_group | 2 |+---------------------------+-----------+m3306:shangcheng-m1 &gt;select 134217728/1024/1024;+---------------------+| 134217728/1024/1024 |+---------------------+| 128.00000000 |+---------------------+ 可以看出innodb_log_file_size只有128M，这和以往的经验差别很大（一般设置为&gt;1G）。 根据performance的给出计算参考： https://www.percona.com/blog/2008/11/21/how-to-calculate-a-good-innodb-log-file-size/ https://www.percona.com/blog/2006/07/03/choosing-proper-innodb_log_file_size/ 1234567 最大值MAX_SIZE=18.90M 业务高峰开启的时候2016-04-11 02:00:01 10.202016-04-11 02:01:01 18.902016-04-11 02:02:01 12.272016-04-11 02:03:01 13.22 按照上述参考计算值为18.9*60/2=567G,按照128M round，至少需要设置640M。 MySQL测试推荐 http://dimitrik.free.fr/blog/archives/2015/10/mysql-performance-yes-we-can-do-more-than-16m-qps-sql-on-mysql-57-ga.html Handler情况]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql故障总结]]></title>
    <url>%2F2016-03-16-mysqlgu-zhang-zong-jie%2F</url>
    <content type="text"><![CDATA[一、MetaTable Lock1、问题现象: 2、问题追查: 1234567891011121314151617181920212223242526select * from INNODB_TRX\G*************************** 1. row ***************************trx_id: 119520700800trx_state: RUNNINGtrx_started: 2016-03-16 04:45:25trx_requested_lock_id: NULLtrx_wait_started: NULLtrx_weight: 0trx_mysql_thread_id: 17427746trx_query: NULLtrx_operation_state: NULLtrx_tables_in_use: 0trx_tables_locked: 0trx_lock_structs: 0trx_lock_memory_bytes: 360trx_rows_locked: 0trx_rows_modified: 0trx_concurrency_tickets: 0trx_isolation_level: REPEATABLE READtrx_unique_checks: 1trx_foreign_key_checks: 1trx_last_foreign_key_error: NULLtrx_adaptive_hash_latched: 0trx_adaptive_hash_timeout: 10000trx_is_read_only: 0trx_autocommit_non_locking: 0 3、上面的thread对应的查询语句 这个对thread_id对应的用户是搜索的。 1160316 3:47:48 17424544 Connect shop_search@10.30.23.222 on shop 4、Metalock原理:http://dev.mysql.com/doc/refman/5.6/en/metadata-locking.htmlhttp://blog.itpub.net/25704976/viewspace-1379568/ Binlog内操作的记录是基于事务的提交顺序进行的，如果有一个事务未执行完成，而这个时候drop了表，这样在从库的执行顺序就会出现问题。MySQL在5.5.3版本后引入了Metadata lock锁，事务释放后才会释放Metadata lock，这样在事务完成期间，是不能进行DDL操作的。 从官方文档可以看出，对于Session1的SQL语句，不仅限于更新的SQL，对于SELECT语句一样如此，且其对Metalock的锁持有时间一直到事务结束。 5、问题模拟: 手动开启事务然后进行alter table操作: 回滚事务alter table操作成功: 6、改进方案1、开启事务(set autocommit=0)，一定要显示的commit或者rollback，且事务里面不要包括太多的语句。2、对于只是Select的查询，一定不要加事务，Innodb引擎是MVCC模式，加事务不起到任何作用。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis Sentinel]]></title>
    <url>%2F2016-03-11-redis-sentinel%2F</url>
    <content type="text"><![CDATA[1、Redis哨兵搭建测试1.1 Redis主从信息主从信息: 123redis主库:10.30.6.184(service-test2)redis从库1:10.30.6.183(service-test3)redis从库2:10.30.6.217（service-test1） redis部署的目录结构: 123456789101112131415161718├── bin│ ├── redis-benchmark│ ├── redis-check-aof│ ├── redis-check-dump│ ├── redis-cli│ ├── redis-sentinel│ ├── redis-server│ └── redis-trib.rb├── conf│ ├── r3050.conf│ └── sentinel.conf├── data│ ├── appendonly.aof│ └── r3050.rdb├── log│ └── r3050.log└── tmp└── redis3050.pid redis配置文件: 123456789101112131415161718192021222324252627daemonize yespidfile /home/op/redis3050/tmp/redis3050.pidport 3050timeout 172800loglevel noticelogfile /home/op/redis3050/log/r3050.logdatabases 16rdbcompression yesdbfilename r3050.rdbdir /home/op/redis3050/data/slave-serve-stale-data yesappendonly yesappendfilename appendonly.aofappendfsync everysecno-appendfsync-on-rewrite yesauto-aof-rewrite-percentage 0auto-aof-rewrite-min-size 64mbslowlog-log-slower-than 10000slowlog-max-len 1024list-max-ziplist-entries 512list-max-ziplist-value 64set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64activerehashing yesmaxmemory-policy noevictionmaxmemory 5G 1.2 哨兵配置以上三台机器上初始化sentinel配置 1234sentinel monitor mymaster 10.30.6.184 3050 2sentinel down-after-milliseconds mymaster 60000sentinel failover-timeout mymaster 18000sentinel config-epoch mymaster 0 通过下面命令在三台机器上启动哨兵: 1./bin/redis-sentinel ./conf/sentinel.conf &amp; 在主上可以看到收到下面消息，说明各个哨兵联合在一起了: 1222210:X 11 Mar 16:37:22.505 * +sentinel sentinel 10.30.6.183:26379 10.30.6.183 26379 @ mymaster 10.30.6.184 305022210:X 11 Mar 16:37:46.050 * +sentinel sentinel 10.30.6.217:26379 10.30.6.217 26379 @ mymaster 10.30.6.184 3050 这个时候的哨兵配置文件内容变成如下: 12345678910111213sentinel monitor mymaster 10.30.6.184 3050 2sentinel down-after-milliseconds mymaster 60000sentinel failover-timeout mymaster 18000sentinel config-epoch mymaster 0 Generated by CONFIG REWRITEport 26379dir &quot;/home/op/redis3050&quot;sentinel leader-epoch mymaster 0sentinel known-slave mymaster 10.30.6.217 3050sentinel known-slave mymaster 10.30.6.183 3050sentinel known-sentinel mymaster 10.30.6.217 26379 86aefa154fe695f9e0ea56312e01a14c24e79129sentinel known-sentinel mymaster 10.30.6.183 26379 61c53d7c01409da6b5e831d0fa26f49026909809sentinel current-epoch 0 每台均是如此。 2、Sentinel基本操作2.1 Sentinel masters列出所有被见识的主Redis服务实例，以及这些主服务实例的当前状态。 1234567891011121314127.0.0.1:26379&gt; sentinel masters1) 1) &quot;name&quot;2) &quot;mymaster&quot;3) &quot;ip&quot;4) &quot;10.30.6.184&quot;5) &quot;port&quot;6) &quot;3050&quot;7) &quot;runid&quot;8) &quot;680b4c8c7cb4a05fadbe968e03c2c9e3de42e09e&quot;9) &quot;flags&quot;10) &quot;master&quot;......37) &quot;parallel-syncs&quot;38) &quot;1&quot; 2.2 Sentinel Slaves列出给定主服务实例的所有从实例，以及这些从实例的当前状态。 1234567891011121314151617181920212223242526127.0.0.1:26379&gt; sentinel slaves mymaster1) 1) &quot;name&quot;2) &quot;10.30.6.217:3050&quot;3) &quot;ip&quot;4) &quot;10.30.6.217&quot;5) &quot;port&quot;6) &quot;3050&quot;7) &quot;runid&quot;8) &quot;9ae75482b5c770c7c0cf8aa2092eab7e450ec232&quot;9) &quot;flags&quot;10) &quot;slave&quot;......37) &quot;slave-repl-offset&quot;38) &quot;186791&quot;2) 1) &quot;name&quot;2) &quot;10.30.6.183:3050&quot;3) &quot;ip&quot;4) &quot;10.30.6.183&quot;5) &quot;port&quot;6) &quot;3050&quot;7) &quot;runid&quot;8) &quot;390beeec7d4ebfd0d4c0317eed3e97e498f4d9fd&quot;9) &quot;flags&quot;10) &quot;slave&quot;......38) &quot;186791&quot; 2.3 Sentinel get-master-addr-by-name返回给定名字的主实例IP地址和端口号。如果这个主实例正在进行故障转移操作，或者针对这个主实例的故障转移操作已经完成，那么这个命令返回新的主服务器的IP地址和端口号。 123127.0.0.1:26379&gt; sentinel get-master-addr-by-name mymaster1) &quot;10.30.6.184&quot;2) &quot;3050&quot; 2.4 Sentinel failover进行一次主动的failover，即在不询问Sentinel意见的情况下，强制开始一次自动故障迁移。发起故障迁移的Sentinel会向其他Sentinel发送一个新的配置，其他Sentinel会根据这个配置进行相应的更新。 123456789101112131415161718192021222324sentinel failover mymaster22210:X 11 Mar 17:03:59.846 # Executing user requested FAILOVER of &apos;mymaster&apos;22210:X 11 Mar 17:03:59.846 # +new-epoch 122210:X 11 Mar 17:03:59.846 # +try-failover master mymaster 10.30.6.184 3050OK127.0.0.1:26379&gt; 22210:X 11 Mar 17:03:59.890 # +vote-for-leader 8da81bbf7a87e42440046a8978b2fa69adc11fae 122210:X 11 Mar 17:03:59.890 # +elected-leader master mymaster 10.30.6.184 305022210:X 11 Mar 17:03:59.890 # +failover-state-select-slave master mymaster 10.30.6.184 305022210:X 11 Mar 17:03:59.973 # +selected-slave slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:03:59.973 * +failover-state-send-slaveof-noone slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:00.031 * +failover-state-wait-promotion slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:00.901 # +promoted-slave slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:00.901 # +failover-state-reconf-slaves master mymaster 10.30.6.184 305022210:X 11 Mar 17:04:00.981 * +slave-reconf-sent slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:01.947 * +slave-reconf-inprog slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:01.947 * +slave-reconf-done slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:02.024 # +failover-end master mymaster 10.30.6.184 305022210:X 11 Mar 17:04:02.024 # +switch-master mymaster 10.30.6.184 3050 10.30.6.183 305022210:X 11 Mar 17:04:02.024 * +slave slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 305022210:X 11 Mar 17:04:02.024 * +slave slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050127.0.0.1:26379&gt; sentinel get-master-addr-by-name mymaster1) &quot;10.30.6.183&quot;2) &quot;3050&quot; 可以看出来新的主，原来主变成新库的从库: 1234567891011121314151617181920212223242526272811826:M 11 Mar 17:04:00.032 # Connection with slave 10.30.6.183:3050 lost.11826:M 11 Mar 17:04:00.982 # Connection with slave 10.30.6.217:3050 lost.11826:S 11 Mar 17:04:11.079 * SLAVE OF 10.30.6.183:3050 enabled (user request from &apos;id=23 addr=10.30.6.217:35942 fd=9 name=sentinel-86aefa15-cmd age=10 idle=0 flags=x db=0 sub=0psub=0 multi=3 qbuf=0 qbuf-free=32768 obl=36 oll=0 omem=0 events=rw cmd=exec&apos;)11826:S 11 Mar 17:04:11.079 # CONFIG REWRITE executed with success.11826:S 11 Mar 17:04:11.602 * Connecting to MASTER 10.30.6.183:305011826:S 11 Mar 17:04:11.602 * MASTER &lt;-&gt; SLAVE sync started11826:S 11 Mar 17:04:11.602 * Non blocking connect for SYNC fired the event.11826:S 11 Mar 17:04:11.603 * Master replied to PING, replication can continue...11826:S 11 Mar 17:04:11.603 * Partial resynchronization not possible (no cached master)11826:S 11 Mar 17:04:11.605 * Full resync from master: 390beeec7d4ebfd0d4c0317eed3e97e498f4d9fd:35720011826:S 11 Mar 17:04:11.683 * MASTER &lt;-&gt; SLAVE sync: receiving 55 bytes from master11826:S 11 Mar 17:04:11.683 * MASTER &lt;-&gt; SLAVE sync: Flushing old data11826:S 11 Mar 17:04:11.683 * MASTER &lt;-&gt; SLAVE sync: Loading DB in memory11826:S 11 Mar 17:04:11.684 * MASTER &lt;-&gt; SLAVE sync: Finished with success11826:S 11 Mar 17:04:11.684 * Background append only file rewriting started by pid 2719111826:S 11 Mar 17:04:11.712 * AOF rewrite child asks to stop sending diffs.27191:C 11 Mar 17:04:11.712 * Parent agreed to stop sending diffs. Finalizing AOF...27191:C 11 Mar 17:04:11.712 * Concatenating 0.00 MB of AOF diff received from parent.27191:C 11 Mar 17:04:11.712 * SYNC append only file rewrite performed27191:C 11 Mar 17:04:11.712 * AOF rewrite: 0 MB of memory used by copy-on-write11826:S 11 Mar 17:04:11.802 * Background AOF rewrite terminated with success11826:S 11 Mar 17:04:11.802 * Residual parent diff successfully flushed to the rewritten AOF (0.00 MB)11826:S 11 Mar 17:04:11.802 * Background AOF rewrite finished successfully11826:S 11 Mar 17:16:59.969 * SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.11826:M 11 Mar 17:17:16.301 # Connection with master lost.11826:M 11 Mar 17:17:16.301 * Caching the disconnected master state.11826:M 11 Mar 17:17:16.301 * Discarding previously cached master state. 2.5 订阅哨兵的消息通过接受sentinel发送的通知:当执行故障转移操作，或者某个被监视的实例被判断为主观下线或者客观下线时，Sentinel就会发送想要的信息。一个频道能够接收和这个名字相同的事件。通过执行PUBSCRIBE *命令接收所有事件信息。例如: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848510.30.6.184:26379&gt; PSUBSCRIBE *Reading messages... (press Ctrl-C to quit)1) &quot;psubscribe&quot;2) &quot;*&quot;3) (integer) 11) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+new-epoch&quot;4) &quot;2&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+try-failover&quot;4) &quot;master mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+vote-for-leader&quot;4) &quot;8da81bbf7a87e42440046a8978b2fa69adc11fae 2&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+elected-leader&quot;4) &quot;master mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+failover-state-select-slave&quot;4) &quot;master mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+selected-slave&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+failover-state-send-slaveof-noone&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+failover-state-wait-promotion&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;-role-change&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050 new reported role is master&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+promoted-slave&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+failover-state-reconf-slaves&quot;4) &quot;master mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave-reconf-sent&quot;4) &quot;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave-reconf-inprog&quot;4) &quot;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave-reconf-done&quot;4) &quot;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+failover-end&quot;4) &quot;master mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+switch-master&quot;4) &quot;mymaster 10.30.6.183 3050 10.30.6.184 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave&quot;4) &quot;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.184 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave&quot;4) &quot;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;-role-change&quot;4) &quot;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 3050 new reported role is master&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+role-change&quot;4) &quot;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 3050 new reported role is slave&quot; 从订阅的信息可以看出，故障检测、vote、以及修改其他从库同步。 2.6 模拟故障，手动kill主库的进程从订阅的信息中可以看到+sdown的信息。 1234567891011121314151617181920212223242526272829303132333435361) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+sdown&quot;4) &quot;master mymaster 10.30.6.184 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+new-epoch&quot;4) &quot;3&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+vote-for-leader&quot;4) &quot;86aefa154fe695f9e0ea56312e01a14c24e79129 3&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+odown&quot;4) &quot;master mymaster 10.30.6.184 3050 #quorum 3/2&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;-role-change&quot;4) &quot;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 3050 new reported role is master&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+config-update-from&quot;4) &quot;sentinel 10.30.6.217:26379 10.30.6.217 26379 @ mymaster 10.30.6.184 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+switch-master&quot;4) &quot;mymaster 10.30.6.184 3050 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave&quot;4) &quot;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&quot; 当将老主库的实例启动起来之后，自动同步新主库。 SDOWN 主观下线如果服务器在给定的毫秒数之内，没有返回Sentinel发送的PING命令回复或者返回一个错误，那么Sentinel将这个服务器标记为主观下线(SDOWN)。 ODOWN 客观下线只有一个Sentinel将服务器标记为主观下线并不一定会引起服务器的自动故障迁移：只有在足够数量的Sentinel都将一个服务器标记为主观下线之后，服务器才会被标记为客观下线（ODOWN），这时自动故障迁移才会执行。 将服务器标记为客观下线所需的Sentinel数量由对主服务器的配置决定。 1sentinel monitor mymaster 10.30.6.184 3050 2 2.7 Sentinel客户端如果要做到应用程序对Redis的failover透明，客户端需要监控sentinel的平道信息，并自动连接新的主节点。 这里就需要整合sentinel的redis driver。 2.8 故障通知以及配置修改123456789101112sentinel notification-script mymaster /var/redis/notify.sh Call the specified notification script for any sentinel event that is generated in the WARNING level (for instance -sdown, -odown, and so forth). This script should notify the system administrator via email, SMS, or any other messaging system, that there is something wrong with the monitored Redis systems.sentinel client-reconfig-script mymaster /var/redis/reconfig.sh When the master changed because of a failover a script can be called in order to perform application-specific tasks to notify the clients that the configuration has changed and the master is at a different address. 2.9 哨兵切换过程一次故障转移操作步骤: 发下主服务器已经进入客观下线状态 对我们的当前纪元进行自增，并尝试在这个纪元中当选 如果当选失败，那么在设定的故障迁移超时时间的两倍之后，重新尝试当选。如果当选成功，那么执行以下步骤 选出一个从服务器，并将它升级为主服务器 向被选中的从服务器发送SLAVEOF NO ONE命令，让它转变为主服务器 通过发布与订阅功能，将更新后的配置传播给所有其他Sentinel，其他Sentinel队它们自己的配置进行更新 向已下线主服务器的从服务器发送SLAVEOF命令，让它们去复制新的主服务器+当所有从服务器都已经开始复制新的主服务器时，领头的Sentinel终止这次故障迁移操作。 2.10 后续处理什么时候知道从库已经全部同步完成？？ 通过python的订阅信息： 12345678&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;psubscribe&apos;, &apos;channel&apos;: &apos;*&apos;, &apos;data&apos;: 1L&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+new-epoch&apos;, &apos;data&apos;: &apos;9&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+config-update-from&apos;, &apos;data&apos;: &apos;sentinel 10.30.6.217:26379 10.30.6.217 26379 @ mymaster 10.30.6.217 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+switch-master&apos;, &apos;data&apos;: &apos;mymaster 10.30.6.217 3050 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;-role-change&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050 new reported role is master&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+role-change&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050 new reported role is slave&apos;&#125; 123456789101112131415161718192021&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;psubscribe&apos;, &apos;channel&apos;: &apos;*&apos;, &apos;data&apos;: 1L&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+new-epoch&apos;, &apos;data&apos;: &apos;8&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+try-failover&apos;, &apos;data&apos;: &apos;master mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+vote-for-leader&apos;, &apos;data&apos;: &apos;558204b27aada22f980284b9447fa34c30ea2fa0 8&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+elected-leader&apos;, &apos;data&apos;: &apos;master mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+failover-state-select-slave&apos;, &apos;data&apos;: &apos;master mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+selected-slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+failover-state-send-slaveof-noone&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+failover-state-wait-promotion&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;-role-change&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050 new reported role is master&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+promoted-slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+failover-state-reconf-slaves&apos;, &apos;data&apos;: &apos;master mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave-reconf-sent&apos;, &apos;data&apos;: &apos;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave-reconf-inprog&apos;, &apos;data&apos;: &apos;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave-reconf-done&apos;, &apos;data&apos;: &apos;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+failover-end&apos;, &apos;data&apos;: &apos;master mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+switch-master&apos;, &apos;data&apos;: &apos;mymaster 10.30.6.183 3050 10.30.6.217 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.217 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.217 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;-role-change&apos;, &apos;data&apos;: &apos;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.217 3050 new reported role is master&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+role-change&apos;, &apos;data&apos;: &apos;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.217 3050 new reported role is slave&apos;&#125; 2.11 问题1-failover-abort-slave-timeout master mytest 10.30.11.225 8379 http://grokbase.com/t/gg/redis-db/147hea9vmm/redis-sentinel-manual-failover-hangs-on-failover-state-wait-promotionhttps://github.com/antirez/redis/pull/2097 原因在于修改对于config命令进行重命名操作了。 https://github.com/jipperinbham/redis/blob/sentinel-rename-command-3.0/sentinel.conf 添加对rename操作支持(支持config以及slaveof 的patch)一共存在两个分支，支持全局rename以及按照cluster的rename配置https://github.com/antirez/redis/pull/2068/commits/78b5be6833d627de96136cc41896b7d01bceaaed 去哪儿使用的方式是使用patch的方式禁用高危命令，这些高危名利只对哨兵机器开放。 脚本调用超时 12345[19809] 22 Mar 18:16:44.906 # +switch-master myredis 10.30.7.211 25379 10.30.7.212 25379[19809] 22 Mar 18:16:44.906 * +slave slave 10.30.7.213:25379 10.30.7.213 25379 @ myredis 10.30.7.212 25379[19809] 22 Mar 18:16:44.909 * +slave slave 10.30.7.211:25379 10.30.7.211 25379 @ myredis 10.30.7.212 25379[19809] 22 Mar 18:17:26.937 # -script-timeout /home/op/sentinel/reconfig.py 24081[19809] 22 Mar 18:18:57.183 # -script-timeout /home/op/sentinel/reconfig.py 24283 单个从库出现问题之后如何处理？？ 订阅消息的地方如何处理？？ 3、参考资料 http://debugo.com/redis-sentinel/]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GreenPlum安装]]></title>
    <url>%2F2016-03-08-greenpluman-zhuang%2F</url>
    <content type="text"><![CDATA[1、安装遇到的错误信息Failed to insert port=40000 解决方案：http://nessfishl11.blog.51cto.com/1640535/1640972 123主要原因是它是用ed编辑器（很古老的linux编辑器）来操作文件的，需要先安装才行ed安装包http://rpmfind.net/linux/rpm2html/search.php?query=edrpm -ivh ed-1.1-3.3.el6.x86_64.rpm 2、安装参考的资料http://my.oschina.net/Kenyon/blog/487572http://www.cnblogs.com/dap570/p/greenplum_4node_install.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[yum问题处理]]></title>
    <url>%2F2016-03-03-yumwen-ti-chu-li%2F</url>
    <content type="text"><![CDATA[1. yum安装失败处理123http://packages.cn-north-1.amazonaws.com.cn/2015.09/main/201509419456/x86_64/amzn-main/readline-devel-6.2-9.14.amzn1.x86_64.rpm?instance_id=i-91da0fa9&amp;region=cn-north-1: [Errno 14] PYCURL ERROR 22 - &quot;The requested URL returned error: 403 Forbidden&quot;Trying other mirror.http://packages.cn-north-1.amazonaws.com.cn/2015.09/main/201509419456/x86_64/amzn-main/readline-devel-6.2-9.14.amzn1.x86_64.rpm?instance_id=i-91da0fa9&amp;region=cn-north-1: [Errno 14] PYCURL ERROR 22 - &quot;The requested URL returned error: 403 Forbidden&quot; 处理方案: 1yum clean all]]></content>
  </entry>
  <entry>
    <title><![CDATA[DNS 相关]]></title>
    <url>%2F2016-02-16-dns-apixiu-gai%2F</url>
    <content type="text"><![CDATA[1、使用dnspython进行DNS的修改API封装遇到的各种问题使用dnspython模块进行DNS的修改，DNS的server搭建方式是使用Bind。 12345678910111213141516171819202122232425 !/usr/bin/env python -*-coding:utf8 -*-import sysimport dns.updateimport dns.queryimport dns.tsigkeyringimport dns.rdatatypeimport tracebackkeyring = dns.tsigkeyring.from_text(&#123;'testkey' : 'yr8lRAyVpMNOrjd3BsKBlQ=='&#125;)update = dns.update.Update('mysql.internal.test.com', keyring=keyring) update.replace('s4000i', 60, 'A', '10.30.21.111')update.delete('s4000i','A', '10.30.21.111')try:response = dns.query.tcp(update, '10.30.8.227', timeout=10)print responseexcept Exception,e:traceback.print_exc() 注意点： keyname需要和named.conf配置文件中对应。 Update的参数是Domain update.replace第一个参数是主机名 问题 Key名称错误 named-denied.log日志文件 1216-Feb-2016 15:50:38.433 security: error: client 10.30.6.49#42571:request has invalid signature: TSIG keyname: tsig verify failure (BADKEY) 1234567891011121314Traceback (most recent call last):File &quot;dns_test.py&quot;, line 22, in &lt;module&gt;response = dns.query.tcp(update, &apos;10.30.8.227&apos;, timeout=10)File &quot;/usr/local/lib/python2.6/site-packages/dns/query.py&quot;, line 323, in tcpone_rr_per_rrset=one_rr_per_rrset)File &quot;/usr/local/lib/python2.6/site-packages/dns/message.py&quot;, line 790, in from_wirereader.read()File &quot;/usr/local/lib/python2.6/site-packages/dns/message.py&quot;, line 731, in readself._get_section(self.message.additional, adcount)File &quot;/usr/local/lib/python2.6/site-packages/dns/message.py&quot;, line 683, in _get_sectionself.message.first)File &quot;/usr/local/lib/python2.6/site-packages/dns/tsig.py&quot;, line 163, in validateraise PeerBadKeyPeerBadKey 原因在于Keyname指定不对。 udp以及tcp的code状态为REFUSED 123456789id 41185opcode UPDATErcode REFUSEDflags QR RA;ZONEmysql.internal.test.com. IN SOA;PREREQ;UPDATE;ADDITIONAL 原因在于allow-update的设置 12345zone &quot;mysql.internal.test.com&quot; IN &#123;type master;file &quot;mysql.internal.test.com.zone&quot;;allow-update &#123; key testkey; &#125;;&#125;; journal open failed: unexpected errorr 日志文件的错误 12345616-Feb-2016 16:11:04.313 update: info: client 10.30.6.49#26678:updating zone &apos;mysql.internal.test.com/IN&apos;: deleting rrset at &apos;s4000i.mysql.internal.test.com&apos; A16-Feb-2016 16:11:04.313 update: info: client 10.30.6.49#26678:updating zone &apos;mysql.internal.test.com/IN&apos;: adding an RR at &apos;s4000i.mysql.internal.test.com&apos; A16-Feb-2016 16:11:04.313 update: info: client 10.30.6.49#26678:updating zone &apos;mysql.internal.test.com/IN&apos;: error: journal open failed: unexpected error 原因在于权限问题，修改/var/named/chroot/var/named目录权限为named.named。 Demo参考代码https://github.com/pexip/os-dnspython 2、DNS Server搭建参考：http://blog.csdn.net/chen_jp/article/details/7855079https://www.digitalocean.com/community/tutorials/how-to-install-the-bind-dns-server-on-centos-6 主从模式https://www.digitalocean.com/community/tutorials/how-to-configure-bind-as-a-private-network-dns-server-on-centos-7 DNS的server进程 1/usr/sbin/named -u named -4 -t /var/named/chroot DNS本地缓存 我们使用Dnsmasq完成机器本地的缓存，DNS的TTL时间设置为60秒。 http://www.freeoa.net/osuport/servap/dnsmasq-use-intro-refer_2480.html]]></content>
      <categories>
        <category>DNS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GDB多进程调试]]></title>
    <url>%2F2016-02-16-gdbduo-jin-cheng-diao-shi%2F</url>
    <content type="text"><![CDATA[1、如何进行多进程调试1.1 代码123456789101112131415161718192021222324252627282930313233343536371 #include &lt;stdio.h&gt;2 #include &lt;stdlib.h&gt;3 #include &lt;unistd.h&gt;45 int main(void)6 &#123;7 pid_t pid;8 int status;9 int a;10 int b;1112 pid=fork();1314 if (pid &lt; 0)&#123;15 printf("fork error");16 exit(1);17 &#125;else if(pid == 0)&#123;18 //child19 printf("in child\n");20 fflush(stdout);21 sleep(100);22 a = 5;23 b = 10;24 printf("sum=%d\n",a+b);25 fflush(stdout);2627 &#125;else&#123;28 //parent29 printf("in parent\n");30 fflush(stdout);31 if(waitpid(pid, &amp;status,0) &lt; 0)&#123;32 printf("failed to wait");33 exit(1);34 &#125;35 &#125;36 exit(0);37 &#125; 对应的makefile 123456test:test.cgcc -g -c test.cgcc -o test test.oclean:rm -rf testrm -rf *.o 默认设置下，在调试多进程时GDB只会调试主进程，但是GDB(&gt;V7.0)持多进程的分别以及同时调试，换句话说，GDB可以同时调试多个程序。只需要设置follow-fork-mode(默认值：parent)和detach-on-fork（默认值：on）即可。 1234567891011(gdb) help set follow-fork-modeSet debugger response to a program call of fork or vfork.A fork or vfork creates a new process. follow-fork-mode can be:parent - the original process is debugged after a forkchild - the new process is debugged after a forkThe unfollowed process will continue to run.By default, the debugger will follow the parent process.(gdb) help show detach-on-forkShow whether gdb will detach the child of a fork.Tells gdb whether to detach the child of a fork. 12345follow-fork-mode detach-on-fork 说明parent on 只调试主进程（GDB默认）child on 只调试子进程parent off 同时调试两个进程，gdb跟主进程，子进程block在fork位置child off 同时调试两个进程，gdb跟子进程，主进程block在fork位置 1.2 GDB调试123456789101112131415161718192021222324252627(gdb) set detach-on-fork off(gdb) show detach-on-forkWhether gdb will detach the child of a fork is off.(gdb) lwarning: Source file is more recent than executable.3 #include &lt;unistd.h&gt;45 int main(void)6 &#123;7 pid_t pid;8 int status;9 int a;10 int b;1112 pid=fork();(gdb) b 14Breakpoint 1 at 0x400700: file test.c, line 14.(gdb) rStarting program: /home/guosong/opdir/20160216/test[New process 7638]Missing separate debuginfos, use: debuginfo-install glibc-2.17-55.93.amzn1.x86_64Breakpoint 1, main () at test.c:1414 if (pid &lt; 0)&#123;Missing separate debuginfos, use: debuginfo-install glibc-2.17-55.93.amzn1.x86_64(gdb) p pid$1 = 7638 默认是在parent进程中。 切换到子进程 123456789101112131415161718192021(gdb) info inferiorsNum Description Executable2 process 9388 /home/guosong/opdir/20160216/test* 1 process 9356 /home/guosong/opdir/20160216/test(gdb) inferior 2[Switching to inferior 2 [process 9388] (/home/guosong/opdir/20160216/test)][Switching to thread 2 (process 9388)] 0 0x00007ffff7aecc7c in fork () from /lib64/libc.so.6Breakpoint 1, main () at test.c:14warning: Source file is more recent than executable.14 if (pid &lt; 0)&#123;(gdb) n17 &#125;else if(pid == 0)&#123;(gdb) n19 printf(&quot;in child\n&quot;);(gdb) info inferiorsNum Description Executable* 2 process 9388 /home/guosong/opdir/20160216/test1 process 9356 /home/guosong/opdir/20160216/test 再切换回去主进程 12345(gdb) inferior 1[Switching to inferior 1 [process 9356] (/home/guosong/opdir/20160216/test)][Switching to thread 1 (process 9356)] 0 main () at test.c:3333 exit(1); 2、参考资料 http://blog.csdn.net/pbymw8iwm/article/details/7876797]]></content>
      <categories>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO多路复用]]></title>
    <url>%2F2016-01-28-ioduo-lu-fu-yong%2F</url>
    <content type="text"><![CDATA[参考资料Linux IO模式及 select、poll、epoll详解 select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。]]></content>
      <categories>
        <category>Unix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis相关链接]]></title>
    <url>%2F2016-01-15-redisxiang-guan-lian-jie%2F</url>
    <content type="text"><![CDATA[Redis AOF相关 AOF Replay AOF 代码详解]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql大小参数设置]]></title>
    <url>%2F2016-01-05-mysqlda-xiao-can-shu-she-zhi%2F</url>
    <content type="text"><![CDATA[MySQL5.5及其以下在同步的时候对lower_case_table_names有比较严格限制&gt;It is strongly recommended that you always use the same setting for the lower_case_table_names system variable on both master and slave. In particular, when a case-sensitive file system is used, setting this variable to 1 on the slave, but to a different value on the master, can cause two types of problems: Names of databases are not converted to lowercase; in addition, when using row-based replication names of tables are also not converted. Either of these problems can cause replication to fail. This is a known issue, which is fixed in MySQL 5.6. 否则会出现同步错误：&gt;Last_SQL_Errno: 1146Last_SQL_Error: Error executing row event: ‘Table’ 10futu.commentAZXI’ doesn’t exist http://dev.mysql.com/doc/refman/5.5/en/replication-features-variables.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pt-online-schema-change使用方法]]></title>
    <url>%2F2015-12-29-pt-online-schema-changeshi-yong-fang-fa%2F</url>
    <content type="text"><![CDATA[0、前言经常使用pt-osc，需要哪些参数以及如何设置，这里给出个demo。 1、封装的osc脚本12345678910111213141516171819202122232425262728293031323334 !/bin/shfunction run_osc()&#123;MAXSTER_IP="xxx"PORT=xxxDB="sxxx"TB="cc_oxxx"SQL="change order_type order_type tinyint nxxxxMAX_LAG=10USER="xxx"PASS="xxx"CHUNK_SIZE=200osc_file_log="$&#123;DB&#125;_$&#123;TB&#125;_osc.log"./pt-online-schema-change --host=$&#123;MAXSTER_IP&#125; \--port=$&#123;PORT&#125; --user=$&#123;USER&#125; --password=$&#123;PASS&#125; --charset=utf8 \--alter="$&#123;SQL&#125;" --max-lag=$&#123;MAX_LAG&#125; \--recursion-method=dsn=D=test,t=dsns \--no-check-replication-filters \--print --progress=time,1 --statistics \--chunk-size=$&#123;CHUNK_SIZE&#125; --check-interval 5 \--max-load Threads_running=140,Threads_connected=600 \--critical-load Threads_running=140,Threads_connected=800\--set-vars="binlog_format=row" \D=$&#123;DB&#125;,t=$&#123;TB&#125; --execute &gt; $&#123;osc_file_log&#125; 2&gt;&amp;1&#125;run_osc 2、 1366错误遇到1366错误，修改osc源码进行或护额 12345 Completely ignore these error codes.my %ignore_code = ( add by guosong1366 =&gt; 1,)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql全文索引]]></title>
    <url>%2F2015-12-23-mysqlquan-wen-suo-yin%2F</url>
    <content type="text"><![CDATA[0、全文索引说明全文索引使用情况，文件组织格式、使用方式等。 1、全文索引1234567891011FTS_000000000000004b_00000000000000a9_INDEX_1.ibdFTS_000000000000004b_00000000000000a9_INDEX_2.ibdFTS_000000000000004b_00000000000000a9_INDEX_3.ibdFTS_000000000000004b_00000000000000a9_INDEX_4.ibdFTS_000000000000004b_00000000000000a9_INDEX_5.ibdFTS_000000000000004b_00000000000000a9_INDEX_6.ibdFTS_000000000000004b_BEING_DELETED_CACHE.ibdFTS_000000000000004b_BEING_DELETED.ibdFTS_000000000000004b_CONFIG.ibdFTS_000000000000004b_DELETED_CACHE.ibdFTS_000000000000004b_DELETED.ibd 之前没有对全文索引研究过，一开始对这个ibd文件感到奇怪，原来使用到全文索引。 https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql性能测试]]></title>
    <url>%2F2015-12-21-mysqlxing-neng-ce-shi%2F</url>
    <content type="text"><![CDATA[0、前言介绍sysbench相关的使用方法。 1、sysbench生成数据12345sysbench --test=/home/guosong/source/sysbench/sysbench/tests/db/oltp.lua--mysql-host=10.30.21.179 --mysql-port=4000--mysql-user=superdba --mysql-password=nUSP9RAOXXqTrNq50rRw--mysql-table-engine=innodb --oltp-table-size=20000000--max-time=180 --num-threads=30 --max-requests=0 prepare 直接使用otlp报错： 123[guosong@dev-00 db]$ sysbench --test=oltp helpsysbench 0.5: multi-threaded system evaluation benchmarkPANIC: unprotected error in call to Lua API (cannot open oltp: No such file or directory) 原因是这个0.5版本的特性，与0.4版本不同。 122 000 0000 行数据 4.8G2 0000 0000 行数据 48G 2、运行12345678910111213sysbench --num-threads=256 --test=/home/guosong/source/sysbench/sysbench/tests/db/oltp.lua--oltp-dist-type=uniform --oltp-table-name=sbtest_1--max-requests=0 --max-time=720--mysql-host=shangcheng-online-s1-d0.db --mysql-port=3306--mysql-user=dba --mysql-password=xxxxxx--mysql-db=sbtest --mysql-table-engine=INNODB--db-driver=mysql --oltp-point-selects=1--oltp-simple-ranges=0--oltp-sum-ranges=0--oltp-order-ranges=0--oltp-distinct-ranges=0--oltp-skip-trx=on--oltp-read-only=on run 参数 含义 默认值 –oltp-simple-ranges Range size for range queries 100 –oltp-sum-ranges Number of SUM range queries in a single transaction 1 –oltp-order-ranges Number of ORDER range queries in a single transaction 1 –oltp-distinct-ranges Number of DISTINCT range queries in a single 1 transaction 1 –oltp-skip-trx Omit BEGIN/COMMIT statements, i.e. run the same queries as the test would normally run but without off using transactions. off –oltp-read-only Read-only mode. No UPDATE, DELETE or INSERT queries off will be performed. off 3、参考资料 http://wiki.mikejung.biz/Benchmarking]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql_gtid实践]]></title>
    <url>%2F2015-12-09-mysql-gtidshi-jian%2F</url>
    <content type="text"><![CDATA[0、前言介绍GTID限制、在同步中断情况下处理方式、使用xtrabackup的方式等。 1、GTID限制https://dev.mysql.com/doc/refman/5.6/en/replication-gtids-restrictions.html 限制： CREATE TABLE … SELECT statements Temporary tables Preventing execution of unsupported statements. sql_slave_skip_counter 不在支持 GTID mode and mysqldump GTID mode and mysql_upgrade 2、在GTID下pt-slave-restart如何使用？对于操作用户的权限需求必须有SUPER privilege(s)权限。 2.1、手动处理的方式：http://imysql.cn/tag/gtid 12345stop slave;set gtid_next='cc5b5f77-91a6-11e5-834b-02b39697b809:4500';begin;commit;set gtid_next="AUTOMATIC";start slave; 2.2、pt-slave-restart使用方法https://www.percona.com/doc/percona-toolkit/2.2/pt-slave-restart.html &gt;GLOBAL TRANSACTION IDSAs of Percona Toolkit 2.2.8, pt-slave-restart supports Global Transaction IDs introduced in MySQL 5.6.5. It’s important to keep in mind that: pt-slave-restart will not skip transactions when multiple replication threads are being used (slave_parallel_workers &gt; 0). pt-slave-restart does not know what the GTID event is of the failed transaction of a specific slave thread.The default behavior is to skip the next transaction from the slave’s master. Writes can originate on different servers, each with their own UUID.See –master-uuid. 1pt-slave-restart -uroot -pxxx -S /home/guosong/mysql5627/tmp/mysql5627.sock 通过PTDEBUG=1开启pt-slave-restart的日志，修改原有代码打印GTID_NEXT dev-00上我的pt-slave-restart，已经修改，不需要使用用户名和密码，只需要host以及port即可。RDS上从库出现错误需要跳过的处理方式 1CALL mysql.rds_skip_repl_error; RDS kill连接 1call rds_kill(id); dev-00上我的pt-slave-restart，已经修改，不需要使用用户名和密码，只需要host以及port即可。1234&gt;&gt;&gt;&gt;&gt;&gt;&gt; 42d27cbafc625665f68177fd142c0eec4f564361[guosong@dev-00 pt-tools]$ ./pt-slave-restart -h 10.30.7.220 -P 56272015-12-09T16:26:41 P=5627,h=10.30.7.220 relay-bin.000012 448 1062 pt_slave_restart:5108 20978 SET GTID_NEXT='cc5b5f77-91a6-11e5-834b-02b39697b809:38' 3、在GTID下xtrbackup如何备份？123innobackupex --defaults-file=/data1/mysql7500/etc/my7500.cnf --user=root --password=xxx /data1/backup/ --socket=/data1/mysql7500/tmp/mysql7500.sockinnobackupex --defaults-file=/data1/mysql7500/etc/my7500.cnf --user=root --password=xx --apply-log /data1/backup/mysql7500 查看xtrabackup_binlog_info 文件多一列： 1mysql-bin.000010 334810306 542ef021-9a64-11e5-bc49-025d3d22c211:1-24368 参考文档：https://www.percona.com/blog/2013/05/09/how-to-create-a-new-or-repair-a-broken-gtid-based-slave-with-percona-xtrabackup/ 123slave1 &gt; SET GLOBAL gtid_purged="c777888a-b6df-11e2-a604-080027635ef5:1-4";slave1 &gt; CHANGE MASTER TO MASTER_HOST="10.0.1.1",master_user="msandbox", master_password="msandbox", MASTER_AUTO_POSITION = 1;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux IO相关-iotop&pidstat]]></title>
    <url>%2F2015-12-07-linux-ioxiang-guan-iotop%2F</url>
    <content type="text"><![CDATA[0、前言上一篇介绍iostat相关使用说明，这里介绍iotop以及pidstat，发现使用最多io的进程以及线程。和之前写的IO统计，那里使用dmesg -c命令，这次是python写的iotop工具。 &gt;iotop watches I/O usage information output by the Linux kernel (requires 2.6.20 or later) and displays a table of current I/O usage by processes or threads on the system. 可以看到进程以及线程的io情况。 1、iotop1.1、基本使用1iotop 1.2、-o参数 -o, –onlyOnly show processes or threads actually doing I/O, instead of showing all processes or threads.This can be dynamically toggled by pressing o. 只显示有IO操作的进程和线程，而不是所有的。通过按o键可以从iotop切换到这里，也可以显示添加。 &gt;-p PID, –pid=PIDA list of processes/threads to monitor (all by default). 根据pid以及thread_id显示对应的信息。 12345678[root@mysql-db-009 ec2-user]# pstree my4000 -pmysqld(3819)─┬─&#123;mysqld&#125;(3821)├─&#123;mysqld&#125;(3822)├─&#123;mysqld&#125;(3823).......├─&#123;mysqld&#125;(3852)├─&#123;mysqld&#125;(3853)└─&#123;mysqld&#125;(3854) 其他的功能参照man iotop功能。 2、pidstat2.1、基本使用2.2、针对单个进程的io1234567891011121314151617[root@mysql-db-009 ec2-user]# pidstat -d -p 3819 1Linux 4.1.7-15.23.amzn1.x86_64 (mysql-db-009) 12/07/2015 _x86_64_ (8 CPU)11:30:33 AM PID kB_rd/s kB_wr/s kB_ccwr/s Command11:30:34 AM 3819 536.00 9316.00 0.00 mysqld11:30:35 AM 3819 752.00 14140.00 0.00 mysqld11:30:36 AM 3819 628.00 3556.00 0.00 mysqld11:30:37 AM 3819 724.00 6268.00 0.00 mysqld11:30:38 AM 3819 1348.00 8552.00 0.00 mysqld11:30:39 AM 3819 500.00 15776.00 0.00 mysqld11:30:40 AM 3819 720.00 7180.00 0.00 mysqld11:30:41 AM 3819 696.00 15932.00 0.00 mysqld11:30:42 AM 3819 1112.00 8064.00 0.00 mysqld11:30:43 AM 3819 824.00 16348.00 0.00 mysqld11:30:44 AM 3819 740.00 6044.00 0.00 mysqld11:30:45 AM 3819 1704.00 2688.00 0.00 mysqld11:30:46 AM 3819 536.00 6892.00 0.00 mysqld 2.3、]]></content>
      <categories>
        <category>Linux Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux IO相关-iostat]]></title>
    <url>%2F2015-12-07-iostat%2F</url>
    <content type="text"><![CDATA[0、前言给出Linux各种IO相关的工具介绍，例如iostat、dstat、iotop、pidstat等 1、iostat1.1 基本使用这篇博客介绍的非常不错，推荐http://www.orczhou.com/index.php/2010/03/iostat-detail/ 1iostat -d -k 1 10 参数 -d 表示，显示设备（磁盘）使用状态；-k某些使用block为单位的列强制使用Kilobytes为单位；1 10表示，数据显示每隔1秒刷新一次，共显示10次。 123456789101112[root@mysql-db-009 ec2-user]# iostat -d -k 1 10Linux 4.1.7-15.23.amzn1.x86_64 (mysql-db-009) 12/07/2015 _x86_64_ (8 CPU)Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnxvda 1.47 21.85 1.19 76408 4156xvdc 0.12 0.48 0.00 1693 4xvdb 714.66 3094.85 6764.03 10824977 23658812Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnxvda 0.00 0.00 0.00 0 0xvdc 0.00 0.00 0.00 0 0xvdb 577.00 1268.00 6428.00 1268 6428 tps该设备每秒的传输次数。一次传输意味着一次IO，多个逻辑请求可能会被合并成一次IO请求。一次传输请求的大小是未知的。 Indicate the number of transfers per second that were issued to the device. A transfer is an I/O request to the device. Multiple logical requests can be combined into a single I/O request to the device. A transfer is of indeterminate size. kB_read/s: 每秒从设备（drive expressed）读取的数据量 kB_wrtn/s: 每秒从设备（drive expressed）写入的数据量 kB_read/s: 每秒读取的数据量总量 kB_wrtn/s: 每秒写入的数据量总量 &gt;kB_read/sIndicate the amount of data read from the device expressed in kilobytes per second.kB_wrtn/sIndicate the amount of data written to the device expressed in kilobytes per second.kB_readThe total number of kilobytes read.kB_wrtnThe total number of kilobytes written. 通过参数-m可以将KB转换为MB 1234567[root@mysql-db-009 ec2-user]# iostat -d -m 1 10Linux 4.1.7-15.23.amzn1.x86_64 (mysql-db-009) 12/07/2015 _x86_64_ (8 CPU)Device: tps MB_read/s MB_wrtn/s MB_read MB_wrtnxvda 1.26 0.02 0.00 77 4xvdc 0.10 0.00 0.00 1 0xvdb 705.84 2.70 7.04 11759 30646 1.2 -x参数使用-x参数可以获取更多统计信息。 1234567[root@mysql-db-009 ec2-user]# iostat -d -x -m 1 10Linux 4.1.7-15.23.amzn1.x86_64 (mysql-db-009) 12/07/2015 _x86_64_ (8 CPU)Device: rrqm/s wrqm/s r/s w/s rMB/s wMB/s avgrq-sz avgqu-sz await svctm %utilxvda 0.00 0.07 0.89 0.09 0.01 0.00 30.27 0.00 0.98 0.37 0.04xvdc 0.00 0.00 0.07 0.00 0.00 0.00 7.99 0.00 0.40 0.40 0.00xvdb 0.00 335.16 159.50 537.92 2.35 7.69 29.50 0.54 0.77 0.55 38.57 rrqm/s: 每秒这个设备相关的读取请求有多少被Merge了（当系统调用需要读取数据的时候，VFS将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge） wrqm/s: ：每秒这个设备相关的写入请求有多少被Merge了。 r/s 和 w/s 合起来就IOPS。 &gt;rrqm/sThe number of read requests merged per second that were queued to the device.&gt;wrqm/sThe number of write requests merged per second that were queued to the device. r/sThe number of read requests that were issued to the device per second. w/sThe number of write requests that were issued to the device per second. await： 每一个IO请求的处理的平均时间（单位是毫秒）。这里可以理解为IO的响应时间，一般地系统IO响应时间应该低于5ms，如果大于10ms就比较大了。 avgrq-sz： 块设备的平均大小。 avgqu-sz： IO队列大小。 svctm： 废弃。 %util:在统计时间内所有处理IO时间，除以总共统计时间。例如，如果统计间隔1秒，该设备有0.8秒在处理IO，而0.2秒闲置，那么该设备的%util = 0.8/1 = 80%，所以该参数暗示了设备的繁忙程度。一般地，如果该参数是100%表示设备已经接近满负荷运行了（当然如果是多磁盘，即使%util是100%，因为磁盘的并发能力，所以磁盘使用未必就到了瓶颈）。 avgrq-szThe average size (in sectors) of the requests that were issued to the device. avgqu-szThe average queue length of the requests that were issued to the device. svctmThe average service time (in milliseconds) for I/O requests that were issued to the device. Warning! Do not trust this field any more. This field will be removed in a future sysstat version. 1util = (r/s + w/s)*svctm/1000 util的数值不准确http://yoshinorimatsunobu.blogspot.jp/2009/07/iostat-rs-ws-svctm-util-on-linux.html]]></content>
      <categories>
        <category>Linux Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Glib Thread篇]]></title>
    <url>%2F2015-12-05-glib-threadpian%2F</url>
    <content type="text"><![CDATA[1、前言在mydumper以及myloader中使用到GLib库的功能，前面分析mydumper源码的时候，已经给出参数解析的demo以及mydumper实现过程。mysqldump以及mydumper最大的不同之处就mydumper是多线程的，效率更高。本文就是研究这个多线程是如何实现的，并给出相关demo进行源码的测试以及验证。 2、GLIB的多线程123456789101112131415161718192021222324252627282930313233343536373839 include &lt;glib.h&gt; define MAX_THREAD 3gpointer gthread_func(gpointer data)&#123;gint i, num;num = GPOINTER_TO_INT(data);for (i = 0; i &lt; MAX_THREAD - num; i++)g_printf("Thread No. %d, of %d\n", i, num);return 0;&#125;gint main(gint argc, gchar* argv[])&#123;GThread *my_thread[MAX_THREAD];gint i;g_printf("Create thread.\n");for ( i = 0; i &lt; MAX_THREAD; i++)&#123;my_thread[i] = g_thread_new(NULL, gthread_func,GINT_TO_POINTER(i));&#125;g_printf("End create thread.\n");for( i = 0; i &lt; MAX_THREAD; i++)&#123;g_thread_join(my_thread[i]);&#125;g_printf("End join thread.\n");return 0;&#125; 参照http://www.d3.dion.ne.jp/~fut_nis/Other/GLib_program_04.pdf进行实现，并对其中已经废弃的函数进行修改。 对应的makefile文件为： 123test:test.cgcc -Wdeprecated-declarations -g -c test.c -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include -lglib-2.0gcc -o test test.o -pthread -lgthread-2.0 -lglib-2.0 其中由于使用到gthread模块，因此需要单独添加。 3、任务多线程实现demoDemo的链接https://github.com/dolphinsboy/code_for_c/blob/master/glib/gthread_multi_job.c 主要包含三个函数 1234567# 处理队列中的任务process_queue# 添加任务add_jobmain 4、静态库编译123456789wget http://ftp.gnome.org/pub/gnome/sources/glib/2.22/glib-2.22.5.tar.gztar zxvf glib-2.22.5.tar.gzcd glib-2.22.5./configure --prefix=/usr/local/glib --enable-static --disable-shared CFLAGS="-static"make &amp;&amp; make install 说明： –prefix指定安装到目录，不要与系统中已安装的glib混淆。 –enable-static –disable-shared CFLAGS=”-static”使得编译出静态库.a文件。 重点 12345export PKG_CONFIG_PATH=/usr/local/glib/lib/pkgconfig:$PKG_CONFIG_PATHpkg-config --libs glib-2.0 gthread-2.0pkg-config --cflags glib-2.0 gthread-2.0 说明： 第一句使用是让pkg-config找到新编译的glib库及头文件，后两句是通过pkg-config分别获取头文件地址和库地址。 此外，也可将–prefix/lib/pkgconfig下的文件拷贝到/lib/pkgconfig下，让pkg-config自动搜索到，但会覆盖之前已安装在标准目录下的的glib的相关文件。]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Graphite]]></title>
    <url>%2F2015-11-10-graphite%2F</url>
    <content type="text"><![CDATA[1、Graphite安装主要是参考http://graphite.wikidot.com/installation，不过中间遇到很多问题，主要列出这些问题。 使用源码安装，安装AWS EC2上，python版本为2.6，话说在AWS上安装软件还是非常方便的，至少不应考虑被墙的问题。 Django版本：安装Django版本过高，而使用的python2.6版本，最终安装1.5.0版本 忘记执行check-dependencies.py进行环境检查了，中间装了一堆的python包 安装最新版没有manage.py脚本，在/opt/graphite/webapp/graphite目录下没有找到这个脚本，通过pip安装获取到 apache的配置问题，在apachep配置目录/etc/httpd/conf.d/下，单独创建一个graphite-vhost.conf，内容是从原始配置中拷贝过来，只修改VirtualHost，其他都没有修改： Django的错误： 12345678from django.contrib.contenttypes.fields import GenericForeignKeyImportError: No module named fields 修改源码：/usr/local/lib/python2.7/site-packages/django_tagging-0.4-py2.7.egg/tagging/models.py from django.contrib.contenttypes.fields import GenericForeignKeyfrom django.contrib.contenttypes.generic import GenericForeignKey 123&lt;VirtualHost *:9090&gt;ServerName 10.30.xx.xx:9090&lt;/VirtualHost&gt; 一开始发现访问不了，原来还需要在/etc/httpd/conf/httpd.conf 文件，添加一行Listen 9090才可以。 运行如下命令发现无法找到django-admin.py文件，处理方法是在~/.bashrc中设置PATH： 123./bin/run-graphite-devel-server.py --port=9000 /opt/graphite/export PATH=/usr/local/lib/python2.6/site-packages/django/bin:$PATH 配置过程中出现错误的话，可以多参照日志/opt/graphite/storage/log/webapp/error.log，这个路径在 2、Graphite入门介绍推荐如下DevOps实战：Graphite监控上手指南 3. Grafana 没有权限访问graphitehttp://docs.grafana.org/installation/installation/ 修改权限： 123Header set Access-Control-Allow-Origin "*"Header set Access-Control-Allow-Methods "GET, OPTIONS"Header set Access-Control-Allow-Headers "origin, authorization, accept" 更好解决方案参照上面的链接。 4. DEV-00 启动graphite-carbon 123[root@dev-00 graphite]# pwd/opt/graphite[root@dev-00 graphite]# ./bin/carbon-cache.py start 启动graphite-web 123[root@dev-00 graphite]# pwd/opt/graphite[root@dev-00 graphite]# ./bin/run-graphite-devel-server.py --port=9000 /opt/graphite/ 启动grafana 1[root@dev-00 dashboards]# service grafan-server restart grafana和MySQL结合 https://www.percona.com/blog/2016/02/29/graphing-mysql-performance-with-prometheus-and-grafana/https://github.com/percona/grafana-dashboards 5. Grafana和Metric对应关系1&#123;service&#125;.&#123;p_name&#125;.&#123;port&#125;.&#123;role&#125;.&#123;node_id&#125;.&#123;metric&#125; &#123;value&#125; &#123;timestamp&#125; 6. Graphite-web问题汇总 perSecond函数bug导致图片无法显示 https://github.com/graphite-project/graphite-web/pull/1626 这个问题的原因在于采集脚本出现问题，导致数据无法显示，准备使用tcollector进行改造(agent采集的方式进行)。 Grafana也是调用graphite的接口实现的，通过下面的graphite API接口可以看到问题所在: http://kan.culiu.org:9090/render/?width=1602&amp;height=745&amp;from=-15mins&amp;target=perSecond(mysql.shop.4000.m.rds.shangcheng-m1.com_select))]]></content>
      <categories>
        <category>Graphite</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis内存使用情况统计]]></title>
    <url>%2F2015-10-22-redisnei-cun-shi-yong-qing-kuang-tong-ji%2F</url>
    <content type="text"><![CDATA[redis rdb文件内存使用情况分析生成rdb文件通过bgsave命令生成rdb文件，如果存在rdb，则跳过此步 1redis-cli -h xxx -p xxx bgsave 分析rdb文件需安装rdb：点击此处连接redis-rdb-tools 1rdb -c memory /var/redis/6379/dump.rdb &gt; memory.csv 使用上面的工具进行分析，分析结果如下： 123456database,type,key,size_in_bytes,encoding,num_elements,len_largest_element0,set,&quot;uv_filter_151020_10005138312&quot;,1440523,hashtable,13975,320,set,&quot;uv_filter_151021_100117706&quot;,1360332,hashtable,13074,320,set,&quot;uv_filter_151020_1000329580&quot;,1284149,hashtable,12218,320,set,&quot;uv_filter_151020_100030831&quot;,1228394,hashtable,11591,320,set,&quot;uv_filter_151020_10007780250&quot;,1194260,hashtable,11208,32 基于第4列进行汇总。按照上面的例子，前缀都是相同的，故需要进行合并。线上的业务总共6个分片，每个rdb文件完后的结果为1G+，将这些文件上传到AWS S3上面。 使用map-reduce服务数据分析将如下程序（mapper.py、reducer.py、run.sh）放在hadoop服务器（data-dev-00） map程序，分析上面的csv文件，获取k-v。 mapper.py 123456789101112131415161718192021222324 coding:utf8import sysimport reif __name__ == "__main__": qps_dic = &#123;&#125; for line in sys.stdin: try: infs = line[:-1].split(',') _key = infs[2] _key = _key.replace("\"", '') _key = ''.join(_key.split(':')[0]) _key = '_'.join(_key.split('_')[:-1]) _key = re.sub(r"\d+","N", _key) _value = int(infs[3]) if _key not in qps_dic: qps_dic[_key] = 0 qps_dic[_key] += _value except Exception: pass for k,v in qps_dic.items(): print "%s\t%d"%(k,v) 处理点： 按照逗号分隔，对前缀进行处理，将数字类转换成特殊字符N 内部进行汇总，故构建一个字典统计 输出按照tab键分隔 reduce程序进行结果合并 reducer.py 123456789101112131415161718192021222324252627 coding:utf8import sysdef emit(_key, _value): print _key + "\t" + "\t".join(map(str,_value))if __name__ == "__main__": current_key = None current_vals = [] for line in sys.stdin: infs = line[:-1].split('\t',1) if len(infs) == 1: (_key,_value) = (infs[0],'0') else: (_key, _value) = infs if _key != current_key and current_key != None: emit(current_key, current_vals) current_vals = [] current_key = _key _values = map(float,_value.split('\t')) if len(current_vals) == 0: current_vals = _values else: current_vals = [x + y for x, y in zip(_values, current_vals)] if current_key != None: emit(current_key, current_vals) 通过hadoop的streaming进行分析: run.sh 1234567891011 !/bin/shexport JAVA_HOME=/usr/java/latest/home/hadoop/bin/hadoop jar /home/hadoop/contrib/streaming/hadoop-streaming.jar \-D mapred.reduce.tasks=5 \-D mapred.job.map.capacity=100 \-input s3://logs.culiu.org/redis_analysis/\ #s3 路径，这个可以自己上传路径修改-output s3://forall/yangyh/redis_analysis \ #s3 路径，分析后保存路径-mapper "python mapper.py" \-reducer "python reducer.py" \-file "mapper.py" \-file "reducer.py" \ 下载并分析结果1aws s3 cp s3://xx.xx ./ --recursive 分析完得到的结果是5个部分： (自己汇总即可) 1part-00000 part-00001 part-00002 part-00003 part-00004 _SUCCESS 得到memory排序结果1sort -rn -k2 part-0000*|awk &apos;&#123;print $1,$2/1024/1024,&quot;M&quot;&#125; 针对购物车的统计需求根据购物车里面的商品数目，按照100为步长给出如下统计： 1234567891011[ec2-user@dev-00 ~]$ aws s3 ls s3://forall/guosong/redis_analysis/users/2016-05-03 12:01:30 02016-05-03 12:03:28 627442 user_100_200.log2016-05-03 12:03:48 136347 user_200_300.log2016-05-03 12:03:55 50394 user_300_400.log2016-05-03 12:04:01 23317 user_400_500.log2016-05-03 12:04:07 12995 user_500_600.log2016-05-03 12:04:13 7649 user_600_700.log2016-05-03 12:04:19 4831 user_700_800.log2016-05-03 12:04:25 3305 user_800_900.log2016-05-03 12:04:43 2318 user_900_1000.log user_100_200是指购物车里面的商品数据超过100且小于200的 使用HIVE来进行操作构建userid的表：12345678910111213hive&gt; show create table temp_user_id;OKCREATE EXTERNAL TABLE `temp_user_id`(`user_id` bigint)ROW FORMAT DELIMITEDFIELDS TERMINATED BY '\t'LINES TERMINATED BY '\n'STORED AS INPUTFORMAT'org.apache.hadoop.mapred.TextInputFormat'OUTPUTFORMAT'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'LOCATION's3://XA:C....@forall/weihl/u/m'; 数据存放在S3上 构建userid和内存之间的映射表 1234567891011121314hive&gt; show create table temp_user_memory;OKCREATE EXTERNAL TABLE `temp_user_memory`(`user_id` bigint,`msize` double)ROW FORMAT DELIMITEDFIELDS TERMINATED BY '\t'LINES TERMINATED BY '\n'STORED AS INPUTFORMAT'org.apache.hadoop.mapred.TextInputFormat'OUTPUTFORMAT'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'LOCATION's3://AKI....APiN@forall/weihl/u/i'; 写HiveSQL 1234567891011121314[hadoop@bd-master-00 guosong]$ more r.sqluse tmp;selectsum(t2.msize)from(selectdistinctt1.user_idfromtemp_user_id t1) t3inner jointemp_user_memory t2ont3.user_id = t2.user_id; 运行HiveSQL 1hive -f sum.sql hive输出结果： 1234567891011121314151617181920212223242526272829303132[hadoop@bd-master-00 guosong]$ hive -f sum.sqlLogging initialized using configuration in file:/etc/hive/conf.dist/hive-log4j.propertiesOKTime taken: 0.043 secondsQuery ID = hadoop_20160503181212_571d477d-2610-4a50-abf6-779eeb7b026aTotal jobs = 1Launching Job 1 out of 1Number of reduce tasks determined at compile time: 1In order to change the average load for a reducer (in bytes):set hive.exec.reducers.bytes.per.reducer=&lt;number&gt;In order to limit the maximum number of reducers:set hive.exec.reducers.max=&lt;number&gt;In order to set a constant number of reducers:set mapreduce.job.reduces=&lt;number&gt;Starting Job = job_1460542469374_69993, Tracking URL = http://ip-10-30-24-68.cn-north-1.compute.internal:20888/proxy/application_1460542469374_69993/Kill Command = /usr/lib/hadoop/bin/hadoop job -kill job_1460542469374_69993Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 12016-05-03 18:12:46,948 Stage-1 map = 0%, reduce = 0%2016-05-03 18:12:59,349 Stage-1 map = 13%, reduce = 0%, Cumulative CPU 8.03 sec2016-05-03 18:13:02,455 Stage-1 map = 27%, reduce = 0%, Cumulative CPU 11.29 sec2016-05-03 18:13:05,600 Stage-1 map = 40%, reduce = 0%, Cumulative CPU 14.51 sec2016-05-03 18:13:07,666 Stage-1 map = 100%, reduce = 0%, Cumulative CPU 16.76 sec2016-05-03 18:13:15,947 Stage-1 map = 100%, reduce = 100%, Cumulative CPU 18.58 secMapReduce Total cumulative CPU time: 18 seconds 580 msecEnded Job = job_1460542469374_69993MapReduce Jobs Launched:Stage-Stage-1: Map: 1 Reduce: 1 Cumulative CPU: 18.58 sec HDFS Read: 692 HDFS Write: 16 SUCCESSTotal MapReduce CPU Time Spent: 18 seconds 580 msecOK9.8070625201E10Time taken: 39.05 seconds, Fetched: 1 row(s)]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模拟MySQL IO线程]]></title>
    <url>%2F2015-10-15-mo-ni-mysql-ioxian-cheng%2F</url>
    <content type="text"><![CDATA[1.前言近期在看mydumper以及mysqlbinlog api的代码，发现MySQL从库同步这块也不是想象中那么复杂，故将其中的代码抽离出来，完成此篇博文。 在网上搜到沃趣科技的博客MYSQL BINLOG相关源码浅析，值得推荐，本文重点在于IO线程这块。 2. REGISTER_SLAVE从库注册流程，需要发送包信息包括如下:http://dev.mysql.com/doc/internals/en/com-register-slave.html 12345678910111 [15] COM_REGISTER_SLAVE4 server-id1 slaves hostname lengthstring[$len] slaves hostname1 slaves user lenstring[$len] slaves user1 slaves password lenstring[$len] slaves password2 slaves mysql-port4 replication rank4 master-id 对应的代码： 1234567891011121314151617181920212223242526int register_slave(MYSQL *conn)&#123;uchar buf[1024];uchar *pos = buf;uchar *unix_sock = 0;long default_start_pos = 4;int server_id = 1;//4bytes server-idint4store(pos, server_id); pos+= 4;pos= net_store_data(pos, (uchar*) hostname, strlen(hostname));pos= net_store_data(pos, (uchar*) username, strlen(username));pos= net_store_data(pos, (uchar*) passwd, strlen(passwd));int2store(pos, (uint16) port);pos += 2;int4store(pos, /* rpl_recovery_rank */ 0);pos += 4;int4store(pos, 0);pos += 4;if (simple_command(conn, COM_REGISTER_SLAVE, buf, (size_t)(pos - buf), 0))return ERR_FAIL;return ERR_OK;&#125; 这步执行之后，只能在主库上看到一个连接。 3.BinlogDUMP发起BinlogDump命令，需要包括如下信息：http://dev.mysql.com/doc/internals/en/com-binlog-dump.html 123451 [12] COM_BINLOG_DUMP4 binlog-pos2 flags4 server-idstring[EOF] binlog-filename 对应的代码： 123456789101112131415161718192021void start_dump(MYSQL *conn)&#123;const char *binlog_name = "mysql-bin.000002";size_t offset = 107;uchar buf[1024];char *binlog_pos;ushort binlog_flags = 0;int server_id = mysql_thread_id(conn) -1000;size_t binlog_name_length;conn-&gt;status = MYSQL_STATUS_READY;int4store(buf, offset);int2store(buf + 4, binlog_flags);int4store(buf + 6, server_id);binlog_name_length = strlen(binlog_name);memcpy(buf + 10, binlog_name, binlog_name_length);simple_command(conn, COM_BINLOG_DUMP, buf, binlog_name_length + 10, 1);&#125; 这里面比较简单，设置固定的binlog同步点。 4.读取EVENT5.Demo代码已经放在Git上binlog.c，编译放在makefile中。]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mydumper源码分析]]></title>
    <url>%2F2015-10-13-mydumperyuan-ma-fen-xi%2F</url>
    <content type="text"><![CDATA[前言记录和研究mydumper的过程，包括使用方法、源码研究以及源码中涉及的模块库函数。 编译安装使用的版本是mydumper-0.6.2 12cmake -DCMAKE_BUILD_TYPE=Debug .make 根据README需要安装一些依赖遇到找不到hash.h头文件： 123456789[root@typhoeus81 mydumper_sina]# make[ 20%] Building C object CMakeFiles/mydumper.dir/binlog.c.oIn file included from /data1/mydumper_sina/binlog.c:27:/data1/guosong/mysql5616/include/sql_common.h:26:18: error: hash.h: No such file or directoryIn file included from /data1/mydumper_sina/binlog.c:27:/data1/guosong/mysql5616/include/sql_common.h:37: error: expected specifier-qualifier-list before ‘HASH’make[2]: *** [CMakeFiles/mydumper.dir/binlog.c.o] Error 1make[1]: *** [CMakeFiles/mydumper.dir/all] Error 2make: *** [all] Error 2 参照这个buglist解决这个问题：http://bugs.mysql.com/bug.php?id=70672 测试实例运行命令: 1./mydumper -h 10.75.19.81 -P 9001 -u test -p test123 -B dbtest1 -T tb1 -o ./backup --lock-all-tables -L mydumper.test.log -v 3 日志输出： 12345678910111213141516[root@typhoeus81 mydumper-0.6.2]# more mydumper.test.log2015-10-13 16:33:26 [INFO] - Connected to a MySQL server2015-10-13 16:33:26 [INFO] - TokuDB detected, creating dummy table for CS2015-10-13 16:33:26 [INFO] - Started dump at: 2015-10-13 16:33:262015-10-13 16:33:26 [INFO] - Written master status2015-10-13 16:33:26 [INFO] - Written slave status2015-10-13 16:33:26 [INFO] - Thread 1 connected using MySQL connection ID 23684862015-10-13 16:33:26 [INFO] - Thread 2 connected using MySQL connection ID 23684872015-10-13 16:33:26 [INFO] - Thread 3 connected using MySQL connection ID 23684882015-10-13 16:33:26 [INFO] - Thread 4 connected using MySQL connection ID 23684892015-10-13 16:33:26 [INFO] - Thread 1 dumping schema for `dbtest1`.`tb1`2015-10-13 16:33:26 [INFO] - Thread 3 shutting down2015-10-13 16:33:26 [INFO] - Thread 1 shutting down2015-10-13 16:33:26 [INFO] - Thread 2 shutting down2015-10-13 16:33:26 [INFO] - Finished dump at: 2015-10-13 16:33:26 目录结构： 12345[root@typhoeus81 mydumper-0.6.2]# ll backup/total 12-rw-r--r-- 1 root root 181 Oct 13 16:33 dbtest1.tb1-schema.sql-rw-r--r-- 1 root root 525 Oct 13 16:33 dbtest1.tb1.sql-rw-r--r-- 1 root root 183 Oct 13 16:33 metadata 参数解析使用glib库的g_option_context_parse进行参数解析，分为两个部分的参数，common_entries包括host、port、user、passwd等，entries包括其他的，例如output_dir等 1234567g_option_group_add_entries(main_group, entries);g_option_group_add_entries(main_group, common_entries);g_option_context_set_main_group(context, main_group);if (!g_option_context_parse(context, &amp;argc, &amp;argv, &amp;error)) &#123; g_print ("option parsing failed: %s, try --help\n", error-&gt;message); exit (EXIT_FAILURE);&#125; 使用glib解析参数的简单例子： 1234567891011121314151617181920212223242526272829303132# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;glib.h&gt;/*Programe options */char *hostname = NULL;guint port = 3306;GOptionEntry common_entries[] =&#123; &#123;"host", 'h', 0, G_OPTION_ARG_STRING, &amp;hostname, "The host to connect to", NULL&#125;, &#123;"port", 'P', 0, G_OPTION_ARG_INT, &amp;port, "TCP/IP port to connect to", NULL&#125;,&#125;;int main(int argc, char *argv[])&#123; GError *error = NULL; GOptionContext *context; context = g_option_context_new("glib option test"); GOptionGroup *main_group = g_option_group_new("main", "Main options", "Main options",NULL, NULL); g_option_group_add_entries(main_group, common_entries); g_option_context_set_main_group(context, main_group); if (!g_option_context_parse(context, &amp;argc, &amp;argv, &amp;error))&#123; g_print ("option parsing failed: %s, try --help\n", error-&gt;message); exit (EXIT_FAILURE); &#125; g_option_context_free(context); return 0;&#125; makfile文件： 123test:test.cgcc -g -c test.c -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/includegcc -o test test.o -lglib-2.0 依赖的库以及包通过pkg-config命令获取： 12[root@typhoeus81 20151013]# pkg-config --cflags --libs glib-2.0-I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include -lglib-2.0 GLib主要参照这个博客浅析GLib main函数main函数除了参数解析部分以及根据参数创建相关目录外，核心功能如下： 12345678910111213141516if (daemon_mode) &#123; #ifdef WITH_BINLOG GThread *bthread= g_thread_create(binlog_thread, GINT_TO_POINTER(1), FALSE, &amp;terror); #endif start_scheduled_dump= g_async_queue_new(); GThread *ethread= g_thread_create(exec_thread, GINT_TO_POINTER(1), FALSE, &amp;terror); // Run initial snapshot run_snapshot(NULL); m1= g_main_loop_new(NULL, TRUE); g_main_loop_run(m1);&#125; else &#123; MYSQL *conn= create_main_connection(); start_dump(conn);&#125; start_dumpcreate_main_connection()函数是创建连接，并进行perl正则表达式的一些检测。PCRE - Perl-compatible regular expressions, 因此关键还在于start_dump。 设置timeout时间: 12SET SESSION wait_timeout = 2147483SET SESSION net_write_timeout = 2147483 长连接处理 / We check SHOW PROCESSLIST,and if there’re queries larger than preset value,we terminate the process.This avoids stalling whole server with flush / 通过show processlist来判断是否有长查询，如果有长查询则退出dump，可以通过–long-query-guard加长时间，或者使用–kill-long-queries杀掉长查询。大概代码如下： 1234567891011int longquery= 60;int killqueries= 0;if (row[tcol] &amp;&amp; atoi(row[tcol])&gt;longquery) &#123; if (killqueries) &#123; mysql_query(conn,p3=g_strdup_printf("KILL %lu",atol(row[icol]))) &#125;else&#123; //报错退出 exit(EXIT_FAILURE); &#125;&#125; 加锁12345 指定lock参数以及指定表参数LOCK TABLE %s READ 没有指定lock参数FLUSH TABLES WITH READ LOCK 记录同步点write_snapshot_info函数,执行SHOW MASTER STATUS 以及SHOW SLAVE STATUS 产生3个消息队列(线程ready队列、任务队列、myisam表处理完毕队列)。 12345678910conf.queue = g_async_queue_new();conf.ready = g_async_queue_new();conf.unlock_tables= g_async_queue_new();for (n=0; n&lt;num_threads; n++) &#123; td[n].conf= &amp;conf; td[n].thread_id= n+1; threads[n] = g_thread_create((GThreadFunc)process_queue,&amp;td[n],TRUE,NULL); g_async_queue_pop(conf.ready);&#125; dump_database两个GList 12innodb_tables :保存Innodb以及Tokudb的表non_innodb_table： 保存非Innodb表 4.6 dump_table4.7 dump_schema4.8 process_queue线程的处理函数是process_queue 12345threads[n] = g_thread_create((GThreadFunc)process_queue,&amp;td[n],TRUE,NULL);dump_table_data_file(MYSQL *conn, char *database, char *table, char *where, char *filename)guint64 rows_count = dump_table_data(conn, (FILE *)outfile, database, table, where, filename); 1234567891011121314151617for(;;) &#123; .... job=(struct job *)g_async_queue_pop(conf-&gt;queue); .... switch (job-&gt;type) &#123; case JOB_DUMP: .... dump_table_data_file(thrconn, tj-&gt;database, tj-&gt;table, tj-&gt;where, tj-&gt;filename); .... case JOB_DUMP_NON_INNODB: .... dump_table_data_file(thrconn, tj-&gt;database, tj-&gt;table, tj-&gt;where, tj-&gt;filename); case JOB_SCHEMA: .... dump_schema_data(thrconn, sj-&gt;database, sj-&gt;table, sj-&gt;filename); &#125;&#125; 典型的生产者（主线程）消费者（子线程）模式，子线程会从任务队列里读取需要处理的表名字和表类型，再通过1SELECT /*!40001 SQL_NO_CACHE */ * FROM `dbtest1`.`tb1` 读入数据各自写入到各自的文件。 引用 MYDUMPER的使用和源代码分析 浅析GLib GLIB参考手册]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-replication-listener]]></title>
    <url>%2F2015-10-08-mysql-replication-listener%2F</url>
    <content type="text"><![CDATA[1. mysql-replication-listener背景介绍同步binlog的C++ API，最开始发现是在MHA作者的博客看到的Making slave pre-fetching work better with SSD 加速SQL线程预取数据的作用。 本文记录自己测试过程以及一些源码分析。mysql-replication-listener代码位置 2. 安装编译2.1 安装参照README文件 12345export MYSQL_DIR=&lt;path of mysql directory or libmysql&gt;cmake . cmake -DCMAKE_BUILD_TYPE=Debug 便于熟悉代码进行调试，编译的时候可以加上这个参数make -j4 前提是已经装好cmake以及boost 2.2 安装遇到的问题 error: ‘MYSQL_TYPE_TIME2’ was not declared in this scope参照这个链接解决:https://bugs.mysql.com/bug.php?id=71681 2.3 测试12345[root@typhoeus81 examples]# ./basic-1 file:///data1/guosong/mysql5616/data/mysql-bin.000001Start read eventFound event of type 116 at 889193472Start read eventEndif 1234567891011121314151617181920212223242526272829303132 include "binlog_api.h"using mysql::Binary_log;using mysql::system::create_transport;int main(int argc, char** argv) &#123;if (argc != 2) &#123;std::cerr &lt;&lt; "Usage: basic-2 &lt;uri&gt;" &lt;&lt; std::endl;exit(2);&#125;Binary_log binlog(create_transport(argv[1]));binlog.connect();binlog.set_position(4);Binary_log_event *event;while (true) &#123;std::cout &lt;&lt; "Start read event"&lt;&lt; std::endl;int result = binlog.wait_for_next_event(&amp;event);if (result != ERR_OK)&#123;std::cout &lt;&lt; "Endif"&lt;&lt; std::endl;break;&#125;std::cout &lt;&lt; "Found event of type "&lt;&lt; event-&gt;get_event_type()&lt;&lt; " at "&lt;&lt; binlog.get_position()&lt;&lt; std::endl;&#125;&#125; 疑问: binlog.get_position()函数获取的位置输出太大，和实际位置不符合。 3. 源码分析MySQL binlog API 实现过程解析 http://backend.blog.163.com/blog/static/20229412620126311032126/ Google Doc Binlog API High-Level Description 官方文档 WL#3283: C/C++ API to binary log以下分析基于这篇博客，主要工作是格式化一下以及补充自己的理解。 3.1 代码分析由Mats Kindahl开发的mysql Replication Listener是一个基于STL/Boost的C++动态库，它提供了一组api函数可以从本地的binlog文件，或则通过网络方式获取binlog文件的具体内容。 mysql Replication Listener获取到的最小单位是binlog event，即mysql执行各种操作所产生的事件： Query event Rotate event Format event Table map event 使用binlog api之前首先需要创建一个连接，输入的参数有两种类型： 1、本地binlog文件，形如：file:///path/to/binlog/file 2、mysql的服务器：形如：mysql://username[:password]@ip:port两类参数分别使用了不同的过程来获取binlog event。分别对这两种实现进行说明. 3.1.1 读取本地binlog文件的实现src/file_driver.cpp文件中封装了对本地文件的全部操作过程。 1.connect() 连接过程的原理是，通过判断文件的头四个个字节是不是{0xfe, 0x62, 0x69, 0x6e}来判断输入的文件是不是一个binary log文件。 12345678910111213141516int Binlog_file_driver::connect()&#123;char magic[]= &#123;0xfe, 0x62, 0x69, 0x6e, 0&#125;;char magic_buf[MAGIC_NUMBER_SIZE];// Check if the file can be opened for reading.m_binlog_file.open(m_binlog_file_name.c_str(), ios::in | ios::binary);// Check if a valid MySQL binlog file is provided, BINLOG_MAGIC.m_binlog_file.read(magic_buf, MAGIC_NUMBER_SIZE);if(memcmp(magic, magic_buf, MAGIC_NUMBER_SIZE))return ERR_FAIL; // Not a valid binlog file.......&#125; 2.disconnect() 直接关闭binlog文件。 12345int Binlog_file_driver::disconnect()&#123;m_binlog_file.close();return ERR_OK;&#125; 3.set_position() 通过seek函数将读写指针设置到指定的位置。 1m_binlog_file.seekg(position, ios::beg ); 4.get_position() 返回binlong文件当前的读写位置。 12345int Binlog_file_driver::get_position(string *str, ulong *position)&#123;if(position)*position= m_binlog_file.tellg();&#125; 5.wait_for_next_event() 该函数首先从binlog文件中读取一个event_log header长度的数据块，hearder的数据结构是 123456789101112 define LOG_EVENT_HEADER_SIZE 20class Log_event_header&#123;public:uint8_t marker; // always 0 or 0xFFuint32_t timestamp;uint8_t type_code;uint32_t server_id;uint32_t event_length;uint32_t next_position;uint16_t flags;&#125;; 读取方式如下： 123456789101112131415161718192021if(m_bytes_read &lt; m_binlog_file_size &amp;&amp; m_binlog_file.good())&#123;//Protocol_chunk&lt;uint8_t&gt; prot_marker(m_event_log_header.marker);Protocol_chunk&lt;uint32_t&gt; prot_timestamp(m_event_log_header.timestamp);Protocol_chunk&lt;uint8_t&gt; prot_type_code(m_event_log_header.type_code);Protocol_chunk&lt;uint32_t&gt; prot_server_id(m_event_log_header.server_id);Protocol_chunk&lt;uint32_t&gt;prot_event_length(m_event_log_header.event_length);Protocol_chunk&lt;uint32_t&gt;prot_next_position(m_event_log_header.next_position);Protocol_chunk&lt;uint16_t&gt; prot_flags(m_event_log_header.flags);m_binlog_file &gt;&gt; prot_timestamp&gt;&gt; prot_type_code&gt;&gt; prot_server_id&gt;&gt; prot_event_length&gt;&gt; prot_next_position&gt;&gt; prot_flags;*event= parse_event(* static_cast&lt;std::istream*&gt; (&amp;m_binlog_file),&amp;m_event_log_header);&#125; m_event_log_header是Log_event_header类型，具体结构上面已经给出。 根据type_code的值来判断是什么样的event事件，然后根据不同event事件读取不同长度的文件内容，同时构造一个相应事件的数据结构填充其内容并返回。读完一个事件长度的内容后将文件的读写指针置于该事件内容的末尾，开始下一个事件的读取，直到文件的末尾。 1m_binlog_file.seekg(m_bytes_read + m_event_log_header.event_length,ios::beg); 函数的调用层次关系如下: create_transport(argv[1]) -&gt; parse_file_url(const char *body, size_t length) -&gt; Binlog_file_driver(body + 2) binlog.connect() -&gt; Binlog_file_driver::connect(const std::string &amp;filename, ulong position) binlog.wait_for_next_event(&amp;event) -&gt; int Binlog_file_driver::wait_for_next_event(mysql::Binary_log_event **event) 3.1.2 读取mysql服务器binlog文件的实现该实现采用网络通信的方式来获取mysql服务器上的binlog信息，通信过程完全采用了mysql网络通信协议的格式，并且使用的是boost::asio::io_servie服务作为通信的基础。 123456789[root@typhoeus81 test]# ./basic-1 mysql://test:test123@10.75.19.81:9001Start read eventFound event of type 4 at 0Start read eventFound event of type 15 at 107Start read eventFound event of type 2 at 246Start read eventFound event of type 2 at 314 对应的MySQL实例可以看到一个BinlogDump线程： 123456789*************************** 3. row ***************************Id: 2284460User: testHost: 10.75.19.81:33253db: NULLCommand: Binlog DumpTime: 13State: Master has sent all binlog to slave; waiting for binlog to be updatedInfo: NULL 在create_transport(const char *url)函数返回是Binlog_tcp_driver对象。 12345/* Port number is stored in portno, either the default, or a parsed one */return new Binlog_tcp_driver(std::string(user, user_end - user),std::string(pass, pass_end - pass),std::string(host, host_end - host),portno); Binlog_tcp_driver类中封装了整个操作过程的实现。src/tcp_driver.h文件中定义了所有的对外接口。下面分别对比较重要的接口进行说明。 1. connect() 12345int Binlog_tcp_driver::connect(const std::string&amp; user,const std::string&amp; passwd,const std::string&amp; host, uint port,const std::string&amp; binlog_filename,size_t offset) 该函数封装了另一个网络连接函数connect(user, passwd, host, port, binlog_filename, offset)。从字面意思可以看出6个参数的含义。 也支持指定binlog_filename以及offset 1int connect(const std::string &amp;binlog_filename, ulong offset); (1) mysql_init创建连接 1m_mysql= mysql_init(NULL); mysql_init文档说明https://dev.mysql.com/doc/refman/5.6/en/mysql-init.html &gt;Allocates or initializes a MYSQL object suitable for mysql_real_connect(). If mysql is a NULL pointer, the function allocates, initializes, and returns a new object. Otherwise, the object is initialized and the address of the object is returned. (2) sync_connect_and_authenticate将相关信息封装在buf内，然后进行身份验证，验证完成发送一个COM_REGISTER_SLAVE命令。 1simple_command(conn, COM_REGISTER_SLAVE, buf, (size_t) (pos - buf), 0) (3) start_binlog_dump(binlog_file, m_binlog_offset)这个函数核心是下面这个函数： 1simple_command(m_mysql, COM_BINLOG_DUMP, buf, binlog_name_length + 10, 1); 这个函数在include/sql_common.h文件中有宏定义, 是MySQL源生态的函数: 123 define simple_command(mysql, command, arg, length, skip_check) \(*(mysql)-&gt;methods-&gt;advanced_command)(mysql, command, 0, \0, arg, length, skip_check, NULL) 2. setposition() 123456int Binary_log::set_position(ulong position)&#123;std::string filename;m_driver-&gt;get_position(&amp;filename, NULL);return this-&gt;set_position(filename, position);&#125; 通过get_position调用fetch_master_status函数执行show master status获取当前的binlog位置点，然后再执行本身对象的set_position。 123456789101112131415161718192021222324Binlog_tcp_driver::set_position(const std::string &amp;str, ulong position)&#123;MYSQL *mysql= mysql_init(NULL);...int err= sync_connect_and_authenticate(mysql, m_user, m_passwd, m_host, m_port);//权限认证成功之后//执行show binary logs获取所有binlog点if (fetch_binlog_name_and_size(mysql, &amp;binlog_map))return ERR_MYSQL_QUERY_FAIL;//根据这个map进行判断请求点是否正确，否则错误std::map&lt;std::string, unsigned long&gt;::iterator binlog_itr= binlog_map.find(str);if (binlog_itr == binlog_map.end())return ERR_FAIL;if (position &gt; binlog_itr-&gt;second)return ERR_FAIL;//断开当前的连接disconnect();//根据实际点再重新连接一下if (connect(m_user, m_passwd, m_host, m_port, str, position))return ERR_CONNECT;&#125; 3.get_position()该函数获取mysql服务器当前正在使用的binlog文件名和当前的偏移量。实现步骤如下： 连接mysql服务端，并进行身份验证。调用的函数是sync_connect_and_authenticate。 获取mysql服务端当前使用的binlog文件名和偏移量。调用的函数为fetch_master_status。 fetch_master_status是执行show master status获取当前的binlog位置点，然后赋值driver类的两个变量。 4.start_binlog_dump()发送给主库COM_BINLOG_DUMP命令，主库开启BinlogDump线程。buf中封装同步点以及server_id信息 1simple_command(m_mysql, COM_BINLOG_DUMP, buf, binlog_name_length + 10, 1); 5.wait_for_next_event()构建完成binlogdump线程之后，就可以从server中读取一个数据包，通过下面的函数 12345len= cli_safe_read(m_mysql);//这个函数功能如下：//Read a packet from server. Give error message if socket was down//or packet is an error message 先接收到的是数据包的头部，根据头部中的长度信息读取整个包体的内容。 一个完整的包体对应的是一个binlog event，所以可以分析它是属于一个什么事件，并构造一个对应的event数据结构，使用包体中的信息填充其各个字段。 1*event_ptr= parse_event(is, m_waiting_event); 这里面还需要细化,还没有看懂 3.1.3 目录结构参照这个文档https://docs.google.com/document/d/1kZt5qcAflc8aORC7SEly-LdPz0n1t-dXlTEu1_zO8vI/edit 123456789101112131415161718192021222324252627282930313233343536# Listener user interfacebinlog_api.hbinary_log.cppbinlog_driver.h# Transport factoryaccess_method_factory.cppaccess_method_factory.h# Content handlersbasic_content_handler.hbasic_content_handler.cpp# Binlog interfacesbinlog_event.cppbinlog_event.hfield_iterator.cppfield_iterator.h# Row set and value interfacesvalue.cppvalue.hrow_of_fields.cpprow_of_fields.hrowset.h# MySQL interfacesprotocol.cppprotocol.hresultset_iterator.cppresultset_iterator.htcp_driver.cpptcp_driver.h# Misc utilitiesbounded_buffer.h 3.3备注 存在一个python版本的https://code.launchpad.net/~mkindahl/mysql-replicant-python/trunk]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工具类]]></title>
    <url>%2F2015-09-06-gong-ju-lei%2F</url>
    <content type="text"><![CDATA[工具类Linux常用性能调优工具索引 http://blog.yufeng.info/archives/category/tools]]></content>
      <categories>
        <category>Linux Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重启SaltMinion导致MySQL Crash]]></title>
    <url>%2F2015-08-28-zhong-qi-saltminiondao-zhi-mysql-crash%2F</url>
    <content type="text"><![CDATA[前言 分析重启SaltMinon导致MySQL Crash原因，包括SaltMinion重启过程、KillThread导致对应进程Crash原因分析以及验证、pid和ThreadId分配规则以及最后给出原因解释。 本文目录 1. SaltMinion重启过程 2. Kill Thread导致对应的进程Crash 3. Pid和Thread_id分配规则 4. SaltMinion重启为什么和MySQL的thread相重合呢？？ 1.Salt-Minion重启过程2.Kill Thread导致对应的进程Crash2.1 kill 和 kill -9方式1234567pstree -n -p |grep mysql|less|-mysqld_safe(18573)---mysqld(20122)-+-&#123;mysqld&#125;(20134)| |-&#123;mysqld&#125;(20135)| |-&#123;mysqld&#125;(20136)| |-&#123;mysqld&#125;(20137)| |-&#123;mysqld&#125;(20138)...... 进行两种kill的模拟 2.2 mysqld_safe作用2.3 验证将下面的代码保存在test.c文件中： 12345678910111213141516171819202122232425 include &lt;stdio.h&gt; include &lt;stdlib.h&gt; include &lt;signal.h&gt; include &lt;pthread.h&gt;void *thread_func()&#123;printf("thread create\n");sleep(100000);printf("thread ended\n");&#125;int main()&#123;pthread_t tid;int rc = pthread_create(&amp;tid, NULL, thread_func, NULL);pthread_join(tid, NULL);printf("pthread_id = %d\n", tid);return 0;&#125; 编译： 12gcc -g -c test.cgcc -o test test.o -lpthread 模拟发现kill 和kill -9输出结果 3.Pid和Thread_id分配规则4.SaltMinion重启为什么和MySQL的thread相重合呢？？]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[服务器负载那些事]]></title>
    <url>%2F2015-08-26-fu-wu-qi-fu-zai-na-xie-shi%2F</url>
    <content type="text"><![CDATA[1. CPU你不一定懂的cpu显示信息 http://www.cnblogs.com/yjf512/p/3383915.html]]></content>
      <categories>
        <category>Linux Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化]]></title>
    <url>%2F2015-08-25-mysqlyou-hua%2F</url>
    <content type="text"><![CDATA[前言汇总各种比较好的优化博客，便于在遇到实际问题的时候查看，包括优化准则、美团的索引博文、Join优化。 1、优化准则12345678910111213L1 cache reference 0.5 nsBranch mispredict 5 nsL2 cache reference 7 nsMutex lock/unlock 100 nsMain memory reference 100 nsCompress 1K bytes with Zippy 10,000 nsSend 2K bytes over 1 Gbps network 20,000 nsRead 1 MB sequentially from memory 250,000 nsRound trip within same datacenter 500,000 nsDisk seek 10,000,000 nsRead 1 MB sequentially from network 10,000,000 nsRead 1 MB sequentially from disk 30,000,000 nsSend packet CA-&gt;Netherlands-&gt;CA 150,000,000 ns http://highscalability.com/numbers-everyone-should-know 2、美团《MySQL索引原理及慢查询优化》http://tech.meituan.com/mysql-index.html 3、MySQL索引背后的数据结构及算法原理http://blog.codinglabs.org/articles/theory-of-mysql-index.html 4、Join优化Join优化原则&gt; 查询所返回的结果集，通常查询返回的结果集很少，是有信心进行优化的； 驱动表的选择至关重要，通过查看执行计划，可以看到优化器选择的驱动表,从执行计划中的rows可以大致反映出问题的所在； 理清各表之间的关联关系，注意关联字段上是否有合适的索引； 使用straight_join关键词来强制表之间的关联顺序，可以方便我们验证某些猜想； 主要参照这篇博客复杂关联SQL的优化]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阿里数据库相关视频分享]]></title>
    <url>%2F2015-08-24-a-li-shu-ju-ku-xiang-guan-shi-pin-fen-xiang%2F</url>
    <content type="text"><![CDATA[1. 阿里分布式数据库(DRDS\TDDL)实践 视频链接http://v.youku.com/v_show/id_XODMyMzk2OTUy.html pdf链接http://vdisk.weibo.com/s/CW6y_n6-bJqB/1416312608 2. DBFree-阿里数据库自动化运维平台 视频链接http://v.youku.com/v_show/id_XNjUyNzExNjky.html?from=s1.8-1-1.2 ppt链接http://wenku.baidu.com/view/6237edf8960590c69ec3765a.html]]></content>
      <categories>
        <category>业界技术分享汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python模块汇总]]></title>
    <url>%2F2015-08-12-pythonmo-kuai-hui-zong%2F</url>
    <content type="text"><![CDATA[前言 汇总在开发过程中使用到所有Python模块，记录起来方便日后使用。 prettytable ascii_graph 1、prettytable1.1 功能实现python console的数据格式化，按照表格的方式输出。 1.2 演示 1.3 代码demo12345678910111213141516 !/usr/bin/env python2.7 -*- coding:utf8 -*-from prettytable import PrettyTabletable = PrettyTable(["animal", "ferocity"])table.add_row(["wolverine", 100])table.add_row(["grizzly", 87])table.add_row(["Rabbit of Caerbannog", 110])table.add_row(["cat", "中文中文中文中文中文中"])table.add_row(["platypus", 23])table.add_row(["dolphin", 63])table.add_row(["albatross", 44])table.sort_key("ferocity")table.reversesort = Trueprint table 如果使用颜色的话，得使用shell的方式 123color = "\033[94m&#123;value&#125;\033[0m"value = "中文"value = color.format(value=value) 2、ascii_graph 2.1 功能将数据打印输出成直方图的形式 2.2 演示 2.3 代码Demo12345678910111213141516from ascii_graph import Pyasciigraphfrom ascii_graph.colors import * Simple coloringtest = [('testval0', 600),('testval1', 500, Pur),('testval2', 400, Red),('testval3', 400, Red),('testval4', 300, Gre),('testval5', 200, Yel),('testval6', 100, Cya),('testval7', 50, Blu) ]graph = Pyasciigraph()for line in graph.graph('test graph', test):print(line) 参考资料 http://code.google.com/p/prettytable/ https://py-ascii-graph.readthedocs.org/en/latest/]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL GroupCommit]]></title>
    <url>%2F2015-08-11-mysql-groupcommit%2F</url>
    <content type="text"><![CDATA[参考资料1、MySQL/InnoDB和Group Commit(1)2、MySQL/InnoDB和Group Commit(2)3、MariaDB &amp; Percona XtraDB Group Commit实现简要分析]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL内存使用情况]]></title>
    <url>%2F2015-08-10-mysqlnei-cun-shi-yong-qing-kuang%2F</url>
    <content type="text"><![CDATA[内存使用情况统计MySQL内存有两个组成部分，全局和线程级别的。下图是一个示例： 参考资料1、https://dev.mysql.com/doc/refman/5.5/en/memory-use.html2、https://www.percona.com/blog/2006/05/17/mysql-server-memory-usage/3、https://www.percona.com/blog/2014/01/24/mysql-server-memory-usage-2/]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Epoll模型]]></title>
    <url>%2F2015-08-04-epollmo-xing%2F</url>
    <content type="text"><![CDATA[1、Epoll模型讲解（转）首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。不管是文件，还是套接字，还是管道，我们都可以把他们看作流。 之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？ 阻塞 Epoll：阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）,那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你)。 非阻塞忙轮询 select : 接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：”你到了没?” 结论:很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。 缓冲区为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。 例子 假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。 但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。 假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”。 也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。 这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。 然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）： 123456while true &#123;for i in stream[]; &#123;if i has dataread until unavailable&#125;&#125; 我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。 为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样: 1234567while true &#123;select(streams[])for i in streams[] &#123;if i has dataread until unavailable&#125;&#125; 于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，没一次无差别轮询时间就越长。再次说了这么多，终于能好好解释epoll了。 epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）在讨论epoll的实现细节之前，先把epoll的相关操作列出： 12345678epoll_create 创建一个epoll对象，一般epollfd = epoll_create()epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件比如epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//注册缓冲区非空事件，即有数据流入epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//注册缓冲区非满事件，即流可以被写入epoll_wait(epollfd,...)等待直到注册的事件发生（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。 一个epoll模式的代码大概的样子是： 123456while true &#123;active_stream[] = epoll_wait(epollfd)for i in active_stream[] &#123;read or write till&#125;&#125; 2、结合APUE上介绍 待更新….. 3、参考资料1、我读过最好的Epoll模型讲解 2、UNIX环境高级编程——epoll函数使用详解]]></content>
      <categories>
        <category>Unix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Innodb内部结构]]></title>
    <url>%2F2015-07-30-innodbnei-bu-jie-gou%2F</url>
    <content type="text"><![CDATA[1、资料来源 逐篇阅读Jeremy Cole大拿的bloghttp://blog.jcole.us/innodb/进行记录汇总。 官方的Internals https://dev.mysql.com/doc/internals/en/index.html 两个结合在一起看。 2、Innodb记录结构123456CREATE TABLE `test4` (`id` int(11) NOT NULL AUTO_INCREMENT,`data` int(11) NOT NULL DEFAULT '1',`data2` varchar(255) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 表t包括6个列，而不是3个列，额外的看不到的列是row ID、transaction ID以及rollback pointer。 插入如下记录： 12345678910+-------+------+--------+| id | data | data2 |+-------+------+--------+| 1 | 0 | NULL || 2 | 0 | b || 3 | 0 | b || 4 | 0 | b || 10 | 1 | NULL || 11 | 2 | TTTTT |+-------+------+--------+ 使用hexdump -C 读取ibd文件，下面一个片段： 12345678910111213141516171819200000c000 8e 35 7e a9 00 00 00 03 ff ff ff ff ff ff ff ff |.5~.............|0000c010 00 00 00 00 69 d8 c7 00 45 bf 00 00 00 00 00 00 |....i...E.......|0000c020 00 00 00 00 01 1a 00 02 01 26 80 08 00 00 00 00 |.........&amp;......|0000c030 01 0c 00 02 00 05 00 06 00 00 00 00 00 00 00 00 |................|0000c040 00 00 00 00 00 00 00 00 01 f7 00 00 01 1a 00 00 |................|0000c050 00 02 00 f2 00 00 01 1a 00 00 00 02 00 32 01 00 |.............2..|0000c060 02 00 1b 69 6e 66 69 6d 75 6d 00 07 00 0b 00 00 |...infimum......|0000c070 73 75 70 72 65 6d 75 6d 01 00 00 10 00 1c 80 00 |supremum........|0000c080 00 01 00 00 00 00 82 6b 99 00 00 01 40 00 84 80 |.......k....@...|0000c090 00 00 00 01 00 00 00 18 00 1d 80 00 00 02 00 00 |................|0000c0a0 00 00 82 6b 99 00 00 01 40 00 91 80 00 00 00 62 |...k....@......b|0000c0b0 01 00 00 00 20 00 1d 80 00 00 03 00 00 00 00 82 |.... ...........|0000c0c0 6b 99 00 00 01 40 00 9e 80 00 00 00 62 01 00 00 |k....@......b...|0000c0d0 00 28 00 1c 80 00 00 04 00 00 00 00 82 6b 99 00 |.(...........k..|0000c0e0 00 01 40 00 ab 80 00 00 00 62 01 00 00 30 00 1c |..@......b...0..|0000c0f0 80 00 00 0a 00 00 00 00 82 91 ae 00 00 01 9b 00 |................|0000c100 84 80 00 00 01 05 00 00 00 38 ff 64 80 00 00 0b |.........8.d....|0000c110 00 00 00 00 82 93 b0 00 00 01 9d 00 84 80 00 00 |................|0000c120 02 54 54 54 54 54 00 00 00 00 00 00 00 00 00 00 |.TTTTT..........|0000c130 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 如何找到记录的开始位置： infimum和supremum是两个具体的英文单词 对应的16个进制为infimum 69 6e 66 69 6d 75 6d supremum 73 75 70 72 65 6d 75 6d 28个字节 123456789101112131415&gt;&gt;&gt; import binascii&gt;&gt;&gt; binascii.b2a_hex('i')'69'&gt;&gt;&gt; binascii.b2a_hex('n')'6e'&gt;&gt;&gt; binascii.b2a_hex('f')'66'&gt;&gt;&gt; binascii.b2a_hex('i')'69'&gt;&gt;&gt; binascii.b2a_hex('m')'6d'&gt;&gt;&gt; binascii.b2a_hex('u')'75'&gt;&gt;&gt;hex(1024*3)'0xc00' 使用姜承尧的脚本进行分析http://code.google.com/p/david-mysql-tools/source/browse/trunk/py_innodb_page_type/ 123456789101112page offset 00000000, page type &lt;File Space Header&gt;page offset 00000001, page type &lt;Insert Buffer Bitmap&gt;page offset 00000002, page type &lt;File Segment inode&gt;page offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0000&gt;page offset 00000000, page type &lt;Freshly Allocated Page&gt;page offset 00000000, page type &lt;Freshly Allocated Page&gt;Total number of page: 6:Freshly Allocated Page: 2Insert Buffer Bitmap: 1File Space Header: 1B-tree Node: 1File Segment inode: 1 总共6个page，文件大小是96KB，innodb单个页面大小为16KB，故也是6个page 参考资料1、http://www.cnblogs.com/zhoujinyi/archive/2012/10/17/2726462.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac快捷键图标]]></title>
    <url>%2F2015-07-29-mackuai-jie-jian-tu-biao%2F</url>
    <content type="text"><![CDATA[Mac图标对于mac的图标总是记不太住，在这里记录一下，便于查找。 更多图标参照参考的第2个链接。 参考资料1、https://support.apple.com/zh-cn/HT201236 2、https://support.apple.com/kb/PH18802?locale=zh_CN&amp;viewlocale=zh_CN]]></content>
      <categories>
        <category>Mac</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go知识点记录1]]></title>
    <url>%2F2015-07-27-goyu-fa-hui-zong%2F</url>
    <content type="text"><![CDATA[本博文说明记录平时学习和使用Go遇到的小问题点，本博文包括如下： 创建自定义包 如何写benchmark以及测试用例 异常抛出以及处理 使用错误处理 len和cap区别 slice Go访问MySQL 类和方法 创建自定义包12345678Package中函数名称首字母必须大写import ("os""./Go_Package")Go_Package.F(1) Testing Demo主要参照的代码demohttps://github.com/davecheney/fib注意点：1、文件名称必须是xx_test.go文件，否则会报错的。2、测试用例，输入参数以及输出结果 代码 123456789101112131415161718192021222324252627282930313233343536package mainimport ("sync""testing")var lock sync.Mutexfunc test() &#123;lock.Lock()lock.Unlock()&#125;func testdefer()&#123;lock.Lock()defer lock.Unlock()&#125;func Test_test(t *testing.T)&#123;test()&#125;func BenchmarkTest(b *testing.B) &#123;for i := 0; i &lt; b.N; i++ &#123;test()&#125;&#125;func BenchmarkTestDefter(b *testing.B)&#123;for i := 0; i &lt; b.N; i++ &#123;testdefer()&#125;&#125; 执行测试用例： 12345guosongdeMacBook-Air:go-test guosong$ go test -bench .PASSBenchmarkTest 50000000 33.8 ns/opBenchmarkTestDefter 20000000 81.6 ns/opok _/Users/guosong/Desktop/Sina/Code/go-test 3.440s 异常抛出以及处理panic抛出异常，recover捕获异常，然后退出 123456789101112131415func test(x int) &#123;defer func() &#123;if err := recover(); err != nil &#123;println(err.(string))&#125;&#125;()if x/2 == 0 &#123;panic("panic error")&#125;&#125;func main() &#123;test(0)&#125; 使用错误处理123456789101112131415161718192021package mainimport "errors"var ErrDivByZero = errors.New("division by zero")func div(x, y int) (int, error) &#123;if y == 0 &#123; return 0, ErrDivByZero&#125;return x / y, nil&#125;func main() &#123;switch z, err := div(10, 1); err &#123;case nil:println(z)case ErrDivByZero:panic(err)&#125;&#125; len 和 cap区别 sliceslice是指针，而不是一个具体的值。 12345678910111213func main() &#123;d := [5]struct &#123;x int&#125;&#123;&#125;s := d[:]d[1].x = 100d[2].x = 200fmt.Printf("%p\n", &amp;d)fmt.Printf("%p", s)&#125; 输出的结果： 12&amp;d = 0x20819c150s = 0x20819c150 可以看到数组d的地址和s相等，说明slice是指针，指向的地址和原来数组起始地址相关，故通过s或者d来改变数组里的数据会相互受影响。 Go访问mysql使用go-sql-driver驱动器，帮助文档参照https://github.com/go-sql-driver/mysql/blob/master/README.md#installation demo123456789101112131415161718192021222324import ("database/sql"_ "./go-sql-driver/mysql""fmt")func checkError(err error) &#123;if err != nil &#123;panic(err.Error())&#125;&#125;func main() &#123;db, err := sql.Open("mysql","test:test123@tcp(10.75.19.79:5616)/test")checkError(err)defer db.Close()var str stringerr = db.QueryRow("select version()").Scan(&amp;str)checkError(err)fmt.Println(str)&#125; 运行时间比较 通过访问编译的程序，访问时间明显缩短很多。]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在Intellij IDEA中配置golang]]></title>
    <url>%2F2015-07-22-zai-intellij-ideazhong-pei-zhi-golang%2F</url>
    <content type="text"><![CDATA[环境搭建参照下面的博客完成在Intellij IDEA中配置golangIntelliJ IDEA 14安装Golang插件go-lang-idea-plugin。 由于系统上之前已经安装好go和IDEA，现在将两者结合起来，本博客记录整个配置的过程。 下载插件在https://github.com/go-lang-plugin-org/go-lang-idea-plugin上下载插件。 配置生成intellij-go.jar包1、将下载的go-lang-idea-plugin压缩包解压，IDEA点击File -&gt; open 打开该工程。 2、点击File -&gt; Project Structure 打开项目结构配置窗口： 3、设置Project SDK点击File -&gt; Project Structure -&gt;Project，设置Project SDK为刚刚设置好的IDEA sdk 4、编译生成jar包点击Build-&gt;Prepare All Plugins For Deployment，选择intellij-go.jar包 安装插件在Perference中选择Plugins 手动安装intellij-go.jar包 设置Go SDK选择go的HOME Demo 命令行运行Go程序]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Using MySQL with java]]></title>
    <url>%2F2015-07-20-using-mysql-with-java%2F</url>
    <content type="text"><![CDATA[1. Using MySQL with Java [Percona Live 2015] 2. Demo使用文件的方式进行访问1234567891011121314151617181920212223242526272829303132import java.io.IOException;import java.sql.*;import java.util.Properties;public class Main &#123;public static void main(String[] args)throws SQLException, ClassNotFoundException, IOException &#123;Class.forName("com.mysql.jdbc.Driver");Properties prop = new Properties();prop.load(Main.class.getClassLoader().getResourceAsStream("db.properties"));Connection conn = DriverManager.getConnection(prop.getProperty("mysql.url"),prop.getProperty("mysql.user"),prop.getProperty("mysql.password"));Statement st = conn.createStatement();ResultSet rs = st.executeQuery("SELECT concat('Hello from mysql', version()) As msg");if (rs.next()) &#123;System.out.println(rs.getString("msg"));&#125;rs.close();st.close();conn.close();&#125;&#125; 3. IDEA配置添加jdbc的jar包： 代码是使用IntelliJ IDEA编写的，遇到找不到文件的情况，解决方案是将db.properties和java代码放置在同一个目录，并且进行下图设置：]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[信号量扑捉]]></title>
    <url>%2F2015-07-14-xin-hao-liang-bu-zhuo%2F</url>
    <content type="text"><![CDATA[1、背景多个平台共同使用一台中控机，由于某个部门运行python脚本的bug，导致机器压缩过大无法登陆，解决的方案就是重启机器，由于是部署的crontab任务，机器启动之后很快有不行了。其他部门的同学在没有通知的情况，使用一个死循序kill掉所有和python相关的运行程序。由于没有周知其他部门的同学，其他部门同学随便运行一个python脚本都会被kill。 由此引发一个问题就是如何找出被kill程序对应的源程序呢？ 2、信号量 kill -9 和 kill -15的区别？？ kill -9 对应的信号量是SIGKILL， kill -15对应的信号量是SIGTERM SIGKILL是否可以扑捉？测试信号量SIGKILL1234567891011 ! /usr/bin/env python2.6import signalimport time, osdef handler(signum, frame):print 'Signum = %d' % signumret = signal.getsignal(signum)print os.getpid(),os.getppid()signal.signal(signal.SIGKILL, handler)signal.pause() 运行的时候会出现如下的错误： 12345[root@typhoeus79 20150714]# python2.6 signal.pyTraceback (most recent call last):File &quot;signal.py&quot;, line 11, in &lt;module&gt;signal.signal(signal.SIGKILL, handler)RuntimeError: (22, &apos;Invalid argument&apos;) 从这个链接中可以看到SIGKILL的说明，http://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html The SIGKILL signal is used to cause immediate program termination. It cannot be handled or ignored, and is therefore always fatal. It is also not possible to block this signal.SIGKILL和SIGSTOP是不能被捕获以及忽略的信号，是向管理员提供可以杀死任一进程的可靠方法。 SIGTERM默认会将未关闭的IO流关闭之后再退出。将上面的代码改成捕捉SIGTERM，输出结果为：[root@typhoeus79 20150714]# python2.6 signal.pySignum = 1514412 24840 根据ppid查看对应的进程为： 12345[root@typhoeus79 20150714]# readlink /proc/24840/exe/bin/bash[root@typhoeus79 20150714]# readlink /proc/24840/cwd/[root@typhoeus79 20150714]# readlink /proc/24840/cwd/data1/guosong/opdir/20150714 进行kill进程的话，还是使用kill -15的方式。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL的server_id出现相同情况的案例分析]]></title>
    <url>%2F2015-07-08-mysqlde-server-idfen-xi%2F</url>
    <content type="text"><![CDATA[1.问题经常会问到主从server_id相同会怎么样？从库之间server_id相同会怎么样？A-&gt;B-&gt;C结构下，如果A和C的server_id相同又会怎么样？ 1.1 主从server_id相同启动start slave 之后，出现错误： Last_IO_Errno: 1593Fatal error: The slave I/O thread stops because master and slave have equal MySQL server ids; these ids must be different for replication to work (or the –replicate-same-server-id option must be used on slave but this does not always make sense; please check the manual before using it). 1.2.两个从库之间存在server_id相同主库上的Binlog Dump线程会替换成新的从库ip，且Binlog Dump的Time时间是变化，主库没有任何写入。 另一个从库的状态是出现一个非常大的延迟。 2.源码分析2.1 从库server_id相同的情况彭立勋的博客MySQL多个Slave同一server_id的冲突原因分析 ，这里给出代码的解释，如果从库之间的server_id出现相同的情况，从库进行COM_REGISTER_SLAVE的时候会到hash表中按照server_id为key进行先删除已经存在的slave，然后再重新注册。由于从库都有重试的机制，故其中断又重新导致其他的被kill掉，然后再反复，故我们看到的现象就是出现server_id的两个从库同步状态是时断时续的。 2.2 主从server_id相同的情况sql/sql_parse.cc 解析start slave的命令12345678910113101 case SQLCOM_SLAVE_START:3102 &#123;3103 mysql_mutex_lock(&amp;LOCK_active_mi);3104 if (active_mi != NULL)3105 res= start_slave(thd, active_mi, 1 /* net report*/);3106 else3107 my_message(ER_SLAVE_CONFIGURATION, ER(ER_SLAVE_CONFIGURATION),3108 MYF(0));3109 mysql_mutex_unlock(&amp;LOCK_active_mi);3110 break;3111 &#125; sql/rpl_slave.cc中的get_master_version_and_clock函数 start_slave() -&gt; start_slave_threads() -&gt; handle_slave_io() -&gt; get_master_version_and_clock() 判断主从server_id是否相同的地方123456789101112131415161919 if (!mysql_real_query(mysql,1920 STRING_WITH_LEN("SHOW VARIABLES LIKE 'SERVER_ID'")) &amp;&amp;1921 (master_res= mysql_store_result(mysql)) &amp;&amp;1922 (master_row= mysql_fetch_row(master_res)))1923 &#123;1924 if ((::server_id == (mi-&gt;master_id= strtoul(master_row[1], 0, 10))) &amp;&amp;1925 !mi-&gt;rli-&gt;replicate_same_server_id)1926 &#123;1927 errmsg= "The slave I/O thread stops because master and slave have equal \1928 MySQL server ids; these ids must be different for replication to work (or \1929 the --replicate-same-server-id option must be used on slave but this does \1930 not always make sense; please check the manual before using it).";1931 err_code= ER_SLAVE_FATAL_ERROR;1932 sprintf(err_buff, ER(err_code), errmsg);1933 goto err;1934 &#125; 3.gdb调试MySQL安装的时候使用 -DWITH_DEBUG=bool, 参照这个Compiling MySQL for Debugging gdb运行的时候，需要指定特定的配置文件，使用的方式如下： 1gdb --args ./bin/mysqld --defaults-file=/data1/guosong/mysql5616/etc/my5616.cnf 更多参照这个链接Debugging a MySQL Server (待补充)]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线程安全]]></title>
    <url>%2F2015-06-23-xian-cheng-an-quan%2F</url>
    <content type="text"><![CDATA[1、线程安全概念 If a function can be safely called by multiple threads at the same time, we say that the function is thread-safe. 如果一个函数在同一时刻可以被多个线程安全地调用，就称该函数是线程安全的。 2、 POSIX.1中不能保证线程安全的函数]]></content>
      <categories>
        <category>Unix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[octopress的git问题]]></title>
    <url>%2F2015-06-12-octopressde-gitwen-ti%2F</url>
    <content type="text"><![CDATA[1. 背景对于octopress来说常用的命令是: octoprocess常用命令12345678rake new_post['xxxx']rake previewrake deploygit statusgit add .git commit -m 'xxxx'git push origin source 但是今天缺遇到一个问题： rake deploy的问题12345678# Pushing generated _deploy websiteTo git@github.com:dolphinsboy/dolphinsboy.github.io.git! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to 'git@github.com:dolphinsboy/dolphinsboy.github.io.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 怎么git rebase –HEAD xxx都不行，也不哪里有冲突，如果直接git pull的话，会将master中无关的代码全部拉下来了，污染source分支。 2. 问题解决方案各种google也没解决，最后发现一篇blog解决我的问题:Setup an Existing Octopress Repository After Git Clone 3.处理过程3.1 重新拉源代码123git clone git@github.com:dolphinsboy/dolphinsboy.github.io.git octopresscd octopress/git checkout source 3.2 手动从master再拉一份deploy文件1234mkdir _deploycd _deploy/git initgit remote add -t master -f origin https://github.com/dolphinsboy/dolphinsboy.github.io 3.3 重新deploy上面完成之后重新rake gen_deploy发现如下问题： 123# Pushing generated _deploy websiteremote: Invalid username or password.fatal: Authentication failed for 'https://github.com/dolphinsboy/dolphinsboy.github.io/' 原因是3.2步骤设置成通过http访问的了，修改_deploy/.git/config中url参数为ssh方式即可。至此解决我的问题。]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[supervisord配置使用总结]]></title>
    <url>%2F2015-06-12-supervisordpei-zhi-shi-yong-zong-jie%2F</url>
    <content type="text"><![CDATA[1.背景之前搭建公司内部的API系统，tornado server的守护进程使用supervisord进行管理，故当时就supervisord进行学习，并整理成相关文档。 2. supervisord总结文档这里不在重复贴出，给出个百度网盘的链接:使用supervisor守护Python进程.pdf Slideshare上的链接：]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python单元测试]]></title>
    <url>%2F2015-06-08-pythondan-yuan-ce-shi%2F</url>
    <content type="text"><![CDATA[背景公司内部使用Salt进行配置管理工作，通过Salt-master的client执行相关命令，鉴于内部其他系统会使用到Salt服务，为了避免每个都ssh到Salt-master执行命令，故之前负责Salt的同学使用django框架对这些常用的命令进行HTTP API的封装。 目前总共32个接口，现在由于各种问题，需要迁移到Tornado的框架中。32个接口手动测试有点麻烦，故此研究一下python单元测试，这些可以为了后续对代码的改进，避免重复手动测试工作。 Python单元测试主要是看了如下几个博客： (1). 廖雪峰博客的单元测试 (2). Python单元测试框架 (3). python2.7手册 (4). Python自动单元测试框架 (5). Unit Testing with Python Demo1——来自博客1123456789101112131415 !/usr/bin/env python -*- coding:utf8 -*-class Dict(dict): def __init__(self, **kw): super(Dict, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r"'Dict' object has no attribute '%s'" % key); def __setattr__(self, key, value): self[key] = value Dict类，这个类的行为和dict一致，但是可以通过属性来访问，保存为mydict.py。 1234567891011121314151617181920212223242526272829303132333435363738394041424344 !/usr/bin/env python -*-coding:utf8 -*-import unittestfrom mydict import Dictclass TestDict(unittest.TestCase):"""测试类，从unittest.TestCase继承以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。""" def test_init(self): d = Dict(a=1, b= 'test'); self.assertEquals(d.a, 1) self.assertEquals(d.b, 'test') self.assertTrue(isinstance(d, dict)) def test_key(self): d = Dict() d['key'] = 'value' self.assertEquals(d.key, 'value') def test_attr(self): d = Dict() d.key = 'value' self.assertTrue('key' in d) def test_keyerror(self): d = Dict() with self.assertRaises(KeyError): value = d['empty'] def test_attrerror(self): d = Dict() with self.assertRaises(AttributeError): value = d.emptyif __name__ == '__main__':unittest.main() unitest.TestCase提供很多内置的条件判断，如下图，只需要调用这些方法就可以断言输出是否符合预期。 另一种重要的断言就是期望抛出指定类型的Error，例如上面的后面两个测试用例。 两个截图都来自链接3 可以将这个test.py当做正常的脚本使用main进行操作。另一种更常见的方法是通过命令行参数-m unittest直接运行单元测试： 通过命令行参数运行单元测试123456guosongdeMacBook-Air:20150608 guosong$ python -m unittest test.....----------------------------------------------------------------------Ran 5 tests in 0.000sOK 注意：脚本名称后面不同加.py后缀，否则出现错误。 setUp 和 tearDown如果想在执行每个测试用例的时候，在开始和结束的时候，执行一些操作，可以使用setUp和tearDown两个函数来实现，具体代码如下： TestDict类中重写setUp和tearDown函数123456def setUp(self): 打印当前执行测试case的方法名print 'setUp..., test_case_name = %s' % self._testMethodNamedef tearDown(self):print 'tearDown..., done' 如果setUp执行成功，那么无论runTest是否成功，tearDown方法都将被执行。上面的实现方式称为固件。 在博客2中介绍通过覆盖runTest 方法实现的方式，不过一般都不常用，具体可以参照博客2。 测试套件(test unit)测试Widget类123456789101112class Widget(object): def __init__(self, name, x=50, y=50): self.name = name self.x = x self.y = y def size(self): return (self.x, self.y) def resize(self, x, y): self.x = x self.y = y 测试用例12345678910111213141516171819202122232425import unittestfrom widget import Widgetclass WidgetTestCase(unittest.TestCase): def setUp(self): self.widget = Widget("The widget") def tearDown(self): self.widget.dispose() self.widget = None def testDefaultSize(self): assert self.widget.size() == (50,50), 'incorrect default size' size = self.widget.size() self.assertEquals(size, (50,50),'incorrect default size') def testResize(self): self.widget.resize(100, 150) size = self.widget.size() self.assertEquals(size, (100,150),'wrong size after resize') 测试组件12345678910111213141516171819202122232425def suite(): """ 测试用例实例可以根据它们所测试的特性组合起来, 这个机制称为测试套件 """ suite = unittest.TestSuite() suite.addTest(WidgetTestCase("testDefaultSize")) suite.addTest(WidgetTestCase("testResize")) """ makeSuite方法创建一个由测试用例类内所有测试用例组成的测试套件 makeSuite(testCaseClass, prefix='test', sortUsing=&lt;built-in function cmp&gt;, suiteClass=&lt;class 'unittest.suite.TestSuite'&gt;) makeSuite会做排序，基于内置的cmp函数 """suite = unittest.makeSuit(WidgetTestCase, 'test')return suiteif __name__ == '__main__': suite = suite() runner = unittest.TextTestRunner() runner.run(suite)]]></content>
      <categories>
        <category>Test</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ELK搭建过程]]></title>
    <url>%2F2015-06-03-elkda-jian-guo-cheng%2F</url>
    <content type="text"><![CDATA[背景内部系统MySQL API 每天都产生大量的日志，需要从这些日志分析接口的调用时间、请求超时、错误等趋势以及具体的接口，便于抓住重点进行分析。目前公司内部主要使用ELK进行日志分析，故在此也使用ELK进行API日志的分析。 ELK搭建过程文档 参照百度网盘上的链接http://pan.baidu.com/s/1pJKFoE3 重点根据上面的文档就可以搭建出ELK了，其中对于日志分析的重点还是写正则表达式。文档中提供Grok，在线工具非常值得推荐http://grokdebug.herokuapp.com/ 常用的patterns：https://github.com/logstash/logstash/tree/v1.4.0/patterns 可以根据的日志格式生成定义的pattern，定义好的变量可以放在${LogstashHOME}/patterns/grok-patterns文件中。 新浪使用ELK进行日志分析新浪是如何分析处理32亿条实时日志的?]]></content>
      <categories>
        <category>ELK</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tornado异步非阻塞]]></title>
    <url>%2F2015-06-02-tornadoyi-bu-fei-zu-sai%2F</url>
    <content type="text"><![CDATA[背景内部平台提供HTTP API对日常经常使用的MySQL运维操作进行封装，经过多人积累，目前平台共有 117 个 HTTP 接口,涵盖到 MySQL 操作、MySQL 实例 元数据、授权、MySQL 状态、MySQL 集群拓扑结构、主从复制、DNS、体检巡检、参数变更、短信邮件报警、监控、表结构修改等。在线上实际运行的过程，经常出现API夯住的问题。 平台的API接口基于Facebook的Tornado实现，Tornado本身是支持异步非阻塞的，但是我们在开发的时候并没有使用这一特性，故进行出现单个端口夯住导致其他请求查询实践过程。 Tornado异步非阻塞调研文档基于下面两个博客，对现有的API进行改造，实现支持异步非阻塞功能 tornado异步非阻塞 Blocking tasks in Tornado 下面给出之前本人写的《MySQLAPI 阻塞问题解决方案调研》的pdf文档，参照百度网盘的链接http://pan.baidu.com/s/1sjxA4KP 里面的关于《Apache+WSGI+Tornado的配置》文档为内部的链接，外网无法访问，故参照下面的链接http://pan.baidu.com/s/1dDq7yY9 介绍Tornado的资料本人学习的Tornado入门资料主要是《Introduction to Tornado》 英文版本的链接：http://maemual-share.qiniudn.com/Oreilly.Introduction.to.Tornado.Mar.2012.pdf 中文版本的链接:http://mirrors.segmentfault.com/itt2zh/index.html 中文版本的翻译看过，整体感觉还不错的，值得推荐，主要还是多敲上面的demo吧 Tornado和Django性能对比通过后台Salt执行获取某个ip机器上某个端口的mysql配置文件信息。构造一个测试例子文件： siege测试API并发量1234siege -c 100 -r 2 -f salt[root@typhoeus81 test]# more salthttp://sinadbp.mars.grid.sina.com.cn/sinasalt/get_mysql_conf/tgt=10.13.2.70 siege 测试Django API siege 测试Tornado API 测试结论从上面的结果上可以看到tornado的明显更为稳定，响应时间也比较快，django在高并发的情况下完全超时。]]></content>
      <categories>
        <category>Tornado</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO统计]]></title>
    <url>%2F2015-05-27-iotong-ji%2F</url>
    <content type="text"><![CDATA[1、背景线上一台Salt Master的机器压力特别大 故需要找出哪个进程在进行写操作，需要按照进程的维度统计出现IOPS的工具，故google的目录3中的一些参考资料 2、实现方式主要参照3节中第一个链接how-to-find-per-process-io-statistics-on-linux 下载iodump的脚本，这是perl写 1wget http://aspersa.googlecode.com/svn/trunk/iodump 打开内核有关IO消息的开关 1echo 1 &gt; /proc/sys/vm/block_dump 统计相关进程的IOPS 1while true; do sleep 1; dmesg -c; done | perl iodump 效果图： 3、参考资料(1)、http://www.xaprb.com/blog/2009/08/23/how-to-find-per-process-io-statistics-on-linux/(2)、http://www.cnblogs.com/cloudstorage/archive/2012/11/11/2764623.html(3)、http://www.ibm.com/developerworks/cn/aix/library/au-lsof.html(4)、http://mp.weixin.qq.com/s?__biz=MzAwODI1NTczOQ==&amp;mid=207783961&amp;idx=1&amp;sn=c3f310f3250cef29a866b15542226305&amp;scene=2#rd]]></content>
      <categories>
        <category>Linux Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tcpdump解析SQL]]></title>
    <url>%2F2015-05-18-tcpdumpjie-xi-sql%2F</url>
    <content type="text"><![CDATA[1、背景公司内部使用到MytriggerQ的自研软件，其主要功能是从MySQL的blackhole从库中读取更新的binlog，将每条更新的SQL转换成一条消息存储到内存中，供其他程序通过GET协议消费。 由于机房网络调整，涉及到很多MytriggerQ的实例，且这些东西几经转手，需要查看是否存在流量，如果存在，需要给出来源的IP以及相关的命令。MytriggerQ自身不提供任何流量查询功能，没有记录相关日志，故能想到的最直接办法就是tcpdump抓包分析。 2、tcpdump详解神一样的文章，值得推荐http://roclinux.cn/?p=2474 在上面的文章中分析包括UDP包的IP报文，故在此基础上，本人再加上一个TCP包的分析过程，具体参照百度网盘中的pdf文档http://pan.baidu.com/s/1o6OLcjo。 TCP的分析过程主要涉及导下面几个结构图: 报文的层次图 IP报文包头的结构图 图引用来源http://www.tcpipguide.com/free/t_IPDatagramGeneralFormat.htm 记忆点：IP报文包头长度20个字节 TCP报文包头的结构图 图引用来源http://www.tcpipguide.com/free/t_TCPMessageSegmentFormat-3.htm 记忆点：TCP报文中不包括可选项也是20个字节，可选项的长度是由Dataoffset确定，故TCP首部长度 = 20个字节 + Dataoffset 3、SQL解析通过上面对于tcpdump分析，如果按照结构进行分析，可能非常麻烦。公司内部之前有同事写的一个分析MySQL流量的情况，其主要也是通过tcpdump抓包分析，分析结果给出来源IP、目标IP以及相关SQL命令。 https://www.percona.com/blog/2008/11/07/poor-mans-query-logging/http://jetpackweb.com/blog/2009/09/16/unobstrusive-viewing-of-mysql-queries-with-tcpdump/ 4、开源分析tcpdump包通过强大的Wireshark图形工具可以分析。如果想按照报文结构格式解析报文，应该如何实现呢？ 4.1 pyshark通过pyshark的Python包可以分许TCP报文包头的信息 123456789101112delta: Delta (difference) time between the current packet and the previous captured packetdestination: The Layer 3 (IP, IPv6) destination addressinfo: A brief application layer summary (e.g. ‘HTTP GET /resource_folder/page.html’)ip id: IP Identification field used for uniquely identifying packets from a hostlength: Length of the packet in bytesno: Index number of the packet in the listprotocol: The highest layer protocol recognized in the packetsource: Layer 3 (IP, IPV6) source addressstream: Index of the TCP stream this packet is a part of (TCP packets only)summary_line: All the summary attributes in one tab-delimited stringtime: Absolute time between the current packet and the first packetwindow: The TCP window size (TCP packets only) pyshark具体的文档链接：http://thepacketgeek.com/pyshark-using-the-packet-object/ 但是对于Data的部分找不到对应的属性，故无法满足需求。 4.2 python分析报文结构过程主要是参照github上的源码https://github.com/TimothyFitz/MyPorkDetector tcpip.py：给出如果从tcpdump的二进制包中按照结构获取对应的属性信息sql_parser.py：将报文中的数据信息转换成对应的SQL语句]]></content>
      <categories>
        <category>Linux Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C typedef用法]]></title>
    <url>%2F2015-05-15-c-typedefyong-fa%2F</url>
    <content type="text"><![CDATA[typedef用法http://www.361way.com/typedef/560.htmlhttp://www.cnblogs.com/xrcun/archive/2013/05/24/3097149.html C语言执行python脚本 C语言执行python脚本123456789101112131415161718192021 include "apue.h" include &lt;sys/wait.h&gt;int main(void)&#123; pid_t pid; if ((pid = fork()) &lt; 0)&#123; err_sys("fork error"); &#125;else if (pid == 0)&#123; printf("child pid=%d, parentid=%d\n", getpid(), getppid()); if (execl("./echoall.py", "echoall.py", "myarg1", "MY ARG2", (char *)0) &lt; 0) err_sys("execle error"); &#125; if (waitpid(pid, NULL, 0) &lt; 0) err_sys("wait error"); exit(0);&#125; execl第1个参数和第二个参数名称必须相同]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C宏定义的特殊用法]]></title>
    <url>%2F2015-05-15-chong-ding-yi-de-te-shu-yong-fa%2F</url>
    <content type="text"><![CDATA[APUE 7-8例子出现如下用法宏定义的井号用法12#define doit(name) pr_limits( name, name)static void pr_limits(char *, int) 更多的特殊使用方法#(井号)在C/C++的#define宏定义中的特殊用法]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[静态库、共享库、动态库]]></title>
    <url>%2F2015-05-15-cheng-xu-ku%2F</url>
    <content type="text"><![CDATA[Program-Library-HOWTO 静态库、共享库、动态库的创建和使用]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C程序存储空间]]></title>
    <url>%2F2015-05-14-ccheng-xu-cun-chu-kong-jian%2F</url>
    <content type="text"><![CDATA[1. 正文段CPU执行的机器指令部分。通常，正文段是可共享的。正文段常常是只读的，以防止程序由于意外而修改其自身的指令。 2. 初始化数据段程序需明确赋值的变量。 3. 非初始化数据段bss：block started by symbol 由符合开始的地方。 4. 栈自动变量以及每次函数调用时所需保存的信息都存放在此段中。 5. 堆通常在堆中进行动态存储分配。 6、例子size命令获取各个段的大小，单位是字节 size命令获取各个段大小123$ size 7-1__TEXT __DATA __OBJC others dec hex4096 4096 0 4294971392 4294979584 100003000 第四列和第五列是十进制和十六进制的长度表示。]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GDB学习笔记]]></title>
    <url>%2F2015-05-11-learning-gdb%2F</url>
    <content type="text"><![CDATA[GDB概述GDB主要帮忙你完成下面四个方面的功能： 1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。 2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式） 3、当程序被停住时，可以检查此时你的程序中所发生的事。 4、动态的改变你程序的执行环境。 GDB分析corefilecorefile产生系统设置1234[root@qbj3-op-sre-test-00 guosong]# ulimit -c1024[root@qbj3-op-sre-test-00 guosong]# ulimit -acore file size (blocks, -c) 1024 Demo 源码 1234567891011121314151617181920[root@qbj3-op-sre-test-00 guosong]# more test.c #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int crash()&#123; char *xxx = "crash!!"; xxx[1] = 'D'; // 写只读存储区! return 2;&#125;int foo()&#123; return crash();&#125;int main()&#123; return foo();&#125; 编译 1gcc -g -o test test.c 需要添加-g参数，可以进行debug 执行test产生core文件。 分析core 123456789[root@qbj3-op-sre-test-00 guosong]# gdb test ./core.21740 Core was generated by `./test&apos;.Program terminated with signal 11, Segmentation fault.#0 0x0000000000400501 in crash () at test.c:77 xxx[1] = &apos;D&apos;; // 写只读存储区!(gdb) bt#0 0x0000000000400501 in crash () at test.c:7#1 0x0000000000400519 in foo () at test.c:13#2 0x0000000000400529 in main () at test.c:18 参考资料陈皓的博客-用GDB调试程序 http://blog.csdn.net/haoel/article/details/2879]]></content>
      <categories>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python类操作符重载]]></title>
    <url>%2F2015-05-04-python-operator-overload%2F</url>
    <content type="text"><![CDATA[Demosetattr & getattr12345678910111213class Object(): def __setattr__(self, n, v): if n == 'age': self.__dict__[n] = v print 'setattr' def __getattr__(self, n): if n == 'age': return self.__dict__[n]obj = Object()obj.age = 2print obj.age 输出： output12setattr2 参考资料1、 http://blog.teamtreehouse.com/operator-overloading-python 2、 所有的操作符https://docs.python.org/3/reference/datamodel.html#special-method-names]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[个人介绍]]></title>
    <url>%2F2015-05-02-introduction%2F</url>
    <content type="text"><![CDATA[联系方式 姓名：郭颂 微博：@小郭学路 QQ：253876250 工作经历 2011.4——2013.6 百度MySQL DBA 2013.6——2015.10 新浪MySQL DBA 2015.10–至今 楚楚街数据库和运维负责人]]></content>
  </entry>
</search>

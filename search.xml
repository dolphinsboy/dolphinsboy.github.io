<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2021-04-21_Innodb参数与状态变量]]></title>
    <url>%2F2021-04-21-Innodb%E5%8F%82%E6%95%B0%E4%B8%8E%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[前言在5.7.25中InnoDB包含156个变量以及55个Status状态变量，它们大概可以分为哪些方面以及各个都代表什么含义呢？ 参数 Buffer Pool相关 自适应Hash相关 Page相关 压缩相关 状态相关 线程相关 日志相关 其他 状态变量]]></content>
  </entry>
  <entry>
    <title><![CDATA[2021-04-15_PostgreSQL-&-MySQL对比]]></title>
    <url>%2F2021-04-15-PostgreSQL-MySQL%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[参照 https://mp.weixin.qq.com/s?spm=a2c6h.12873639.0.0.71d17af365JDEo&amp;__biz=MzAwMDU1MTE1OQ==&amp;mid=2653547609&amp;idx=1&amp;sn=cbb55ee823ddec9d98ef1fa984e001f6&amp;scene=0#wechat_redirect https://eng.uber.com/mysql-migration/ https://www.slideshare.net/GrokkingVN/grokking-techtalk-20-postgresql-internals-101]]></content>
  </entry>
  <entry>
    <title><![CDATA[2021-04-14_MVCC-InnoDB&PostgreSQL]]></title>
    <url>%2F2021-04-14-MVCC-InnoDB-PostgreSQL%2F</url>
    <content type="text"><![CDATA[主要参考 https://severalnines.com/database-blog/comparing-data-stores-postgresql-mvcc-vs-innodb]]></content>
  </entry>
  <entry>
    <title><![CDATA[2021-04-08_HDFS-EC码]]></title>
    <url>%2F2021-04-08-HDFS-EC%E7%A0%81%2F</url>
    <content type="text"><![CDATA[EC码的数学原理https://zhuanlan.zhihu.com/p/356436303]]></content>
  </entry>
  <entry>
    <title><![CDATA[2021-04-01_HDFS-HA]]></title>
    <url>%2F2021-04-01-HDFS-HA%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2021-04-01_HDFS-写流程]]></title>
    <url>%2F2021-04-01-HDFS-%E5%86%99%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[2021-04-01_HDFS-读流程]]></title>
    <url>%2F2021-04-01-HDFS-%E8%AF%BB%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[HDFS读关键问题 整体读的流程 就近访问规则 如何保证数据一致性 一个文件涉及多个Block，Block之间是串行读取还是并发读取？ 数据读取的单位是啥？ 基本概念-1. block：HDFS操作文件的最小单元，默认是128MB-2. chunk：文件块block实际存储/校验的最小单位，chunk包括数据域（默认512字节）和校验域（checksum值，固定4个字节）-3. packet：HDFS各组件间数据传输的基本单位，默认64KB 三者之间的关系为： 1个block由多个chunk data组成，每个chunk data里存储的都是二进制数据 1个block对应一个meta文件，存放与之对应的chunk checksum HDFS组件间传输数据最小以packet为单位，1个packet由多个chunk构成，传输后取出其中的chunk（data+checksum），最后构成block和meta HDFS读Java代码12345678910111213141516171819import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FSDataInputStream;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IOUtils;import java.net.URI;public class FileRead &#123; public static void main(String[] args) throws Exception&#123; String dst = "hdfs://my-hadoop-test14:8020/tmp/tezsmokeinput/sample-tez-test"; Configuration conf = new Configuration(); FileSystem fs = FileSystem.get(URI.create(dst), conf); //发RPC给NameNode，返回的stream对象包含文件对应的block+dn列表（假设文件已存在，且权限认证通过） FSDataInputStream in = fs.open(new Path(dst)); //读取核心的逻辑 in.read(); IOUtils.copyBytes(in, System.out, 4096, true); &#125;&#125; 读文件流程看着比较简单，关键的三行代码，背后对应哪些流程和细节呢？ 关键流程如下： 客户端通过F 参考 HDFS源码分析之Client读流程 Hadoop权威指南第四版]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[半同步复制]]></title>
    <url>%2F2021-03-31-%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言传统的MySQL复制是主从异步复制的模式，在主库故障的时候，存在binlog未传到从库的场景，从而引发丢失的问题。为了解决这个问题，在MySQL5.5版本引入半同步复制功能。半同步同步机制是怎么样的？半同步是否完全解决数据丢失问题以及主从数据一致呢？本文一一介绍一下。 架构半同步复制流程 上图是半同步复制的示意图，在master将事务写入binlog后，将新写入的binlog事务日志传送slave节点，但需要等待slave返回传送的ACK结果；slave收到binlog事务后，将其写入relay log中（刷盘），然后向master返回成功的ACK；master收到ACK后，再存储引擎中提交事务。如果主库故障了，至少可以确保有一个从库有最新的binlog。 更详细的解释，如下图： 场景分析 旧主库多数据 这个可以看出如果在Sync Binlog之后主库故障，这个时候所有slave上都没有这Binlog的。主从切换之后，如果旧主库再恢复之后，旧主库就会有多数据的情况。不过由于没有给客户端返回OK，客户端认为是失败，会再次进行操作，所以问题不大。 新主库多数据？ 如果slave上返回ACK之后，这个时候如果主库故障，主从切换之后，由于新的slave有relaylog。旧主库如果重启恢复的话，redolog存在未提交的事务，此事务在binlog中存在(前提是binlog是持久到磁盘，因此需要设置sync_binlog=1，如果是非1的模式，主库因此可能存在丢数据的风险)，在崩溃恢复的时候会提交，旧主库数据不会丢失。 sync_binlog设置为1的Dump线程和IO线程如下交互的，具体看下图（引用自MySQL · 源码分析 · MySQL 半同步复制数据一致性分析）： 对标的从库上sync_relay_log参数，如果是非1的情况，从库在Crash的时候就会丢失已经回复的主库ACK的事务。 MySQL二阶段提交二阶段提交是Binlog和Redolog两者之间的，协调者为Binlog，崩溃恢复的时候仲裁由Binlog进行，如果Redolog回放的时候，未提交的事务没有在Binlog中找到，则回滚，否则提交。 图来自iMySQL沉思 半同步如何保证数据不丢失？ 在从库ACK之后，如果主库还没有返回client，这个时候主库故障，会发生什么场景？ 数据一致性Loss-less Semi-Synchronous Replication on MySQL 5.7.2MySQL 半同步复制数据一致性分析 半同步的两种类型，使用参数rpl_semi_sync_master_wait_point进行控制，包括两种AFTER_SYNC &amp; AFTER_COMMIT。 AFTER_SYNC模式master将新的事务写入binlog（buffer），然后发送给slave，再sync到自己的binlog file（disk）。之后才允许接收slave的ACK回复。接收到ACK之后才会引擎层提交事务，并返回成功信息给客户端。这里的AFTER_SYNC是在主库binlog的sync之后就接收SLAVE的ACK回复。 AFTER_COMMIT模式master将新的事务写入binlog（buffer），然后发送给slave，再sync到自己的binlog（disk），然后直接引擎提交事务。之后才允许接收slave的ACK回复，然后再返回成功信息给客户端。这里的AFTER COMMIT是在引擎层commit之后再接收SLAVE的ACK回复。 图参照深入MySQL复制(三)：半同步复制 AFTER_COMMIT模式使得数据持久化保存并对释放对数据的锁定。因此，即使client仍在等待确认，此后其他会话也可以访问到该数据。如果master故障而slave切换之后，它会导致幻读。具体如下图所示：新主库没有最新的数据，说明新主库ACK没有返回成功，而旧主库已经引擎层提交了，这个时候旧主库出现故障并发生切换的情况。 一开始是AFTER_COMMIT的模式，在5.7.2引入Loss-Less Semi-Synchronous机制，也就是AFTER_SYNC模式。 半同步配置相关参数12345678910111213mysql&gt; show global variables like &apos;rpl_semi_%&apos;;+-------------------------------------------+------------+| Variable_name | Value |+-------------------------------------------+------------+| rpl_semi_sync_master_enabled | OFF || rpl_semi_sync_master_timeout | 10000 || rpl_semi_sync_master_trace_level | 32 || rpl_semi_sync_master_wait_for_slave_count | 1 || rpl_semi_sync_master_wait_no_slave | ON || rpl_semi_sync_master_wait_point | AFTER_SYNC || rpl_semi_sync_slave_enabled | OFF || rpl_semi_sync_slave_trace_level | 32 |+-------------------------------------------+------------+ 线上使用的时候多注意rpl_semi_sync_master_timeout，超时之后自动从半同步复制降级到异步复制。主要参照https://www.cnblogs.com/f-ck-need-u/p/9166452.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binlog日志]]></title>
    <url>%2F2021-03-26-Binlog%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[Binlog 格式格式类型 ROW STATEMENT MIX :默认是Statement格式，只有在需要的时候才转换为ROW格式 Binlog 格式对比 数据不一致 基于Statment格式会产生数据不一致的场景 Binlog相关的源码文件 https://dev.mysql.com/doc/internals/en/source-files-related-to-the-binary-log.html Event Type123456789101112131415161718192021mysql test@127.0.0.1:test&gt; show binlog events in 'mysql-bin.000008';+------------------+-----+----------------+-----------+-------------+------------------------------------------------------------------------+| Log_name | Pos | Event_type | Server_id | End_log_pos | Info |+------------------+-----+----------------+-----------+-------------+------------------------------------------------------------------------+####################Binlog Format为ROW格式##################################################################| mysql-bin.000008 | 4 | Format_desc | 57259203 | 123 | Server ver: 5.7.25-debug-log, Binlog ver: 4 || mysql-bin.000008 | 123 | Previous_gtids | 57259203 | 190 | 69161b29-71c1-11eb-b9da-90b11c2651dc:1-91 || mysql-bin.000008 | 190 | Gtid | 57259203 | 251 | SET @@SESSION.GTID_NEXT= '69161b29-71c1-11eb-b9da-90b11c2651dc:92' || mysql-bin.000008 | 251 | Query | 57259203 | 379 | use `test`; create table t(id int not null AUTO_INCREMENT primary key) || mysql-bin.000008 | 379 | Gtid | 57259203 | 440 | SET @@SESSION.GTID_NEXT= '69161b29-71c1-11eb-b9da-90b11c2651dc:93' || mysql-bin.000008 | 440 | Query | 57259203 | 508 | BEGIN || mysql-bin.000008 | 508 | Table_map | 57259203 | 548 | table_id: 141 (test.t) || mysql-bin.000008 | 548 | Write_rows | 57259203 | 584 | table_id: 141 flags: STMT_END_F || mysql-bin.000008 | 584 | Xid | 57259203 | 611 | COMMIT /* xid=77 */ |####################Binlog Format为Statement格式##################################################################| mysql-bin.000008 | 611 | Gtid | 57259203 | 672 | SET @@SESSION.GTID_NEXT= '69161b29-71c1-11eb-b9da-90b11c2651dc:94' || mysql-bin.000008 | 672 | Query | 57259203 | 747 | BEGIN || mysql-bin.000008 | 747 | Intvar | 57259203 | 775 | INSERT_ID=2 || mysql-bin.000008 | 775 | Query | 57259203 | 871 | use `test`; insert into t values(NULL) || mysql-bin.000008 | 871 | Xid | 57259203 | 898 | COMMIT /* xid=100 */ |+------------------+-----+----------------+-----------+-------------+------------------------------------------------------------------------+ 可以看到在Binlog Format为Statement格式的，有IntVar类型以及Query类型，更多Type参照官方文档 Binlog写入当server执行事务时，server将事务更改缓存到每个连接的transaction cache中（binlog_buffer）。statement格式将语句记录到cache中，row格式将事务行的更新记录到cache中。一旦事务提交的时候，binlog cache将被写入到binlog文件中，多个连接写入的时候都会加锁。 1234| binlog_cache_size | 32768 || binlog_stmt_cache_size | 32768 || max_binlog_cache_size | 18446744073709547520 || max_binlog_stmt_cache_size | 18446744073709547520 | 如果经常使用大事务，可以增加cache大小，减少或避免写临时文件，获取更好的性能。主要看如下两个状态变量： 12Binlog_cache_use #使用到Binlog Cache的事务个数Binlog_cache_disk_use #由于超过binlogc_cache_size而写入到临时文件的事务个数 Binlog协调以及崩溃恢复MySQL是多存储引擎架构的，是分Server和Engine架构,Binlog打开的情况下，它将作为协调者和各个引擎交互。在启动节点要负责引擎内状态为prepare的事务，决定它们是提交还是回滚。 MySQL · 引擎特性 · 主库 binlog 概览 臭名昭著的prepare_commit_mutex崩溃恢复的时候依赖Binlog，如果没有Binlog的话，比如使用xtrabackup进行备份的时候，其在apply log（崩溃恢复的过程），会出现数据丢失问题。 图中处于Prepared的事务会被回滚。 图中如果在T1的引擎Commit之前备份完成，那么T1的事务会丢失。 通过隐去prepare_commit_mutex锁来保证一致性，所有事务变成顺序提交。 Group Commit基本原理因为磁盘写比较慢，将每个事务都刷盘就非常影响性能。 对于每个阶段，都有一个输入队列，每个连接在其中排队等待处理。如果连接（THD）在空队列中注册的话，则将其视为Leader，否则为Follower。Leader负责所有线程的每一个阶段的操作，然后Folloer等待Leader发出信号，说明整个提交已完成。 在Flush Stage阶段，所有THD将其缓存写入二进制日志中（Binlog Cache）。在Sync Stage阶段，依据sync_binlog的配置，将binlog刷新到磁盘上。设置sync_binlog=1所有THD将在该阶段刷盘。在Commit Stage阶段，按照注册顺序执行在Innodb引擎层提交操作，所有工作交由Leader完成。按照相同的顺序完成。 在Commit阶段执行完成后，所有处于该阶段的THD都将被标记为已完成，并被告知可以继续执行，然后每个THD从提交过程返回并继续执行。 性能对比 sync_binlog为0和1区别 在5.6.5版本中，设置sync_binlog为0和1，性能差别还比较到。在5.6实验版本中，两个差距相对缩写比较少。 groupcommit性能对比 可以看到引入group_commit性能提升不少。 以上图主要来自MySQL 5.6中的二进制日志组提交。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-Group-Replication架构]]></title>
    <url>%2F2021-03-26-MySQL-Group-Replication%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言上一篇测试搭建MGR集群，本篇主要研究MGR架构以及略微底层原理架构。 异步复制 半同步复制 组复制 MGR插件组成 MySQL Group Replication是一个MySQL插件，基于现有的MySQL复制基础的，并利用基于行的二进制日志以及GTID等功能。上图是MySQL组复制的总体架构。MGR插件包括一组用于捕获Capture、应用Applier、生命周期LifeCycle的API，这些API控制插件与MySQL Server交互。下一层组件，捕获组件负责跟踪与正在执行的事务相关的上下文；应用程序组件负责在数据库上执行远程事务。恢复组件管理分布式服务，并负责成员加入管理。复制协议模块包含复制协议的特定逻辑，包括处理冲突检测，接收事务并将其传播到该组其他节点上。 最后两层是组通信系统GCS和基于Paxos的组通信引擎（XCom）。GCS API是一个高级API，抽象构建复制状态机所需的熟悉。因此，他将消息传递层的实现与插件的其他上层分离。组通信引擎(XCom)处理与复制组成员的通信。 数据同步原理在集群内部通过Binlog Events进行原子广播判断，是否有冲突。如果有冲突，本地进行回滚操作，其他节点将对应的Binlog Event丢弃处理；否则通过多线程同步在本地回放。 冲突检测 基于WriteSet的冲突检测原则 单主单主选主原则事务一致性保证组复制是最终的一致性系统。一旦访问流量减慢或停止，所有组成员将具有相同的数据内容。当访问流量在持续的时候，可能导致过时的读取。为了限制这些问题，可以激活和调整组复制的流控机制，以最大程度地减少快速成员和慢速成员之间的差异。 从MySQL8.0.14开始，要为组中的每个事务都拥有一个事务一致性保证，通过参数group_replication_consistency系统变量来做到这一点。官方文档-事务一致性保证 跨版本兼容性建议是选择相同的版本，5.7版本中可以支持8.0版本加入，8.0版本不支持5.7版本的加入。这样就带来一个问题，如下滚动的升级呢？比如3个节点的。 监控参考文档 阿里云《深入MySQL实战》 宋利兵 《深入理解MySQL Group Replication》 官方文档]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-Group-Replication-配置实战]]></title>
    <url>%2F2021-03-25-MySQL-Group-Replication-%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[背景从MySQL5.7.17就开始支持Group Replication，以MySQL插件的模式，支持单主、多主更新，自动分区恢复、冲突检测等特性，其主要好处如下： 自动剔除故障节点 提供容错机制 支持多节点更新 自动组配置管理（处理宕机、故障以及重连接） 提供高可用复制数据库 本文主要测试如何配置、单主和多主区别、多主数据更新冲突等。 搭建MySQL基础配置1234567gtid-mode = ONenforce_gtid_consistency = 1master_info_repository = TABLErelay_log_info_repository = TABLEtransaction_write_set_extraction = MURMUR32binlog_checksum = NONElog-slave-updates = 1 组复制配置12345678#-------------- group replication ---------------plugin_load_add=&apos;group_replication.so&apos;transaction_write_set_extraction=XXHASH64loose-group_replication_group_name=&quot;0f1ec2e6-db7f-11ea-9773-38f9d35e8343&quot;loose-group_replication_start_on_boot=offloose-group_replication_local_address= &quot;qbj3-mysql-test7:15729&quot;loose-group_replication_group_seeds= &quot;qbj3-mysql-test7:15729,qbj3-mysql-test8:15729,qbj3-mysql-test13:15729&quot;loose-group_replication_bootstrap_group=off 具体参数含义参照官方文档 授权配置1CHANGE MASTER TO MASTER_USER=&apos;replica&apos;, MASTER_PASSWORD=&apos;eHnNCaQE3ND&apos; FOR CHANNEL &apos;group_replication_recovery&apos;; 权限配置在8.0上版本表现不同，具体参照官方文档 开启MGR单主模式默认是单主的模式 在Server1上执行123SET GLOBAL group_replication_bootstrap_group=ON;START GROUP_REPLICATION;SET GLOBAL group_replication_bootstrap_group=OFF; Configure this server to bootstrap the group. This option must only be set on one server and only when starting the group for the first time or restarting the entire group. After the group has been bootstrapped, set this option to OFF. It should be set to OFF both dynamically and in the configuration files. Starting two servers or restarting one server with this option set while the group is running may lead to an artificial split brain situation, where two independent groups with the same name are bootstrapped. 这个参数只能在一台服务器上配置，并且只能在首次启动组或者重新启动整个组时进行设置。组引导完成之后，将此设置为OFF，否则容易导致分裂。搭建测试的时候，在每台服务器都执行这个命令生成三个组。 在Server2和Server3上执行12START REPLICATION; 校验12345678910mysql&gt; select * from performance_schema.replication_group_members;+---------------------------+--------------------------------------+------------------+-------------+--------------+| CHANNEL_NAME | MEMBER_ID | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE |+---------------------------+--------------------------------------+------------------+-------------+--------------+| group_replication_applier | 3daf3191-78a5-11ea-88da-f8bc124417c4 | qbj3-mysql-test7 | 5729 | ONLINE || group_replication_applier | f65c1f31-d0b2-11ea-a245-90b11c503899 | qbj3-mysql-test13 | 5729 | RECOVERING || group_replication_applier | f72f4b43-d0b1-11ea-8ef4-c81f66f4e97a | qbj3-mysql-test8 | 5729 | RECOVERING |+---------------------------+--------------------------------------+------------------+-------------+--------------+3 rows in set (0.00 sec) 历史遗留的环境，其他两个merbers一致处于recover的状态。重新reset master之后，然后重新设置组复制。 1234567891011121314151617181920212223242526272829303132mysql&gt; select * from replication_group_members;+---------------------------+--------------------------------------+------------------+-------------+--------------+| CHANNEL_NAME | MEMBER_ID | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE |+---------------------------+--------------------------------------+------------------+-------------+--------------+| group_replication_applier | 3daf3191-78a5-11ea-88da-f8bc124417c4 | qbj3-mysql-test7 | 5729 | ONLINE || group_replication_applier | f65c1f31-d0b2-11ea-a245-90b11c503899 | qbj3-mysql-test13 | 5729 | ONLINE || group_replication_applier | f72f4b43-d0b1-11ea-8ef4-c81f66f4e97a | qbj3-mysql-test8 | 5729 | ONLINE |+---------------------------+--------------------------------------+------------------+-------------+--------------+3 rows in set (0.00 sec)mysql&gt; select * from performance_schema.replication_group_member_stats\G*************************** 1. row *************************** CHANNEL_NAME: group_replication_applier VIEW_ID: 15971212520128575:3 MEMBER_ID: 3daf3191-78a5-11ea-88da-f8bc124417c4 COUNT_TRANSACTIONS_IN_QUEUE: 0 COUNT_TRANSACTIONS_CHECKED: 0 COUNT_CONFLICTS_DETECTED: 0COUNT_TRANSACTIONS_ROWS_VALIDATING: 0TRANSACTIONS_COMMITTED_ALL_MEMBERS: 0f1ec2e6-db7f-11ea-9773-38f9d35e8343:1-3 LAST_CONFLICT_FREE_TRANSACTION:1 row in set (0.00 sec)mysql&gt; show processlist;+----+-------------+-----------+--------------------+---------+------+--------------------------------------------------------+------------------+| Id | User | Host | db | Command | Time | State | Info |+----+-------------+-----------+--------------------+---------+------+--------------------------------------------------------+------------------+| 73 | root | localhost | performance_schema | Query | 0 | starting | show processlist || 76 | system user | | NULL | Connect | 142 | executing | NULL || 79 | system user | | NULL | Connect | 142 | Slave has read all relay log; waiting for more updates | NULL |+----+-------------+-----------+--------------------+---------+------+--------------------------------------------------------+------------------+3 rows in set (0.00 sec) 开启多线程复制1234567891011121314151617181920mysql&gt; set global slave_parallel_type=&apos;logical_clock&apos;;Query OK, 0 rows affected (0.01 sec)mysql&gt; set global slave_parallel_workers=4;Query OK, 0 rows affected (0.00 sec)mysql&gt; show processlist;+-----+-------------+-----------+------+---------+------+--------------------------------------------------------+------------------+| Id | User | Host | db | Command | Time | State | Info |+-----+-------------+-----------+------+---------+------+--------------------------------------------------------+------------------+| 104 | system user | | NULL | Connect | 6634 | executing | NULL || 107 | system user | | NULL | Connect | 19 | Slave has read all relay log; waiting for more updates | NULL || 108 | system user | | NULL | Connect | 19 | Waiting for an event from Coordinator | NULL || 109 | system user | | NULL | Connect | 6634 | Waiting for an event from Coordinator | NULL || 110 | system user | | NULL | Connect | 6634 | Waiting for an event from Coordinator | NULL || 111 | system user | | NULL | Connect | 6634 | Waiting for an event from Coordinator | NULL || 176 | root | localhost | test | Sleep | 19 | | NULL || 177 | root | localhost | NULL | Query | 0 | starting | show processlist |+-----+-------------+-----------+------+---------+------+--------------------------------------------------------+------------------+8 rows in set (0.00 sec) 线程12345678910111213141516171819202122232425262728293031323334mysql&gt; select name from performance_schema.threads order by name;+----------------------------------------------+| name |+----------------------------------------------+| thread/group_rpl/THD_applier_module_receiver || thread/group_rpl/THD_certifier_broadcast || thread/innodb/buf_dump_thread || thread/innodb/dict_stats_thread || thread/innodb/io_ibuf_thread || thread/innodb/io_log_thread || thread/innodb/io_read_thread || thread/innodb/io_read_thread || thread/innodb/io_read_thread || thread/innodb/io_read_thread || thread/innodb/io_write_thread || thread/innodb/io_write_thread || thread/innodb/io_write_thread || thread/innodb/io_write_thread || thread/innodb/page_cleaner_thread || thread/innodb/srv_error_monitor_thread || thread/innodb/srv_lock_timeout_thread || thread/innodb/srv_master_thread || thread/innodb/srv_monitor_thread || thread/innodb/srv_purge_thread || thread/innodb/srv_worker_thread || thread/innodb/srv_worker_thread || thread/innodb/srv_worker_thread || thread/sql/compress_gtid_table || thread/sql/main || thread/sql/one_connection || thread/sql/signal_handler || thread/sql/slave_sql || thread/sql/thread_timer_notifier |+----------------------------------------------+ 多主库模式 在第一台服务器上配置 12345SET GLOBAL group_replication_bootstrap_group=ON;set global group_replication_single_primary_mode=0;set global slave_preserve_commit_order = 1;START GROUP_REPLICATION;SET GLOBAL group_replication_bootstrap_group=OFF; 在另外两台服务器上配置 123set global group_replication_single_primary_mode=0;set global slave_preserve_commit_order = 1;START GROUP_REPLICATION; 状态校验 1234567891011121314151617mysql&gt; select * from performance_schema.replication_group_members;+---------------------------+--------------------------------------+------------------+-------------+--------------+| CHANNEL_NAME | MEMBER_ID | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE |+---------------------------+--------------------------------------+------------------+-------------+--------------+| group_replication_applier | 3daf3191-78a5-11ea-88da-f8bc124417c4 | qbj3-mysql-test7 | 5729 | ONLINE || group_replication_applier | f65c1f31-d0b2-11ea-a245-90b11c503899 | qbj3-mysql-test13 | 5729 | ONLINE || group_replication_applier | f72f4b43-d0b1-11ea-8ef4-c81f66f4e97a | qbj3-mysql-test8 | 5729 | ONLINE |+---------------------------+--------------------------------------+------------------+-------------+--------------+3 rows in set (0.00 sec)mysql&gt; select * from performance_schema.replication_group_member_stats;+---------------------------+---------------------+--------------------------------------+-----------------------------+----------------------------+--------------------------+--------------+| CHANNEL_NAME | VIEW_ID | MEMBER_ID | COUNT_TRANSACTIONS_IN_QUEUE | COUNT_TRANSACTIONS_CHECKED | COUNT_CONFLICTS_DETECTED | COUNT_TRANSAC|+---------------------------+---------------------+--------------------------------------+-----------------------------+----------------------------+--------------------------+--------------+| group_replication_applier | 16166521384465852:3 | 3daf3191-78a5-11ea-88da-f8bc124417c4 | 0 | 0 | 0 | |+---------------------------+---------------------+--------------------------------------+-----------------------------+----------------------------+--------------------------+--------------+1 row in set (0.00 sec) 读写测试单主模式12345678mysql&gt; show global variables like &apos;%group_replication_single_primary_mode%&apos;;+---------------------------------------+-------+| Variable_name | Value |+---------------------------------------+-------+| group_replication_single_primary_mode | ON |+---------------------------------------+-------+mysql&gt; set global group_replication_single_primary_mode=0;ERROR 3093 (HY000): Cannot change into or from single primary mode while Group Replication is running. 创建无主键的表12345mysql&gt; create table t(id int);Query OK, 0 rows affected (0.13 sec)mysql&gt; insert into t values(100);ERROR 3098 (HY000): The table does not comply with the requirements by an external plugin. 无主键表可以创建，但是不能插入数据，具体报错如上 创建有主键的表12345mysql&gt; create table gr(id int ,name varchar(10),primary key(id));Query OK, 0 rows affected (0.13 sec)mysql&gt; insert into gr values(1, &apos;test&apos;);Query OK, 1 row affected (0.03 sec) 创建唯一键的表12345678910111213141516171819202122mysql&gt; create table t(id int,unique key(id));Query OK, 0 rows affected (0.13 sec)mysql&gt; show create table t\G*************************** 1. row *************************** Table: tCreate Table: CREATE TABLE `t` ( `id` int(11) DEFAULT NULL, UNIQUE KEY `id` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb41 row in set (0.00 sec)mysql&gt; insert into t values(1);ERROR 3098 (HY000): The table does not comply with the requirements by an external plugin.mysql&gt; drop table t;Query OK, 0 rows affected (0.08 sec)mysql&gt; create table t(id int not null,unique key(id));Query OK, 0 rows affected (0.13 sec)mysql&gt; insert into t values(1);Query OK, 1 row affected (0.03 sec) 唯一键必须为非null 多主模式下插入测试使用tmux同时提交 同时insert server1 12insert into t values(11);Query OK, 1 row affected (0.03 sec) server2 12insert into t values(11);ERROR 1062 (23000): Duplicate entry &apos;11&apos; for key &apos;id&apos; server3 12insert into t values(11);ERROR 3101 (HY000): Plugin instructed the server to rollback the current transaction. 同时update server1 123begin;update t set id=100 where id=10;commit; server2 1234begin;update t set id=100 where id=10;commit;ERROR 3101 (HY000): Plugin instructed the server to rollback the current transaction. server3 1234begin;update t set id=100 where id=10;commit;ERROR 3101 (HY000): Plugin instructed the server to rollback the current transaction. 可以看到update都可以进入prepare状态，使用乐观执行的模式，但是在commit的时候会判断冲突，然后回滚。 多主自增主键测试 server1 123456789mysql&gt; show global variables like &apos;%auto_increment%&apos;;+--------------------------------------------+-----------+| Variable_name | Value |+--------------------------------------------+-----------+| auto_increment_increment | 7 || auto_increment_offset | 572911156 || group_replication_auto_increment_increment | 7 |+--------------------------------------------+-----------+insert into t values(NULL); server2 123456789mysql&gt; show global variables like &apos;%auto_increment%&apos;;+--------------------------------------------+-----------+| Variable_name | Value |+--------------------------------------------+-----------+| auto_increment_increment | 7 || auto_increment_offset | 572911203 || group_replication_auto_increment_increment | 7 |+--------------------------------------------+-----------+insert into t values(NULL); server3 123456789mysql&gt; show global variables like &apos;%auto_increment%&apos;;+--------------------------------------------+-----------+| Variable_name | Value |+--------------------------------------------+-----------+| auto_increment_increment | 7 || auto_increment_offset | 572911131 || group_replication_auto_increment_increment | 7 |+--------------------------------------------+-----------+insert into t values(NULL); auto_increment_offset(起始值)默认是使用server id值。MGR最多只支持9个，所以一般这个auto_increment_increment(步长)设置为7就够用了。 插入测试 在以上三个server先后顺序分别执行insert操作，最后t表中的数据如下： 12345678mysql&gt; select * from t;+----+| id |+----+| 4 || 9 || 14 |+----+ 使用tmux的同时执行模拟，产生的数据如下： 1234567891011121314| 16 || 18 || 21 |+----+6 rows in set (0.00 sec)mysql&gt; show create table t\G*************************** 1. row *************************** Table: tCreate Table: CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8mb41 row in set (0.00 sec) 看着并没有使用严格group_replication_auto_increment_increment递增，表象和三个客户端不同时间插入完全不同。更多关于组复制的自增参照这里 MGR 日志查看错误日志,发宣布当前Leader以及Follower 1232020-08-11T04:47:32.029858Z 84 [Note] Plugin group_replication reported: &apos;This server is working as primary member.&apos;2020-08-11T04:47:44.029189Z 69 [Note] Plugin group_replication reported: &apos;This server is working as secondary member with primary member address qbj3-mysql-test7:5729.&apos; 这里对应primary member以及secondary member。 MGR要求和限制要求基本要求 InnoDB 存储引擎，通过参数disable_storage_engines进行设置 表必须有主键，或者非null的唯一键 只支持IPv4网络 网络性能，组复制部署在服务器实例彼此非常接近的集群环境中，并受到网络延迟和网络带宽的影响。 服务器配置 开启二进制日志，指定log_bin 从库开启更新记录，log_slave_updates 二进制日志行格式，binlog_format=ROW 开启GTID 复制信息记录表，设置master_info_repository=TABLE以及relay_log_info_repository=TABLE 事务Write-Set，设置transaction_write_set_extraction=XXHASH64,write set基于每个的主键 表名设置大小写无关，lower_case_table_names=1 开启并行复制，设置slave_parallel_type=LOGICAL_CLOCK，slave_parallel_workers=N,slave_preserve_commit_order=1 限制 组复制认证不考虑Gap Locks 认证过程不考虑表锁以及命名锁 binlog-checksum=NONE 多主模式不支持序列化（SERIALIZABLE） 多主模式不支持对同一个表同时执行DDL，在同一个表并发执行DML有冲突风险但是不检测 多主模式导致死锁，例如select…for update可能会导致死锁，lock各个组成员之间不共享 Replication Filters 不支持 组成员大小限制为9，超过这个就是拒绝，为了保证网络稳定 限制事务大小，例如在sqoop批量导入的时候容易产生大事务 故障模拟停止一台实例而且还是主实例 12345678mysql&gt; select * from performance_schema.replication_group_members;+---------------------------+--------------------------------------+------------------+-------------+--------------+| CHANNEL_NAME | MEMBER_ID | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE |+---------------------------+--------------------------------------+------------------+-------------+--------------+| group_replication_applier | 3daf3191-78a5-11ea-88da-f8bc124417c4 | qbj3-mysql-test7 | 5729 | ONLINE || group_replication_applier | f65c1f31-d0b2-11ea-a245-90b11c503899 | qbj3-mysql-test13 | 5729 | ONLINE |+---------------------------+--------------------------------------+------------------+-------------+--------------+2 rows in set (0.00 sec) 1234562021-01-28T09:26:06.843045Z 0 [Warning] Plugin group_replication reported: &apos;Members removed from the group: qbj3-mysql-test8:5729&apos;2021-01-28T09:26:06.843100Z 0 [Note] Plugin group_replication reported: &apos;Primary server with address qbj3-mysql-test8:5729 left the group. Electing new Primary.&apos;2021-01-28T09:26:06.843280Z 0 [Note] Plugin group_replication reported: &apos;A new primary with address qbj3-mysql-test7:5729 was elected, enabling conflict detection until the new primary appli &apos;2021-01-28T09:26:06.851776Z 269 [Note] Plugin group_replication reported: &apos;This server is working as primary member.&apos;2021-01-28T09:26:06.851905Z 0 [Note] Plugin group_replication reported: &apos;Group membership changed to qbj3-mysql-test7:5729, qbj3-mysql-test13:5729 on view 16118256858604912:7.&apos;2021-01-28T09:26:54.444961Z 248 [Note] Plugin group_replication reported: &apos;Primary had applied all relay logs, disabled conflict detection&apos; 发生切换，选择出新的主库。 12mysql&gt; insert into t values(12);ERROR 1290 (HY000): The MySQL server is running with the --super-read-only option so it cannot execute this statement 在单主模式下切换后，有的节点是只读的。针对单主模式的访问需要区分哪个是主节点。 DDL操作12345678910111213mysql&gt; alter table t add COLUMN c int after id;Query OK, 0 rows affected (0.34 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; show create table t\G*************************** 1. row *************************** Table: tCreate Table: CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, UNIQUE KEY `id` (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb41 row in set (0.00 sec) 多主模式使用tmux同时执行DDL，不会报错，都会执行成功，但是只是执行一个DDL，符合逻辑的需求。 GTID组内所有实例使用相同的UUID用于记录GTID。 12345678910loose-group_replication_group_name=&quot;0f1ec2e6-db7f-11ea-9773-38f9d35e8343&quot;mysql&gt; show master status\G*************************** 1. row *************************** File: mysql-bin.000004 Position: 453 Binlog_Do_DB: Binlog_Ignore_DB:Executed_Gtid_Set: 0f1ec2e6-db7f-11ea-9773-38f9d35e8343:1-101299:1000009-10000141 row in set (0.00 sec) 使用组名和事务ID组成GTID，组内全局唯一。组内事务记录到binlog中是不冲突。这么做有什么好处呢？ 问题点1234567891011121314mysql&gt; select * from performance_schema.replication_group_members;+---------------------------+--------------------------------------+-----------------+-------------+--------------+| CHANNEL_NAME | MEMBER_ID | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE |+---------------------------+--------------------------------------+-----------------+-------------+--------------+| group_replication_applier | 3daf3191-78a5-11ea-88da-f8bc124417c4 | tdxy-paas-test7 | 5729 | ERROR |+---------------------------+--------------------------------------+-----------------+-------------+--------------+mysql&gt; show master status\G*************************** 1. row *************************** File: mysql-bin.000004 Position: 7970 Binlog_Do_DB: Binlog_Ignore_DB:Executed_Gtid_Set: 0f1ec2e6-db7f-11ea-9773-38f9d35e8343:1-101313:1000009-1000024:2000015-20000231 row in set (0.00 sec) 在测试的时候，遇到上面的问题，查看相关日志如下： 1234567891011122021-03-25T07:18:44.877457Z 0 [Note] Plugin group_replication reported: &apos;Group membership changed to tdxy-paas-test7:5729 on view 16166521384465852:4.&apos;2021-03-25T07:18:44.899362Z 361 [ERROR] Slave SQL for channel &apos;group_replication_applier&apos;: Worker 1 failed executing transaction &apos;0f1ec2e6-db7f-11ea-9773-38f9d35e8343:2000024&apos;; Error &apos;Duplicate column name &apos;a&apos;&apos; on query. Default database: &apos;test&apos;. Query: &apos;alter table t add column a int&apos;, Error_code: 10602021-03-25T07:18:44.899471Z 360 [ERROR] Plugin group_replication reported: &apos;The applier thread execution was aborted. Unable to process more transactions, this member will now leave the group.&apos;2021-03-25T07:18:44.899532Z 357 [ERROR] Plugin group_replication reported: &apos;Fatal error during execution on the Applier process of Group Replication. The server will now leave the group.&apos;2021-03-25T07:18:44.899592Z 357 [ERROR] Plugin group_replication reported: &apos;The server was automatically set into read only mode after an error was detected.&apos;2021-03-25T07:18:44.899823Z 360 [ERROR] Error running query, slave SQL thread aborted. Fix the problem, and restart the slave SQL thread with &quot;SLAVE START&quot;. We stopped at log &apos;FIRST&apos; position 78.2021-03-25T07:18:44.900019Z 357 [Note] Plugin group_replication reported: &apos;Going to wait for view modification&apos;2021-03-25T07:18:48.429153Z 0 [Note] Plugin group_replication reported: &apos;Group membership changed: This member has left the group.&apos;2021-03-25T07:18:48.429266Z 357 [Note] Plugin group_replication reported: &apos;The group replication applier thread was killed&apos; 问题在于执行两个alter table语句导致错误，尽管在执行的时候没有报错，但是导致MGR中的同步中断。 处理的方式是跳过这条binlog，然后再按照多主的模式重启组复制。 单主模式和多主模式切换group_replication_single_primary_mode 组复制运行时， 不能手动更改值 。在MySQL 8.0.13中，您可以使用 group_replication_switch_to_single_primary_mode() 和 group_replication_switch_to_multi_primary_mode() UDF在组复制仍在运行时将组从一种模式移至另一种模式。这些UDF管理更改组模式的过程，并确保数据的安全性和一致性。 相关参考 https://zhuanlan.zhihu.com/p/128461028 https://cloud.tencent.com/developer/article/1438724 https://codeleading.com/article/75303165534/]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDFS机架感知配置]]></title>
    <url>%2F2021-03-23-HDFS%E6%9C%BA%E6%9E%B6%E6%84%9F%E7%9F%A5%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[背景HDFS在冗余方面，考虑机架之间的冗余。三副本块存储的时候，第一个块存储离client最近的节点DN1，第二块存储在和DN1不在同一个机架上的节点DN2，第三个块存储离DN1近的节点DN3。 机架感知的配置Ambari配置 在配置参数指定一个toplogy_script.py脚本。这个python脚本内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env pythonimport sys, osfrom string import joinimport ConfigParserDEFAULT_RACK = &quot;/default-rack&quot;DATA_FILE_NAME = os.path.dirname(os.path.abspath(__file__)) + &quot;/topology_mappings.data&quot;SECTION_NAME = &quot;network_topology&quot;class TopologyScript(): def load_rack_map(self): try: #RACK_MAP contains both host name vs rack and ip vs rack mappings mappings = ConfigParser.ConfigParser() mappings.read(DATA_FILE_NAME) return dict(mappings.items(SECTION_NAME)) except ConfigParser.NoSectionError: return &#123;&#125; def get_racks(self, rack_map, args): if len(args) == 1: return DEFAULT_RACK else: return join([self.lookup_by_hostname_or_ip(input_argument, rack_map) for input_argument in args[1:]],) def lookup_by_hostname_or_ip(self, hostname_or_ip, rack_map): #try looking up by hostname rack = rack_map.get(hostname_or_ip) if rack is not None: return rack #try looking up by ip rack = rack_map.get(self.extract_ip(hostname_or_ip)) #try by localhost since hadoop could be passing in 127.0.0.1 which might not be mapped return rack if rack is not None else rack_map.get(&quot;localhost.localdomain&quot;, DEFAULT_RACK) #strips out port and slashes in case hadoop passes in something like 127.0.0.1/127.0.0.1:50010 def extract_ip(self, container_string): return container_string.split(&quot;/&quot;)[0].split(&quot;:&quot;)[0] def execute(self, args): rack_map = self.load_rack_map() rack = self.get_racks(rack_map, args) print rackif __name__ == &quot;__main__&quot;: TopologyScript().execute(sys.argv) 这个脚本核心功能是从配置文件读取机器的机架信息，通过输入IP或HostName获取机器位置信息，支持多个参数输入 topology_mappings.data文件内容如下： 123[network_topology]1.slXXX.XXX=/4F-D0810.XXX.XXX.14=/4F-D08 core-site.xml文件中配置1234&lt;property&gt; &lt;name&gt;net.topology.script.file.name&lt;/name&gt; &lt;value&gt;/etc/hadoop/conf/topology_script.py&lt;/value&gt;&lt;/property&gt; 补充分析在手册上有这么一句话 1Using either the java class or external script for topology, output must adhere to the java org.apache.hadoop.net.DNSToSwitchMapping interface 可以使用Java类或者外部脚本，输出格式需要兼容org.apache.hadoop.net.DNSToSwitchMapping接口。查看这个DNSToSwitchMapping接口，有比较多的实现，对照Ambari配置找到ScriptBasedMapping类。 12345678910111213141516@Overridepublic List&lt;String&gt; resolve(List&lt;String&gt; names) &#123; List&lt;String&gt; m = new ArrayList&lt;String&gt;(names.size()); if (names.isEmpty()) &#123; return m; &#125; if (scriptName == null) &#123; for (String name : names) &#123; m.add(NetworkTopology.DEFAULT_RACK); &#125; return m; &#125; String output = runResolveCommand(names, scriptName); 如果脚本配置文件为空，返回/default-rack。重点在runResolveCommand调用执行脚本，输出机器机架信息。 拓扑距离的算法 待补充]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[High Performance TiDB-HomeWork第一篇]]></title>
    <url>%2F2020-12-17-high-performance-tidb-1%2F</url>
    <content type="text"><![CDATA[HomeWork说明题目描述本地下载TiDB，TiKV，PD源代码，改写源代码并编译部署以下环境： 1 TiDB 1 PD 3 TiKV 改写后 使得TiDB启动事务时，会打一个“hello transaction”的日志 Mac 编译执行1234/Users/guosong/GoglandProjects/src/github.com/pingcap/tidb/tidb-server/main.go指定参数：-log-file=/tmp/tidb.log--store=tikv --path=127.0.0.1:2379 开启事务打印日志代码修改位置123456789101112131415161718func (e *SimpleExec) executeBegin(ctx context.Context, s *ast.BeginStmt) error &#123; // If BEGIN is the first statement in TxnCtx, we can reuse the existing transaction, without the // need to call NewTxn, which commits the existing transaction and begins a new one. // 如果是BEGIN是TxnCtx的第一条语句，可以复用现有事务，无需调用NewTxn txnCtx := e.ctx.GetSessionVars().TxnCtx if txnCtx.History != nil &#123; err := e.ctx.NewTxn(ctx) if err != nil &#123; return err &#125; &#125; ... //Added by Guosong START 2020-12-17 if e.ctx.GetSessionVars().ConnectionID != 0 &#123; logutil.BgLogger().Info(&quot;hello transaction in executeBegin############ by Guosong&quot;) &#125; //Added by Guosong END 2020-12-17&#125; 测试12345678mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into t values(22);Query OK, 1 row affected (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec) tidb的日志 1[2020/12/17 17:00:30.475 +08:00] [INFO] [simple.go:556] [&quot;hello transaction in executeBegin############ by Guosong&quot;] 默认提交的事务是不打的。 代码需要判断一下，否则Connection ID 0的线程一直打印： 123456[2020/12/17 17:10:33.407 +08:00] [INFO] [simple.go:556] [&quot;hello transaction in executeBegin############ by Guosong&quot;][2020/12/17 17:10:33.407 +08:00] [INFO] [simple.go:557] [ConnectionID:0][2020/12/17 17:10:36.406 +08:00] [INFO] [simple.go:556] [&quot;hello transaction in executeBegin############ by Guosong&quot;][2020/12/17 17:10:36.406 +08:00] [INFO] [simple.go:557] [ConnectionID:0][2020/12/17 17:10:36.408 +08:00] [INFO] [simple.go:556] [&quot;hello transaction in executeBegin############ by Guosong&quot;][2020/12/17 17:10:36.408 +08:00] [INFO] [simple.go:557] [ConnectionID:0] 本地测试]]></content>
      <categories>
        <category>TiDB</category>
      </categories>
      <tags>
        <tag>TiDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch选主过程]]></title>
    <url>%2F2020-01-14-Elasticsearch%E9%80%89%E4%B8%BB%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[选举的入口本代码基于Elasticsearch6.7.0版本 12345678910//入口函数 #ZenDiscovery#innerJoinCluster private void innerJoinCluster() &#123; DiscoveryNode masterNode = null; final Thread currentThread = Thread.currentThread(); nodeJoinController.startElectionContext(); //一直阻塞直到找到master节点，在集群刚刚启动合作或者master丢失的情况，这种阻塞能够保证集群一致性 while (masterNode == null &amp;&amp; joinThreadControl.joinThreadActive(currentThread)) &#123; masterNode = findMaster(); &#125; 初次启动的时候masterNode为null，需要进行findMaster。 findMaster首先ping各个候选节点(通过参数discovery.zen.ping.unicast.host进行指定) 12345private DiscoveryNode findMaster() &#123; //选举临时master logger.trace("starting to ping"); //ping所有节点 List&lt;ZenPing.PingResponse&gt; fullPingResponses = pingAndWait(pingTimeout).toList(); 这里的ping实际是调用UnicastZenPing#ping 12345678910111213141516protected void ping(final Consumer&lt;PingCollection&gt; resultsConsumer, final TimeValue scheduleDuration, final TimeValue requestDuration) &#123; final List&lt;DiscoveryNode&gt; seedNodes; try &#123; seedNodes = resolveHostsLists( unicastZenPingExecutorService, logger, configuredHosts, limitPortCounts, transportService, UNICAST_NODE_PREFIX, resolveTimeout); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; 在pingTimeout时间内收到各个ping结果之后，将本节点添加到其中： 12345678// add our selves assert fullPingResponses.stream().map(ZenPing.PingResponse::node) .filter(n -&gt; n.equals(localNode)).findAny().isPresent() == false; fullPingResponses.add(new ZenPing.PingResponse(localNode, null, this.clusterState())); // filter responses final List&lt;ZenPing.PingResponse&gt; pingResponses = filterPingResponses(fullPingResponses, masterElectionIgnoreNonMasters, logger); discovery.zen.master_election.ignore_non_master_pings设置为true的话，节点设置node.master为false的节点会被过滤掉，不能作为候选的master。 12345678910111213141516171819//将每个节点所认为的master节点加入到activeMasters列表中List&lt;DiscoveryNode&gt; activeMasters = new ArrayList&lt;&gt;();for (ZenPing.PingResponse pingResponse : pingResponses) &#123; // We can't include the local node in pingMasters list, otherwise we may up electing ourselves without // any check / verifications from other nodes in ZenDiscover#innerJoinCluster() //不包括本节点 if (pingResponse.master() != null &amp;&amp; !localNode.equals(pingResponse.master())) &#123; activeMasters.add(pingResponse.master()); &#125;&#125;// nodes discovered during pinging//存储master候选者列表List&lt;ElectMasterService.MasterCandidate&gt; masterCandidates = new ArrayList&lt;&gt;();for (ZenPing.PingResponse pingResponse : pingResponses) &#123; //只添加节点角色是master的节点 if (pingResponse.node().isMasterNode()) &#123; masterCandidates.add(new ElectMasterService.MasterCandidate(pingResponse.node(), pingResponse.getClusterStateVersion())); &#125;&#125; 如何确定候选人？1234567891011121314151617181920if (activeMasters.isEmpty()) &#123; //如果当前活跃的master列表为空，前提是候选者足够 if (electMaster.hasEnoughCandidates(masterCandidates)) &#123; //从master候选列表中选举一个新的主 final ElectMasterService.MasterCandidate winner = electMaster.electMaster(masterCandidates); logger.trace("candidate &#123;&#125; won election", winner); return winner.getNode(); &#125; else &#123; //从候选中选举新的master失败 // if we don't have enough master nodes, we bail, because there are not enough master to elect from logger.warn("not enough master nodes discovered during pinging (found [&#123;&#125;], but needed [&#123;&#125;]), pinging again", masterCandidates, electMaster.minimumMasterNodes()); return null; &#125;&#125; else &#123; assert !activeMasters.contains(localNode) : "local node should never be elected as master when other nodes indicate an active master"; // lets tie break between discovered nodes //从activeMasters中选择最合适的作为master return electMaster.tieBreakActiveMasters(activeMasters);&#125; 主要的判断在ElectMasterService类中，主要是如下两个方法： 1234567891011121314151617181920212223/** * Elects a new master out of the possible nodes, returning it. Returns &lt;tt&gt;null&lt;/tt&gt; * if no master has been elected. */public MasterCandidate electMaster(Collection&lt;MasterCandidate&gt; candidates) &#123; assert hasEnoughCandidates(candidates); List&lt;MasterCandidate&gt; sortedCandidates = new ArrayList&lt;&gt;(candidates); //通过自定义的比较函数对候选者节点从小到大排序 sortedCandidates.sort(MasterCandidate::compare); //返回最新的作为Master return sortedCandidates.get(0);&#125;/** selects the best active master to join, where multiple are discovered */public DiscoveryNode tieBreakActiveMasters(Collection&lt;DiscoveryNode&gt; activeMasters) &#123; //从已知的Master节点中选择一个最小值作为新的主 return activeMasters.stream().min(ElectMasterService::compareNodes).get();&#125;public boolean hasEnoughMasterNodes(Iterable&lt;DiscoveryNode&gt; nodes) &#123; final int count = countMasterNodes(nodes); return count &gt; 0 &amp;&amp; (minimumMasterNodes &lt; 0 || count &gt;= minimumMasterNodes);&#125; 比较函数实现如下： 1234567891011121314151617/** * compares two candidates to indicate which the a better master. * A higher cluster state version is better * * @return -1 if c1 is a batter candidate, 1 if c2. */public static int compare(MasterCandidate c1, MasterCandidate c2) &#123; // we explicitly swap c1 and c2 here. the code expects "better" is lower in a sorted // list, so if c2 has a higher cluster state version, it needs to come first. //先比较集群状态的版本号，集群状态版本号是啥？ int ret = Long.compare(c2.clusterStateVersion, c1.clusterStateVersion); //如果版本号相同，则比较节点ID,NodeId为第一次启动时随机生成 if (ret == 0) &#123; ret = compareNodes(c1.getNode(), c2.getNode()); &#125; return ret;&#125; clusterStateVersion越大，优先级越高，这是为了保证新Master拥有最新的clusterState（集群的元数据）。Master当选之后以此clusterState为基础进行更新。clusterStateVersion是long类型的版本号。 什么时候选举成功？当一个master-eligible node（Node_A）发起一次选举时，它会按照上述排序策略选出一个它认为的master。 假如Node_A选自己当master 12345678910111213141516171819202122if (transportService.getLocalNode().equals(masterNode)) &#123; final int requiredJoins = Math.max(0, electMaster.minimumMasterNodes() - 1); // we count as one logger.debug("elected as master, waiting for incoming joins ([&#123;&#125;] needed)", requiredJoins); nodeJoinController.waitToBeElectedAsMaster(requiredJoins, masterElectionWaitForJoinsTimeout, new NodeJoinController.ElectionCallback() &#123; @Override public void onElectedAsMaster(ClusterState state) &#123; synchronized (stateMutex) &#123; joinThreadControl.markThreadAsDone(currentThread); &#125; &#125; @Override public void onFailure(Throwable t) &#123; logger.trace("failed while waiting for nodes to join, rejoining", t); synchronized (stateMutex) &#123; joinThreadControl.markThreadAsDoneAndStartNew(currentThread); &#125; &#125; &#125; );&#125; 此时NodeA会等待别的node来join，即等待别的node选票，当收集超过半数（requiredJoins）的选票时，认为自己成为master，然后变更cluster_state中的master node为自己，并向集群发布这一消息。 假设Node_A选Node_B当master 123456789101112131415161718192021222324252627else &#123; // process any incoming joins (they will fail because we are not the master) nodeJoinController.stopElectionContext(masterNode + " elected"); // send join request final boolean success = joinElectedMaster(masterNode); synchronized (stateMutex) &#123; if (success) &#123; DiscoveryNode currentMasterNode = this.clusterState().getNodes().getMasterNode(); if (currentMasterNode == null) &#123; // Post 1.3.0, the master should publish a new cluster state before acking our join request. we now should have // a valid master. logger.debug("no master node is set, despite of join request completing. retrying pings."); joinThreadControl.markThreadAsDoneAndStartNew(currentThread); &#125; else if (currentMasterNode.equals(masterNode) == false) &#123; // update cluster state joinThreadControl.stopRunningThreadAndRejoin("master_switched_while_finalizing_join"); &#125; joinThreadControl.markThreadAsDone(currentThread); &#125; else &#123; // failed to join. Try again... joinThreadControl.markThreadAsDoneAndStartNew(currentThread); &#125; &#125; &#125; Node_A会向Node_B发送join请求，那么此时： 1）如果Node_B已经成为Master，Node_B就会把Node_A加入到集群中，然后发布最新的cluster_state，最新的cluster_state就包含Node_A信息。相当于一次正常情况的新节点加入。对于Node_A，等待新的cluster_state发布到Node_A的时候，Node_A也就完成join。 2）如果Node_B在竞选Master，那么Node_B会把这次join当做一张选票。对于这种情况，Node_A会等待一段时间，看Node_B是否能成为真正的Master，直到超时或者有别的master选成功。 3）如果Node_B认为自己不是master，Node_B拒绝这次加入。 选举怎么保证不脑裂？基本原则是多数派策略，通过参数discovery.zen.minimum_master_nodes来约束。 参考文档 https://zhuanlan.zhihu.com/p/34830403 https://www.jianshu.com/p/bba684897544]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-06-25_Elasticsearch各类日志解读]]></title>
    <url>%2F2019-06-25-Elasticsearch%E5%90%84%E7%B1%BB%E6%97%A5%E5%BF%97%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[Slow Log12[2020-11-11T11:52:48,899][WARN ][index.search.slowlog.query] [node-1] [cars1][0] took[9.9micros], took_millis[0], total_hits[0], types[], stats[], search_type[QUERY_THEN_FETCH], total_shards[89], source[&#123;&quot;query&quot;:&#123;&quot;bool&quot;:&#123;&quot;must&quot;:[&#123;&quot;match&quot;:&#123;&quot;content&quot;:&#123;&quot;query&quot;:&quot;full text search&quot;,&quot;operator&quot;:&quot;AND&quot;,&quot;prefix_length&quot;:0,&quot;max_expansions&quot;:50,&quot;fuzzy_transpositions&quot;:true,&quot;lenient&quot;:false,&quot;zero_terms_query&quot;:&quot;NONE&quot;,&quot;auto_generate_synonyms_phrase_query&quot;:true,&quot;boost&quot;:1.0&#125;&#125;&#125;],&quot;should&quot;:[&#123;&quot;match&quot;:&#123;&quot;content&quot;:&#123;&quot;query&quot;:&quot;Elasticsearch&quot;,&quot;operator&quot;:&quot;OR&quot;,&quot;prefix_length&quot;:0,&quot;max_expansions&quot;:50,&quot;fuzzy_transpositions&quot;:true,&quot;lenient&quot;:false,&quot;zero_terms_query&quot;:&quot;NONE&quot;,&quot;auto_generate_synonyms_phrase_query&quot;:true,&quot;boost&quot;:1.0&#125;&#125;&#125;,&#123;&quot;match&quot;:&#123;&quot;content&quot;:&#123;&quot;query&quot;:&quot;Lucene&quot;,&quot;operator&quot;:&quot;OR&quot;,&quot;prefix_length&quot;:0,&quot;max_expansions&quot;:50,&quot;fuzzy_transpositions&quot;:true,&quot;lenient&quot;:false,&quot;zero_terms_query&quot;:&quot;NONE&quot;,&quot;auto_generate_synonyms_phrase_query&quot;:true,&quot;boost&quot;:1.0&#125;&#125;&#125;],&quot;adjust_pure_negative&quot;:true,&quot;boost&quot;:1.0&#125;&#125;&#125;], id[], GC Log日志示例123456789[2020-03-17T09:08:12,670][WARN ][o.e.m.j.JvmGcMonitorService] [weixin_es_data3] [gc][old][37795][15] duration [1.2m],collections [1]/[1.3m], total [1.2m]/[3.4m], memory [28.8gb]-&gt;[27.2gb]/[29.8gb], all_pools &#123;[young] [802.5mb]-&gt;[94.4mb]/[1.1gb]&#125; &#123;[survivor] [149.7mb]-&gt;[0b]/[149.7mb]&#125; &#123;[old] [27.9gb]-&gt;[27.1gb]/[28.5gb]&#125; 解读 [gc][本次是old gc][这是第33795次 GC检查][从JVM启动至今发生的第15次GC] duration [本次检查到的GC总耗时是1.2分钟] collections [从上次检查至今总共发送1次GC]/[从上次检查至今已过去1.3分钟] total [本次检查到的GC总耗时为1.2分钟]/[从JVM启动至今发生的GC总耗时为3.4分钟] memory [GC前Heap Memory空间：28.8gb]-&gt;[GC后Heap Memory空间：27.2gb]/[Heap Memory总空间] all_pools(分代部分详情) {[young区] [GC前Memory: 802.mb]-&gt;[GC后Memory: 94.4mb]/[young区Memory总大小]} {[survivor区] [GC前Memory:149.7mb]-&gt;[GC后Memory: 0b]/[survivor区Memory总大小]} {[old区][GC前Memory: 27.9gb]-&gt; [GC后Memory: 27.1gb]/[old区Memory总大小]} 代码解读123456789101112131415161718192021222324252627282930313233343536373839 private static final String SLOW_GC_LOG_MESSAGE = "[gc][&#123;&#125;][&#123;&#125;][&#123;&#125;] duration [&#123;&#125;], collections [&#123;&#125;]/[&#123;&#125;], total [&#123;&#125;]/[&#123;&#125;], memory [&#123;&#125;]-&gt;[&#123;&#125;]/[&#123;&#125;], all_pools &#123;&#125;";static void logSlowGc( final Logger logger, final JvmMonitor.Threshold threshold, final long seq, final JvmMonitor.SlowGcEvent slowGcEvent, BiFunction&lt;JvmStats, JvmStats, String&gt; pools) &#123; final String name = slowGcEvent.currentGc.getName(); final long elapsed = slowGcEvent.elapsed; final long totalGcCollectionCount = slowGcEvent.currentGc.getCollectionCount(); final long currentGcCollectionCount = slowGcEvent.collectionCount; final TimeValue totalGcCollectionTime = slowGcEvent.currentGc.getCollectionTime(); final TimeValue currentGcCollectionTime = slowGcEvent.collectionTime; final JvmStats lastJvmStats = slowGcEvent.lastJvmStats; final JvmStats currentJvmStats = slowGcEvent.currentJvmStats; final ByteSizeValue maxHeapUsed = slowGcEvent.maxHeapUsed; switch (threshold) &#123; case WARN: if (logger.isWarnEnabled()) &#123; logger.warn( SLOW_GC_LOG_MESSAGE, name, seq, totalGcCollectionCount, currentGcCollectionTime, currentGcCollectionCount, TimeValue.timeValueMillis(elapsed), currentGcCollectionTime, totalGcCollectionTime, lastJvmStats.getMem().getHeapUsed(), currentJvmStats.getMem().getHeapUsed(), maxHeapUsed, pools.apply(lastJvmStats, currentJvmStats)); &#125; break; 123456789101112name:old/youngseq:37795totalGcCollectionCount:15currentGcCollectionTime:1.2mcollections currentGcCollectionCount:1collections elapsed:1.3mtotal currentGcCollectionTime:1.2mtotal totalGcCollectionTime:3.4mmemory lastJvmStats.getMem().getHeapUsed():28.8gbmemory currentJvmStats.getMem().getHeapUsed():27.2gbmemory maxHeapUsed:29.8gball_pools:传入的参数 pools.apply(lastJvmStats, currentJvmStats));]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-26_Innodb-Checkpoint]]></title>
    <url>%2F2019-03-26-Innodb-Checkpoint%2F</url>
    <content type="text"><![CDATA[checkpoint 作用 加速崩溃恢复 减少日志数量 checkpoint 推进1234srv_master_do_active_task - log_free_checksrv_master_do_idle_task - log_free_check Flush List Flush 在刷脏页的时候会推进 更新操作，修改页面之前 checkpoint 更新 将buffer pool Flush List中，第一个dirty page的oldest_modification(最小)作为新的Checkpoint LSN 在此之前，必须保证新的checkpoint LSN之前的dirty pages全部Flush到磁盘。 所以在Flush List Flush的时候会更新checkpoint Innodb Crash Recovery Q1: CrashRecovery的起点，Checkpoint LSN存储在何处？ Q2：InnoDB如何完成Redo日志的重做？ Q3：InnoDB如何定位哪些事务需要Rollback？ Q4：CrashRecovery需要等待Rollback完成吗？ Q5：InnoDB各版本，在CrashRecovery流程上做了哪些优化？ Q6: InnoDB各版本涉及的参数含义，已经在不同版本上的变化]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Innodb-Log相关]]></title>
    <url>%2F2019-03-24-Innodb-Log%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[前言记录Innodb的Redo和Undo的一些关键功能对应的相关代码。 主要思考 RedoLog和Binlog区别 RedoLog和Binlog如何保证一致性 RedoLog和Binlog如何保证数据不丢失 UndoLog在什么时候清理 Redo Redo刷盘机制 Undo Undo的存储 Redo LogLog Buffer 刷盘innodb_flush_log_at_trx_commit在事务提交的时候根据innodb_flush_log_at_trx_commit参数设置的不同，进行刷log buffer。 123456789101112131415161718192021222324252627282930313233/**********************************************************************//**If required, flushes the log to disk based on the value ofinnodb_flush_log_at_trx_commit. */staticvoidtrx_flush_log_if_needed_low(/*========================*/ lsn_t lsn) /*!&lt; in: lsn up to which logs are to be flushed. */&#123;#ifdef _WIN32 bool flush = true;#else bool flush = srv_unix_file_flush_method != SRV_UNIX_NOSYNC;#endif /* _WIN32 */ switch (srv_flush_log_at_trx_commit) &#123; case 2: /* Write the log but do not flush it to disk */ flush = false; /* fall through */ case 1: /* Write the log and optionally flush it to disk */ log_write_up_to(lsn, flush); return; case 0: /* Do nothing */ //设置为零的时候，此处不做什么。由master thread负责每秒进行检查 return; &#125; ut_error;&#125; Master Thread主线程根据繁忙程度每秒调用一次： 12srv_master_do_dile_taskssrv_master_do_active_tasks 123456789101112131415161718192021222324252627282930//log_free_check在用户线程也会被调用srv_master_do_idle_tasks()&#123; //检查redolog files是否有足够的可用空间 srv_main_thread_op_info = "checking free log space"; //同步刷盘 log_free_check(); /* Flush logs if needed */ //判断是否需要刷日志 //异步刷盘 srv_sync_log_buffer_in_background();&#125;主线程后台每秒刷一次，确保在设置innodb_flush_logs_at_trx_commit的时候至多只有1秒的数据丢失srv_sync_log_buffer_in_background(void)/*===================================*/&#123; time_t current_time = time(NULL); srv_main_thread_op_info = "flushing log"; if (difftime(current_time, srv_last_log_flush_time) ¦ &gt;= srv_flush_log_at_timeout) &#123; log_buffer_sync_in_background(true); srv_last_log_flush_time = current_time; srv_log_writes_and_flush++; &#125;&#125; 当然在srv_master_do_active_tasks的时候也会做上面两个操作。 用户线程检查1234567891011storage/innobase/row/row0ins.cc:done by calling log_free_check(). The reason for checking thestorage/innobase/row/row0ins.cc: log_free_check();storage/innobase/row/row0merge.cc: log_free_check();storage/innobase/row/row0purge.cc:done by calling log_free_check(). The reason for checking thestorage/innobase/row/row0purge.cc: log_free_check();storage/innobase/row/row0uins.cc:introduced where a call to log_free_check() is bypassed. */storage/innobase/row/row0umod.cc:done by calling log_free_check(). The reason for checking thestorage/innobase/row/row0umod.cc: log_free_check();storage/innobase/row/row0upd.cc: log_free_check();//master thread中storage/innobase/srv/srv0srv.cc: log_free_check(); 可以看到log_free_check的地方很多。 log_free_check实现关键1234567//判断是否需要flush log buffer 或者生成一个新的checkpointlog_free_check()&#123; if (log_sys-&gt;check_flush_or_checkpoint) &#123; log_check_margins(); &#125;&#125; 这个log_sys-&gt;check_flush_or_checkpoint啥时候为True： 1234567log_margin_checkpoint_age()&#123; //max_checkpoint_age if (log_sys-&gt;lsn - log_sys-&gt;last_checkpoint_lsn + margin &gt; log_sys-&gt;log_group_capacity) &#123; log_sys-&gt;check_flush_or_checkpoint = true; &#125;&#125; Redo Log记录的内容在数据上执行一个大的delete，通过hexdump -C查看ib_logfile 每个block记录的内容如下：1&lt;space id, page no, operation code, data&gt; Redo的逻辑日志和物理日志各表示什么呢？ InnoDB的REDO日志不完全是物理日志，包含部分逻辑意义在里面，比如插入一行记录时，MTR记录的是在一个页面中写入这条记录，包括页面号、文件号（表空间号）以及这条记录的值（包括每列信息），这样就有逻辑概念。在做REDO恢复时，需要保证这个页面是正确的、完整的，不然这个REDO就会失败，也就是依赖DOUBLEWRITE。 Redo Log在MySQL8.0上改进MySQL Performance: 8.0 re-designed REDO log &amp; ReadWrite Workloads Scalability MySQL · 引擎特性 · 庖丁解InnoDB之REDO LOG innodb_log_file_size 设置测试What is a big innodb_log_file_size? UndoUndo的功能 用户DML操作，均需要记录Undo 对于回滚的事务，Undo可用来将事务的操作全部撤销-Rollback 对于提交的事务，Undo可用来将事务产生的过期版本回收-Purge。（delete_markde的版本） 一致性多MVCC通过Undo实现 Undo在内存中的结构trx_undo_t主要结构1234567891011121314151617struct trx_undo_t&#123; //undo的类型，包括TRX_UNDO_INSERT和TRX_UNDO_UPDATE ulint type; //del_marks，只有TRX_UNDO_UPDATE才为true ibool del_marks //事务id trx_id_t trx_id; //对应的回滚段 trx_rseg_t* rseg; //在回滚段中undo log的链表 UT_LIST_NODE_T(trx_undo_t) undo_list;&#125; 回滚段rsegment123456789101112/** The transaction system central memory data structure. *///内存结构中的全局事务系统struct trx_sys_t&#123; MVCC* mvcc; //MVCC多版本的Manager //回滚段指针数组，单线程产生和销毁，没有使用锁保护 //TRX_SYS_N_RSEGS=128 trx_rseg_t* rseg_array[TRX_SYS_N_RSEGS]; //待purge的回滚段 trx_rseg_t* const pending_purge_rseg_array[TRX_SYS_N_RSEGS];&#125; 每个回滚段对象trx_rseg_t还要管理undo log信息，对应结构体是trx_undo_t，使用多个链表来维护trx_undo_t信息。 事务开启时，会专门给他指定一个回滚段，以后该事务遇到的undo log页，就从该回滚段上分配。 事务提交后，需要purge的回滚段会被放到purge队列上(purge_sys-&gt;purge_queue) Undo在外存中的存储对记录变更操作时产生undo记录，Undo记录默认被记录到系统表空间中ibdata中，但从5.6开始，也可以使用独立的Undo表空间。 123456789101112131415161718192021222324252627srv_undo_tablespaces_init()&#123; ulint undo_tablespace_ids[TRX_SYS_N_RSEGS + 1]; for (i = 0; create_new_db &amp;&amp; i &lt; n_conf_tablespaces; ++i) &#123; char name[OS_FILE_MAX_PATH]; //拼接成undo的名字 ut_snprintf( name, sizeof(name), "%s%cundo%03lu", //srv_undo_dir 可以单独设置 srv_undo_dir, OS_PATH_SEPARATOR, i + 1); /* Undo space ids start from 1. */ //从name对应的文件中读取undo seg err = srv_undo_tablespace_create( name, SRV_UNDO_TABLESPACE_SIZE_IN_PAGES); if (err != DB_SUCCESS) &#123; ib::error() &lt;&lt; "Could not create undo tablespace '" &lt;&lt; name &lt;&lt; "'."; return(err); &#125; &#125; &#125; 回滚段默认的是使用系统表空间(space=0),在5.6.3之后，可通过单独设置： 123456789101112innobase_init()&#123; if (!srv_undo_dir) &#123; srv_undo_dir = default_path; &#125; os_normalize_path(srv_undo_dir); if (strchr(srv_undo_dir, ';')) &#123; sql_print_error("syntax error in innodb_undo_directory"); DBUG_RETURN(innobase_init_abort()); &#125; &#125; 主要涉及如下几个参数: 12345innodb_trx_rseg_n_slots_debuginnodb_undo_directoryinnodb_undo_log_truncateinnodb_undo_logsinnodb_undo_tablespaces http://mysql.taobao.org/monthly/2016/07/01/ InnoDB采用回滚段的方式来维护undo log并发写入和持久化。回滚段实际上是一种Undo文件组织方式，每个回滚段又有多个undo log slot。 在MySQL8.0中，Undo情况具体参照InnoDB 事务分析-Undo Log 事务初始化事务系统对应的file page12345678910111213141516171819202122232425262728293031323334/*****************************************************************//**Creates the file page for the transaction system. This function is called onlyat the database creation, before trx_sys_init. */staticvoidtrx_sysf_create(/*============*/ mtr_t* mtr) /*!&lt; in: mtr */&#123; trx_sysf_t* sys_header; ulint slot_no; buf_block_t* block; page_t* page; ulint page_no; byte* ptr; ulint len; ut_ad(mtr); /* Note that below we first reserve the file space x-latch, and then enter the kernel: we must do it in this order to conform to the latching order rules. */ mtr_x_lock_space(TRX_SYS_SPACE, mtr); /* Create the trx sys file block in a new allocated file segment */ block = fseg_create(TRX_SYS_SPACE, 0, TRX_SYS + TRX_SYS_FSEG_HEADER, ¦ mtr); buf_block_dbg_add_level(block, SYNC_TRX_SYS_HEADER); //FSP_TRX_SYS_PAGE_NO 5 //transaction system header, in tablespace 0 ut_a(block-&gt;page.id.page_no() == TRX_SYS_PAGE_NO);&#125; transaction和undo相关的关键数据结构123456789101112131415161718192021222324252627282930313233struct trx_t&#123; //事务id trx_id_t id; //标识事务写的undo记录数量 undo_no_t undo_no; //undo log的对应space_no ulint undo_rseg_space; //事务上一条执行成功的最后一条undo记录的undo_no //语句级别回滚 trx_savept_t last_sql_stat_start; //事务所使用的回滚段 trx_rsegs_t rsegs;&#125;struct trx_rsegs_t&#123; trx_undo_ptr_t m_redo;&#125;struct trx_undo_ptr_t&#123; trx_rseg_t* rseg; //两种类型的undo //事务内的insert写入这里 //insert不需要进行purge，在commit之后直接删除 trx_undo_t* insert_undo; //事务内update、delete写入这里 //需要等待purge线程进行回收 trx_undo_t* update_undo;&#125; Purgeinnodb_max_purge_lag, 如果超过这个，所有的DML操作都会hang住。默认是关闭的 根据Undo日志，回收聚簇索引/二级索引上的被标记为删除(DEL_BIT=1),并且不会被当前活跃事务以及新事务看到的过期版本记录。Insert操作不会产生Del_Bit=1的删除项，因此purge不需要使用 insert_undo 12345678910111213srv_purge_coordinator_thread()&#123; slot = srv_reserve_slot(SRV_PURGE); //获取历史的回滚段 ulint rseg_history_len = trx_sys-&gt;rseg_history_len; do&#123; rseg_history_len = srv_do_purge( //多线程进行purge，通过参数innodb_purge_threads设置 srv_n_purge_threads, &amp;n_total_purged); &#125;while (!srv_purge_should_exit(n_total_purged));&#125;srv_do_purge真正涉及的purge函数为trx_purge 12345678910111213141516This function runs a purge batch.@return number of undo log pages handled in the batch */ulint trx_purge(/*======*/ ulint n_purge_threads, /*!&lt; in: number of purge tasks to submit to the work queue */ ulint batch_size, /*!&lt; in: the maximum number of records to purge in one batch */ bool truncate) /*!&lt; in: truncate history if true */&#123; /* Fetch the UNDO recs that need to be purged. */ n_pages_handled = trx_purge_attach_undo_recs( n_purge_threads, purge_sys, batch_size); &#125; innodb_max_purge_lag_delay 设置等待的最长时间 innodb_purge_threads 设置purge的线程数 innodb_purge_batch_size 设置每次purge，回收的事务数量 purge 过程的可见性也是通过read view来判断。 http://mysql.taobao.org/monthly/2018/03/01/https://yq.aliyun.com/articles/41050 purge线程的创建123456789101112131415161718192021222324252627//通过这个全局变量管理/** The global data structure coordinating a purge */ trx_purge_t* purge_sys = NULL;innobase_start_or_create_for_mysql()&#123; /* The purge system needs to create the purge view and therefore requires that the trx_sys is inited. */ //purge需要purge view，因此需要trx_sys先被初始化 trx_purge_sys_create(srv_n_purge_threads, purge_queue); //创建purge线程 os_thread_create( srv_purge_coordinator_thread, NULL, thread_ids + 5 + SRV_MAX_N_IO_THREADS); ut_a(UT_ARR_SIZE(thread_ids) ¦ &gt; 5 + srv_n_purge_threads + SRV_MAX_N_IO_THREADS); /* We've already created the purge coordinator thread above. */ for (i = 1; i &lt; srv_n_purge_threads; ++i) &#123; os_thread_create( srv_worker_thread, NULL, thread_ids + 5 + i + SRV_MAX_N_IO_THREADS); &#125; srv_start_wait_for_purge_to_start();&#125; MTR(Mini-Transaction) 如何使用MTR实现原子性操作？ 一个逻辑事务是由多个物理事务组成，用来保证数据库的ACID特性，物理事务可以保证一次物理修改是完整的。所谓一次物理修改，可以理解为一个底层的相对完整的写入操作，比如插入一条记录的过程中，会包括写一条回滚记录以及插入时写入一个页面等，那么这些逻辑上是一个动作的物理写入，可以被认为是一个独立的物理事务，就是在写回滚记录时执行mtr_start,写完成之后执行mtr_commit，真正插入时写入一个页面也是同样的道理。 MTR提交，物理事务的提交主要是将所有这个物理事务产生的日志写入到InnoDB日志系统的日志缓冲区中，然后等待srv_master_thread线程定时将日志系统的日志缓冲区中的日志数据刷新到日志文件中，这会涉及日志刷盘时机的问题。 【InnoDB源码分析】Redo log MTR代表着整个数据库最新的LSN值 1234567---LOG---Log sequence number 7710318Log flushed up to 7710318Pages flushed up to 7710318Last checkpoint at 7710309 如何确认一个物理事务的完整性？在日志最后再写一些特殊的日志，这些特殊的日志就是一个物理事务结束的标志，提交时一起将这些特殊的日志写入，在重做时如果当前这一批日志信息最后面存在这个标志，则说明这些日志是完整的，否则就是不完整的，就不会重做。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Innodb-buffer-pool结构]]></title>
    <url>%2F2019-03-24-Innodb-buffer-pool%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[InnoDB架构图官方文档中的图描述InnoDB在内存中以及磁盘上的主要结构。核心组件包括Buffer Pool、Change Buffer、Log Buffer、System Tablespace、DoubleWrite、Undo Tablespaces、Redo Log、独立表空间等。 BufferPool启动123456789buf_pool_initinnobase_start_or_create_for_mysqlinnobase_initha_initialize_handlertonplugin_initializeplugin_register_builtin_and_init_core_seinit_server_componentsmysqld_mainmain buf_pool_init关键 1234567891011121314151617181920212223242526/*Creates the buffer pool.*/dberr_tbuf_pool_init( ulint total_size, //innodb_buffer_pool_size总大小 ulint n_instances) //innodb_buffer_pool_instances参数&#123; const ulint size = total_size / n_instances; //创建n_instances buffer_pool对应的指针 buf_pool_ptr = (buf_pool_t*) ut_zalloc_nokey( n_instances * sizeof *buf_pool_ptr); for (i = 0; i &lt; n_instances; i++) &#123; //每个buffer_pool通过结构体buf_pool_t来管理 buf_pool_t* ptr = &amp;buf_pool_ptr[i]; //初始化每个instance if (buf_pool_init_instance(ptr, size, i) != DB_SUCCESS) &#123; buf_pool_free(i); return(DB_ERROR); &#125; &#125; buf_pool_set_sizes(); buf_LRU_old_ratio_update(100 * 3/ 8, FALSE); btr_search_sys_create(buf_pool_get_curr_size() / sizeof(void*) / 64); return(DB_SUCCESS);&#125; buf_pool_t关键成员 12345678BufPoolMutex mutex; /*Buffer pool mutex of this instance*/ulint curr_pool_size; /*!&lt; Current pool size in bytes */ulint LRU_old_ratio; /*old blocks占比*/buf_chunk_t* chunks; /*!&lt; buffer pool chunks */UT_LIST_BASE_NODE_T(buf_page_t) free; //空闲页，使用一个list串联起来UT_LIST_BASE_NODE_T(buf_page_t) LRU; //LRU页buf_page_t* LRU_old; //old页起始位置UT_LIST_BASE_NODE_T(buf_page_t) flush_list; //脏页list 主要部分如下： mutex：主要用来保护这个Buffer Pool实例，一个实例之由一个线程来操作 chunks：指向这个Buffer Pool实例中第一个真正内存页面的首地址，页面都是连续，通过这个指针可以直接访问所有的其他页面 free: 用来存储这个实例中所有空闲的页面 flush_list：用来存储所有被修改过且需要刷到文件中的页面 LRU：用来存储内存中的页面，LRU_old表示old页起始位置 Chunk和Page关系上图来自Exploring Innodb engine。 通常一个chunk为128MB，一个page为16KB，一个chunk包括8192个页面。InnoDB在Resize操作的时候是依赖chunk进行的。 https://developer.aliyun.com/article/700436?spm=a2c6h.13262185.0.0.6fd97667dUWnre Buffer Pool如何动态Resize参考 MySQL Buffer Management]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-03-24_Innodb-刷脏页原理]]></title>
    <url>%2F2019-03-24-Innodb-%E5%88%B7%E8%84%8F%E9%A1%B5%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[背景Innodb刷脏页的两个目的： 加快崩溃恢复(checkpoint)，已经刷到磁盘上的页面在做redo的时候其LSN小于checkpoint，因此不需要重做 增加内存可用的buffer数量，脏页是不能被重用的,只有被刷到磁盘上，才可用被使用。 针对这两个目的操作涉及两个List： 目的1：Flush List Flush 目的2：LRU List Flush 脏页结构Innodb Buffer Pool通过维护Flush List链表将所有脏页管理起来，并按照oldest_modification升序排列，按照这个顺序刷脏页。 用户线程触发需要读取一个页面时，先根据space_id和page_no找到对应的buffer pool insance,然后根据page_hash查询其页面是否在内存中，如果没有，则表示需要从磁盘中读取。在读取前需要分配一个空闲block。当free List上没有空闲的block，会从LUR链表上flush 一个页面替换使用。 参考函数buf_LRU_scan_and_free_block（5.6.27） 123buf_LRU_get_free_block() buf_flush_single_page_from_LRU(buf_pool) buf_flush_page(buf_pool, bpage, BUF_FLUSH_SINGLE_PAGE, true) 单个Page Cleaner线程(5.6.27版本)Page cleaner线程针对LRU List和Flush List都会有定时任务操作 12345678910111213141516171819202122232425262728293031buf_flush_page_cleaner_thread()&#123; while (srv_shutdown_state == SRV_SHUTDOWN_NONE) &#123; //server空闲的时候或者没有IOs操作的时候跳过sleep if(srv_check_activity(last_activity) || buf_get_n_pending_read_ios() || n_flushed==0)&#123;//当前没有脏页可刷，则进入sleep // 大概sleep 1秒 page_cleaner_sleep_if_needed(next_loop_time); &#125; // 当server 处于active状态时候 if (srv_check_activity(last_activity))&#123; /* Flush pages from end of LRU if required */ n_flushed = buf_flush_LRU_tail(); /* Flush pages from flush_list if required */ n_flushed += page_cleaner_flush_pages_if_needed(); &#125;else&#123; //根据innodb_io_capacity全量刷 //PCT_IO(5)，表示innodb_io_capacity的5%值 n_flushed = page_cleaner_do_flush_batch( PCT_IO(100),LSN_MAX); &#125; &#125; do&#123; //当shutdown处于cleanup状态下，持续全量刷 n_flushed = page_cleaner_do_flush_batch(PCT_IO(100), LSN_MAX); &#125;while (srv_shutdown_state == SRV_SHUTDOWN_CLEANUP);&#125; 主要包含三个函数: buf_flush_LRU_tail: 从LRU维护flush脏页 page_cleaner_flush_pages_if_needed: 从Flush List flush脏页 page_cleaner_do_flush_batch buf_flush_LRU_tail1234567891011121314151617181920212223242526272829303132333435363738ulint buf_flush_LRU_tail(void)&#123; ulint total_flushed = 0; //遍历各个buffer pool instance for (ulint i=0; i&lt;srv_buf_pool_instances; i++)&#123; //获取当前buffer pool指针 buf_pool_t* buf_pool = buf_pool_from_array(i); //获取buffer pool中LRU链表的长度 scan_depth = UT_LIST_GET_LEN(buf_pool-&gt;LRU); //取参数innodb_lru_scan_depth和当前lru页面数两者最小值 scan_depth = ut_min(srv_LRU_scan_depth, scan_depth); //将LRU flush 分为多个小chunks，chunk size为100 //避免用户线程在buf_LRU_get_free_block()中等待刷新完成 //因为需要需要等待buffer pool mutex，flush操作由mutex进行保护的 for (ulint j=0; j&lt;scan_depth; j += PAGE_CLEANER_LRU_BATCH_CHUNK_SIZE)&#123; //buf_flush_LRU，刷脏页并将其加入到free list中 if (buf_flush_LRU(buf_pool, PAGE_CLEANER_LRU_BATCH_CHUNK_SIZE, &amp;n_flushed)) &#123; //等待刷脏页结束 buf_flush_wait_batch_end( buf_pool, BUF_FLUSH_LRU); &#125; if(n_flushed)&#123; total_flushed += n_flushed &#125;else&#123; //没有脏页可刷退出 break; &#125; &#125; &#125;&#125; Flush List Flush策略1234567891011121314151617181920212223242526272829303132333435363738394041//page_cleaner线程几乎每秒调用一次ulint page_cleaner_flush_pages_if_needed(void)&#123; //当前lsn cur_lsn = log_get_lsn(); if(prev_lsn == cur_lsn)&#123; //没有新的lsn产生 return(0); &#125; //和参数innodb_flushing_avg_loops有关的优化，这里暂时省略 //获取buffer pool中最老的页面对应的lsn //每个buffer pool中flush list最后一个page对应的首次修改时间lsn oldest_lsn = buf_pool_get_oldest_modification(); //判断lsn的age age = cur_lsn &gt; oldest_lsn ? cur_lsn - oldest_lsn : 0; //获取脏页的比例，和参数innodb_max_dirty_pages_pct[lwm]有关 pct_for_dirty = af_get_pct_for_dirty(); //redo log产生速度的比例 //前提是开启自适应flush策略,innodb_adaptive_flushing为ON //和参数innodb_adaptive_flushing_lwm、innodb_io_capacity有关 pct_for_lsn = af_get_pct_for_lsn(age); //选择两个比例的最大值 pct_total = ut_max(pct_for_dirty, pct_for_lsn); //计算出需要刷新的页面数量 n_pages = (PCT_IO(pct_total) + avg_page_rate) / 2; //最多每次只flush这么多(和innodb_io_capacity_max有关) if (n_pages &gt; srv_max_io_capacity) &#123; n_pages = srv_max_io_capacity; &#125; //根据上面算出需要刷新的页面数量之后再进行批量刷新 n_pages = page_cleaner_do_flush_batch( n_pages, oldest_lsn + lsn_avg_rate * (age_factor + 1));&#125; af_get_pct_for_dirty1234567891011121314151617181920212223242526272829static ulint af_get_pct_for_dirty()&#123; //ratio = (100 * flush_list_len) / (1 + lru_len + free_len); ulint dirty_pct = buf_get_modified_ratio_pct(); if (dirty_pct &gt; 0 &amp;&amp; srv_max_buf_pool_modified_pct == 0) &#123; return(100); &#125; //低水位设置为参数innodb_max_dirty_pages_pct_lwm if (srv_max_dirty_pages_pct_lwm == 0) &#123; /* The user has not set the option to preflush dirty pages as we approach the high water mark. */ //srv_max_buf_pool_modified_pct和innodb_max_dirty_pages_pct参数有关 //如果脏页数量超过设置buffer pool总数量75%的高水位， if (dirty_pct &gt; srv_max_buf_pool_modified_pct) &#123; /* We have crossed the high water mark of dirty pages In this case we start flushing at 100% of innodb_io_capacity. */ return(100); &#125; &#125; else if (dirty_pct &gt; srv_max_dirty_pages_pct_lwm) &#123; /* We should start flushing pages gradually. */ //鉴于低水位和高水位之间 return((dirty_pct * 100) / (srv_max_buf_pool_modified_pct + 1)); &#125; return(0);&#125; af_get_pct_for_lsn此函数涉及到redo_log以及checkpoint，故重点介绍一下。 12345678910111213141516171819202122232425//基于redo log产生的比率计算是否进行flush脏页ulint af_get_pct_for_lsn(lsn_t age)&#123; //innodb_adaptive_flushing_lwm,触发flush的低水位 lsn_t af_lwm = (srv_adaptive_flushing_lwm * //innodb_log_file_size以及innodb_log_files_in_group的90% log_get_capacity())/100 //最大修改lsn age max_async_age = log_get_max_modified_age_async(); //如果没有超过最大修改lsn_age，也不做flush if(age &lt; max_async_age &amp;&amp; !srv_adaptive_flushing)&#123; return(0); &#125; //如果超过这个，计算lsn修改age因子 lsn_age_factor = (age * 100) / max_async_age; ut_ad(srv_max_io_capacity &gt;= srv_io_capacity); //innodb_io_capacity_max(2000)和innodb_io_capacity(50) //再和这个age因子结合计算出这个lsn比例 return(static_cast&lt;ulint&gt;( ((srv_max_io_capacity / srv_io_capacity) * (lsn_age_factor * sqrt((double)lsn_age_factor))) / 7.5));&#125; checkpoint涉及的几个参数12345678910log_sys-&gt;log_group_capacity = smallest_capacity;log_sys-&gt;max_modified_age_async = margin - margin / LOG_POOL_PREFLUSH_RATIO_ASYNC;log_sys-&gt;max_modified_age_sync = margin - margin / LOG_POOL_PREFLUSH_RATIO_SYNC;log_sys-&gt;max_checkpoint_age_async = margin - margin / LOG_POOL_CHECKPOINT_RATIO_ASYNC;log_sys-&gt;max_checkpoint_age = margin; page_cleaner_do_flush_batch在server是ACTIVE和IDLE情况，除了每次刷新不同的页面数量外，都是调用下面函数完成Flush List的刷脏页操作。page_cleaner_do_flush_batch 函数是buf_flush_list的封装。 123456789101112131415161718192021222324buf_flush_list(n_to_flush, lsn_limit, &amp;n_flushed);bool buf_flush_list( ulint min_n, //需要flush page的最小数量 //BUF_FLUSH_LIST所有block的oldest_modification要小于lsn_limit lsn_t lsn_limit, //flush的页面计数 ulint *n_processed )&#123; /* Flush to lsn_limit in all buffer pool instances */ //所有buffer pool instance都flush到lsn_limit for (i = 0; i &lt; srv_buf_pool_instances; i++) &#123; //获取buf_pool指针 buf_pool = buf_pool_from_array(i); //通过min_n和lsn_limit获取到最小的flush页面数量 page_count = buf_flush_batch( buf_pool, BUF_FLUSH_LIST, min_n, lsn_limit); //刷页面操作，第一个参数类型，包括BUF_LRU_LIST buf_flush_common(BUF_FLUSH_LIST, page_count); &#125;&#125; buf_flush_batchbuf_flush_t支持三种类型: 12345678910111213141516171819202122232425262728293031/** Flags for flush types */enum buf_flush_t &#123; BUF_FLUSH_LRU = 0, /*!&lt; flush via the LRU list */ BUF_FLUSH_LIST, /*!&lt; flush via the flush list of dirty blocks */ BUF_FLUSH_SINGLE_PAGE, /*!&lt; flush via the LRU list but only a single page */ BUF_FLUSH_N_TYPES /*!&lt; index of last element + 1 */&#125;;ulint buf_flush_batch( buf_pool_t* buf_pool, //buffer pool instance buf_flush_t flush_type, //list类型， ulint min_n, lsn_t lsn_limit )&#123; //只负责处理多个页面的flush switch(flush_type)&#123; case BUF_FLUSH_LRU: //LRU List Flush策略,先从LRU_zip上，再从LRU上 count = buf_do_LRU_batch(buf_pool, min_n); break; case BUF_FLUSH_LIST: //FLush List Flush策略 count = buf_do_flush_list_batch(buf_pool, min_n, lsn_limit); break; defaut: ut_error; &#125;&#125; LRU Flush策略LRU Flush的时候会先从LRU unzip List找是否有页面可以flush，如果flush的数量不够，再从LRU上flush，这里重点说明从LRU List flush的过程。 12345678910111213141516171819202122232425262728293031323334353637383940ulint buf_flush_LRU_list_batch( buf_pool_t* buf_pool, ulint max)&#123; //free list的长度 ulint free_len = UT_LIST_GET_LEN(buf_pool-&gt;free); //lru list的长度 ulint lru_len = UT_LIST_GET_LEN(buf_pool-&gt;LRU); //获取LRU链表的尾部 bpage = UT_LIST_GET_LAST(buf_pool-&gt;LRU); //重点说明free_len&lt;innodb_lru_scan_depth=1024 //说明只有在free不足的情况下才进行flush LRU list while（bpage != NULL &amp;&amp; count&lt;max &amp;&amp; free_len&lt;srv_LRU_scan_depth &amp;&amp; lru_len &gt; BUF_LRU_MIN_LEN)&#123; //判断当前页面是否适合替换出去 //判断原则：oldest_modification==0 &amp;&amp; buf_fix_count==0 //还有io_fix==BUF_IO_NONE evict = buf_flush_ready_for_replace(bpage); if(evict)&#123; //这里做了简化说明，释放页面，遍历下一个page buf_LRU_free_page(bpage, true) bpage = UT_LIST_GET_LAST(buf_pool-&gt;LRU); &#125;else&#123; //找邻居页面进行替换 &#125; //重新计算两个list的长度 free_len = UT_LIST_GET_LEN(buf_pool-&gt;free); lru_len = UT_LIST_GET_LEN(buf_pool-&gt;LRU); &#125;&#125; Flush List Flush策略1234567891011121314151617181920212223242526ulint buf_do_flush_list_batch( buf_pool_t* buf_pool, ulint min_n, lsn_t lsn_limit)&#123; //当前脏页的数量 ulint len = UT_LIST_GET_LEN(buf_pool-&gt;flush_list); //从flush list的尾部进行遍历 //判断bpage的oldest_modification，首次修改时间 for (buf_page_t* bpage = UT_LIST_GET_LAST(buf_pool-&gt;flush_list); ount &lt; min_n &amp;&amp; bpage != NULL &amp;&amp; len &gt; 0 &amp;&amp; bpage-&gt;oldest_modification &lt; lsn_limit; ++scanned) &#123; //当前页面会被加到free list，故先保存prev指针用于循环遍历 prev = UT_LIST_GET_PREV(list, bpage); //判断当前页面是否适合flush，如果适合的话，flush并尝试flush它的邻居 //也是调用buf_flush_ready_for_flush(bpage, flush_type)进行判断 //基本规则是没有latch，也没有pin buf_flush_page_and_try_neighbors( bpage, BUF_FLUSH_LIST, min_n, &amp;count); &#125;&#125; 多个Page Cleaner线程(5.7.17版本)Page cleaner并未和buffer pool绑定，其模型为一个协调线程+多个工作线程，协调线程本身也是工作线程。innodb_page_cleaners设置为4，那么就是一个协调线程，3个工作线程，工作方式为生产者-消费者。工作队列长度为buffer pool instance的个数，使用一个全局的slot数组表示。 初始化多线程12345678910111213innodb_init -&gt; innobase_start_or_create_for_mysql(void)&#123; buf_flush_page_cleaner_init(); //page cleaner线程的协作者 os_thread_create(buf_flush_page_cleaner_coordinator, NULL, NULL); //page cleaner线程的工作者，具体数量可以通过innodb_page_cleaners参数设置 for (i = 1; i &lt; srv_n_page_cleaners; ++i) &#123; os_thread_create(buf_flush_page_cleaner_worker, NULL, NULL); &#125;&#125; buf_flush_page_cleaner_coordinator协调线程在决定了需要flush的page数和lsn_limit后，会设置slot数组，将其中每个slot的状态设置为PAGE_CLEANER_STATE_REQUESTED, 并设置目标page数及lsn_limit，然后唤醒工作线程 (pc_request) buf_flush_page_cleaner_workerworker的基本工作和5.6版本应该差不多。 参考资料 http://mysql.taobao.org/monthly/2015/02/01/]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-23_Innodb-MVCC]]></title>
    <url>%2F2019-03-23-Innodb-MVCC%2F</url>
    <content type="text"><![CDATA[前言MVCC是Innodb实现高并发一种方式，对快照读不加锁，直接利用MVCC读取指定版本的数据。 Innodb行隐藏列Innodb数据行的结构，除了自身的信息外，还额外包括三个结构DB_TRX_ID、DB_ROLL_PTR以及DB_ROW_ID。 DB_TRX_ID：表示最近修改该行数据的事务IDDB_ROLL_PTR：表是该行回滚段的指针，该行上所有旧的版本，在undo中通过链表的方式组织，而该值，正式指向undo中该行的历史记录链表。 整个MVCC的关键是通过DB_TRX_ID和DB_ROLL_PTR这两个隐藏列来实现的。 事务链表Innodb事务通过trx_sys这个全局变量进行管理，有当前活跃事务的list。 MySQL中的事务在开始到提交这段过程中，都会被保存trx_sys的事务链表中。 Read View ReadView 中的low_limit_id、up_limit_id以及trx_ids如何初始化的？ 可见性判断？ 在5.7中是storage/innobase/include/read0types.h中定义ReadView类 在5.6中是结构体read_view_t 在RC模式下，事务中的每一条SQL都创建一个ReadView，在RR模式下，事务开始的时候创建一个ReadView，直到事务结束。 ha_innobase::index_read-&gt;row_search_mvcc 参考http://mysql.taobao.org/monthly/2018/11/04/]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-22_Innodb-Change-Buffer]]></title>
    <url>%2F2019-03-22-Innodb-Change-Buffer%2F</url>
    <content type="text"><![CDATA[Innodb Change Buffer在写操作的时候， 随机IO是存储引擎设计挑战之一。在Innodb中，一个表包括一个聚簇索引，0个或者多个辅助索引。每个索引都是B-Tree结构，当一条记录插入到表中的时候，该记录首先进行聚簇索引插入的操作，然后再进行辅助索引的插入操作，所以其对应的IO操作是随机分布在磁盘上的。 随机IO会带来性能问题，为了缓和这一问题，Innodb存储引擎设计一种特别的数据结构-change buffer。（5.5版本之前叫insert buffer，5.5版本以及其以后版本，支持Delete\Update操作的缓存，故修改为change buffer）。 9大问题总结change buffer支持哪些操作类型?只是针对辅助索引的，对于非唯一索引支持INSERT、UPDATE、DELETE，对于唯一索引只支持DELETE。还有一个前提是索引修改对应的页不在Buffer Pool中。 change buffer有哪些好处？缓存那些不在buffer pool中的二级索引页面操作可以避免从磁盘加载索引页到内存中的随机IO操作。当涉及的索引被加载到内存中时，change buffer会被merge。 change buffer是否支持其他类型的索引？只支持辅助索引，聚簇索引、全文索引、空间索引都不支持。 change buffer使用多大的空间？change buffer的最大空间通过innodb_change_buffer_max_size进行设定，默认是25%，最大可以是50%。change buffer对应的page不需要持序在buffer pool中，可能会LRU操作替换出去。 12345678mysql&gt; show global variables like &apos;%change_buffer%&apos;;+-------------------------------+-------+| Variable_name | Value |+-------------------------------+-------+| innodb_change_buffer_max_size | 25 || innodb_change_buffering | all || innodb_change_buffering_debug | 0 |+-------------------------------+-------+ 如何获取当前change buffer的大小?通过show engine innodb status可以获取到。 12345678-------------------------------------INSERT BUFFER AND ADAPTIVE HASH INDEX-------------------------------------Ibuf: size 1, free list len 258, seg size 260, 0 mergesmerged operations: insert 0, delete mark 0, delete 0discarded operations: insert 0, delete mark 0, delete 0 size表示change buffer使用到的页面数量，seg size表示change buffer的大小。 1size = seg size - (1+free list len) change buffer 何时发生merge操作？ 当页面被读取到buffer pool中，在页面可用之前，会进行merge操作。 主线程后台有任务进行定时操作，参数innodb_io_capacity可以设置每次merge的页面数量 在崩溃恢复的时候，从系统表空间里面回访这些change，然后再将对应的页面加载到buffer pool中。 在innodb-fast-shutdow=0的时候会进行merge。 change buffer何时会flushed？和buffer pool一样的flush机制，change buffer占内存比较大，需要进行flush。 change buffer的选择时机？如果比较少涉及到辅助索引操作时候，可以关闭change buffer。或者磁盘性能能保证随机IO和顺序IO一样的话，也可以关闭change buffer。当然在设置之前需要进行测试。 如何获取额外的change buffer信息？1234567891011121314151617181920212223242526272829303132333435mysql&gt; SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE -&gt; WHERE PAGE_TYPE LIKE 'IBUF%') AS change_buffer_pages, -&gt; (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE) AS total_pages, -&gt; (SELECT ((change_buffer_pages/total_pages)*100)) -&gt; AS change_buffer_page_percentage;+---------------------+-------------+-------------------------------+| change_buffer_pages | total_pages | change_buffer_page_percentage |+---------------------+-------------+-------------------------------+| 3 | 8191 | 0.0366 |+---------------------+-------------+-------------------------------+mysql&gt; SELECT NAME, COMMENT,COUNT FROM INFORMATION_SCHEMA.INNODB_METRICS WHERE NAME LIKE '%ibuf%';+-----------------------------------------+-------------------------------------------------------------+-------+| NAME | COMMENT | COUNT |+-----------------------------------------+-------------------------------------------------------------+-------+| buffer_page_read_index_ibuf_leaf | Number of Insert Buffer Index Leaf Pages read | 0 || buffer_page_read_index_ibuf_non_leaf | Number of Insert Buffer Index Non-Leaf Pages read | 0 || buffer_page_read_ibuf_free_list | Number of Insert Buffer Free List Pages read | 0 || buffer_page_read_ibuf_bitmap | Number of Insert Buffer Bitmap Pages read | 0 || buffer_page_written_index_ibuf_leaf | Number of Insert Buffer Index Leaf Pages written | 0 || buffer_page_written_index_ibuf_non_leaf | Number of Insert Buffer Index Non-Leaf Pages written | 0 || buffer_page_written_ibuf_free_list | Number of Insert Buffer Free List Pages written | 0 || buffer_page_written_ibuf_bitmap | Number of Insert Buffer Bitmap Pages written | 0 || ibuf_merges_insert | Number of inserted records merged by change buffering | 0 || ibuf_merges_delete_mark | Number of deleted records merged by change buffering | 0 || ibuf_merges_delete | Number of purge records merged by change buffering | 0 || ibuf_merges_discard_insert | Number of insert merged operations discarded | 0 || ibuf_merges_discard_delete_mark | Number of deleted merged operations discarded | 0 || ibuf_merges_discard_delete | Number of purge merged operations discarded | 0 || ibuf_merges | Number of change buffer merges | 0 || ibuf_size | Change buffer size in pages | 1 || innodb_ibuf_merge_usec | Time (in microseconds) spent to process change buffer merge | 0 |+-----------------------------------------+-------------------------------------------------------------+-------+17 rows in set (0.00 sec) 更多参照文档 内核层次分析ibuf的初始化change buffer本身也是B-Tree结构，其持久化在系统表空间中。change buffer的root页固定在系统表空间(space_id=0)的第4个页面(FSP_IBUF_TREE_ROOT_PAGE_NO)，其初始化函数为ibuf_init_at_db_start。 其调用链条为： 1234ibuf_init_at_db_startdict_bootinnobase_start_or_create_for_mysqlinnobase_init 其中innobase_init(handler/ha_innodb.cc)是在存储引擎定义的时候设置： 12345678910111213141516mysql_declare_plugin(innobase)&#123; MYSQL_STORAGE_ENGINE_PLUGIN, &amp;innobase_storage_engine, innobase_hton_name, plugin_author, "Supports transactions, row-level locking, and foreign keys", PLUGIN_LICENSE_GPL, innobase_init, /* Plugin Init */ NULL, /* Plugin Deinit */ INNODB_VERSION_SHORT, innodb_status_variables_export,/* status variables */ innobase_system_variables, /* system variables */ NULL, /* reserved */ 0, /* flags */&#125;, 重点看看ibuf_init_at_db_start实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172struct ibuf_t&#123; //当前ibuf大小 ulint size; //ibuf的max_size ulint max_size; //ibuf header和tree对应的分配页面多少 ulint seg_size; //ibuf tree是否为空 bool empty; //free list长度 ulint free_list_len; //ibuf tree的高度 ulint height; //insert buffer index(最关键的结构) dict_index_t *index; //ibuf merged的pages数量 ulint n_merges; //ibuf三个类型各个页面的merged操作数 ulint n_merged_ops[IBUF_OP_COUNT]; //由于索引或表被删除之后丢弃的操作数 ulint n_discarded_ops[IBUF_OP_COUNT];&#125;;void ibuf_init_at_db_start(void)&#123; //对应的数据结构为ibuf_t ibuf = static_cast&lt;ibuf_t*&gt;(mem_zalloc(sizeof(ibuf_t))); //ibuf最大size，和参数innodb_change_buffer_max_size有关 ibuf-&gt;max_size = ((buf_pool_get_curr_size() / UNIV_PAGE_SIZE) * CHANGE_BUFFER_DEFAULT_SIZE) / 100; //通过min-transaction保证原子性？？ mtr_start(&amp;mtr); //有单独的mutex进行保护 mutex_enter(&amp;ibuf_mutex); //获取IBUF_SPACE_ID=0的latch(对页面的保护) mtr_x_lock(fil_space_get_latch(IBUF_SPACE_ID, NULL), &amp;mtr); //page header存储位置 //对应space_id=0 page_no=3的页面 header_page = ibuf_header_page_get(&amp;mtr); //page root初始化 //page都通过block(page_header进行管理) &#123; buf_block_t* block; //space=0，page_no=4 //FSP_IBUF_TREE_ROOT_PAGE_NO=4 block = buf_page_get( IBUF_SPACE_ID, 0, FSP_IBUF_TREE_ROOT_PAGE_NO, RW_X_LATCH, &amp;mtr); root = buf_block_get_frame(block); &#125; /* Use old-style record format for the insert buffer. */ //初始化系统表空间的ibuf部分？ //IBUF_TABLE_NAME为SYS_IBUF_TABLE，ibuf表名字,该系统表实现了insert buffer的管理功能 table = dict_mem_table_create(IBUF_TABLE_NAME, IBUF_SPACE_ID, 1, 0, 0); //创建index index = dict_mem_index_create( IBUF_TABLE_NAME, "CLUST_IND", IBUF_SPACE_ID, DICT_CLUSTERED | DICT_UNIVERSAL | DICT_IBUF, 1); //ibuf-&gt;index作用是啥？ //insert buffer index ibuf-&gt;index = dict_table_get_first_index(table);&#125; ibuf操作的三种类型:Change buffer主要是针对非唯一辅助索引的。Innodb buffer操作的三种类型：insert、delete marking、delete。疑问：Innodb是标记删除，那个这个delete是啥？这里没有UPDATE？ 12345678910/* Possible operations buffered in the insert/whatever buffer. Seeibuf_insert(). DO NOT CHANGE THE VALUES OF THESE, THEY ARE STORED ON DISK. */typedef enum &#123; IBUF_OP_INSERT = 0, IBUF_OP_DELETE_MARK = 1, IBUF_OP_DELETE = 2, /* Number of different operation types. */ IBUF_OP_COUNT = 3&#125; ibuf_op_t; 记住一点change buffer是面向叶页面(leaf page)。为什么引起叶页面分裂的话，就不进行ibuf操作呢？ 使用bitmap page管理页面的空余空间，来判断是否进行change buffer操作。 purgechange buffer内存占用最大是buffer pool的25%。为了保证change buffer的恢复能在较短时间内完成，change buffer pages也会由dirty page flush操作写回磁盘。在系统崩溃时，就能保证change buffer(SYS_IBUF_TABLE)快速恢复。 merge主线程的中每秒都调用后台任务 123456789101112131415161718srv_master_thread()&#123; //SRV_SHUTDOWN_NONE 表示MySQL正在运行 while (srv_shutdown_state == SRV_SHUTDOWN_NONE) &#123; //sleep 1秒 srv_master_sleep(); MONITOR_INC(MONITOR_MASTER_THREAD_SLEEP); if (srv_check_activity(old_activity_count)) &#123; old_activity_count = srv_get_activity_count(); srv_master_do_active_tasks(); &#125; else &#123; srv_master_do_idle_tasks(); &#125; &#125;&#125; 这里判断集群是否活跃是通过，activity_count这个atomic变量，每个SQL操作之后都会对这个activity_count进行加1。 merge ibuf函数： 1234567891011121314151617181920/*********************************************************************//**Contracts insert buffer trees by reading pages to the buffer pool.@return a lower limit for the combined size in bytes of entries whichwill be merged from ibuf trees to the pages read, 0 if ibuf isempty */UNIV_INTERNulintibuf_contract_in_background(/*========================*/ table_id_t table_id, /*!&lt; in: if merge should be done only for a specific table, for all tables this should be 0 */ ibool full) /*!&lt; in: TRUE if the caller wants to do a full contract based on PCT_IO(100). If FALSE then the size of contract batch is determined based on the current size of the ibuf tree. */&#123; //根据full是否为true，刷不同数量的页面&#125; 123456789101112131415161718192021222324srv_master_do_idle_tasks(void)&#123; /* make sure that there is enough reusable space in the redo log files*/ // 检查redo log是否有足够的可用空间 log_free_check(); /* Do an ibuf merge */ // 执行ibuf的合并 ibuf_merge_in_background(true); // 强制执行table cache srv_main_thread_op_info = &quot;enforcing dict cache limit&quot;; ulint n_evicted = srv_master_evict_from_table_cache(100); /* Flush logs if needed */ // 持久化log buffer,innodb_flush_log_at_trx_commit配置0的时候就是此操作 srv_sync_log_buffer_in_background()； /* Make a new checkpoint */ // 创建一个新的检查点 log_checkpoint(TRUE, FALSE);&#125; srv_master_do_active_tasks基本相同，在执行操作的条件上会判断更加严格。 在shutdown和start时候对ibuf处理情况参考资料 https://mysqlserverteam.com/the-innodb-change-buffer/ FAQ http://mysql.taobao.org/monthly/2015/07/01/ http://hedengcheng.com/?p=94]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap+Django分页方式由client切换到server]]></title>
    <url>%2F2019-03-13-Bootstrap-Django%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F%E7%94%B1client%E5%88%87%E6%8D%A2%E5%88%B0server%2F</url>
    <content type="text"><![CDATA[背景公司内部项目分页在数据量超过700行之后，第一次表格加载的时候就变得有点慢(超过6s以上)。查看前端代码boostrap的分页模式还是client的，一次加载，然后静态展示。 查看后台数据库对应的SQL发现没有慢查询，说明数据库执行比较快。client模式需要将所有需要的数据二次处理，故考虑使用server模式，这样每次处理的数据就变得很小(limit分页值，如10、20、30等)。 页面修改查看bootstrapTable文档，在javascript部分增加如下： 123456789$(function () &#123; $('#demo-table').bootstrapTable(&#123; method: 'get', dataType: 'json', url: "&#123;% url 'p_perform_records_list' %&#125;", cache: false, #增加的部分 sidePagination: "server", queryParamsType: "limit", 修改为server之后，debug调试Django： 1/?search=&amp;sort=make_time&amp;order=desc&amp;offset=690&amp;limit=10&amp;_=1552474052890 可以看到传递的参数，包括limit, offset, search, sort, order。 Django部分的修改Django部分对应的view修改： 123456789101112131415161718192021222324252627282930313233343536373839404142class PerformRecordsListView(View): def get(self, request): //解析相关的参数 limit = request.GET.get('limit') offset = request.GET.get('offset') search = request.GET.get('search') sort = request.GET.get('sort') order = request.GET.get('order') if not sort: sort = "make_time" order= "desc" //执行相关的数据库查询操作，获取所有元素 all_records = IncepMakeExecTask.objects.raw(query) exec_tasks = [] for row in all_records: exec_tasks.append(row) if not offset: offset = 0 if not limit: limit = 20 //Django的分页操作 pageinator = Paginator(exec_tasks, limit) page = int(int(offset)/int(limit)+1) //返回的Json串必须包含total和rows两个key ret = &#123;'total':len(exec_tasks), 'rows':[]&#125; for row in pageinator.page(page): ret['rows'].append(&#123;'user': row.user, 'taskid': row.taskid, 'group_name': row.group_name, 'category': row.category, #'dst_host': row.dst_host, 'dst_port': row.dst_port, 'dst_database': row.dst_database, 'make_time': row.make_time, 'exec_status': exec_status&#125;) //返回Json串 return JsonResponse(ret)]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inception语法解析过程浅析]]></title>
    <url>%2F2019-03-12-Inception%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[背景在Inception执行远程命令分析中分析Inception执行命令的过程，但是文中给出的SQL如何解析的呢，例如comment涉及的相关信息(如远程的host、port等)是如何解析到的呢？还有，alter语句又是如何解析到的呢？ 本文针对这些问题进行源码分析: 如何解析comment信息，获取inception支持的选项信息。 Inception涉及的语句。 Inception支持的选项解析Inception是从注释语句中获取其支持的一些选项的，如果从SQL中无法解析到必须的选项则返回错误。 gdb调试查看python发送的SQL在dispatch_command上打上断点进行调试，可以看到如下(保留一些关键信息)： 123456789101112Breakpoint 1, dispatch_command (command=COM_QUERY, packet=0x10224c1 "set autocommit=0")(gdb) cContinuing.Breakpoint 1, dispatch_command (command=COM_QUERY, packet=0x10224c1 "/*--user=dba;--password=xxx;--host=10.x;--enable-check=1;--port=5627;*/inception_magic_start;set names utf8mb4;alter table sbtest.cc_order_user engine=Innodb;inception_ma"...(gdb) cContinuing.Breakpoint 1, dispatch_command (command=COM_QUIT, packet=0x10224c1 "")(gdb) c 总共包含三条SQL： 第一条set autocommit=0是MySQLdb在构建connect时候发送的（具体可以看MySQLdb的源码实现）; 第二条是实际的SQL，也是我们分析的重点； 第三条是调用MySQLdb的cursor.close产生COM_QUIT。 从SQL comment中解析Inception支持的选项从上面的gdb调试，可以看出第二条SQL才是重点，第二条SQL是一个完整的SQL。 在上文中，发送这些远端信息存储在thd-&gt;thd_sinfo中，通过对比thd_sinfo变化，找到对应的关键函数，调用栈分析: 1234567891011(gdb) bt#0 thd_parse_options#1 0x00000000006cb3cd in mysql_parse_and_check_valid#2 0x00000000006cb53e in mysql_process_command#3 0x00000000006cb6a2 in mysql_parse#4 0x00000000006abd4d in dispatch_command#5 0x00000000006a99c5 in do_command#6 0x00000000006832ef in do_handle_one_connection#7 0x0000000000683098 in handle_one_connection#8 0x00007ffff7bc6e25 in start_thread#9 0x00007ffff6c96bad in clone () 主要看看thd_parse_options实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int thd_parse_options( THD * thd, char* sql)&#123; //判断注释字符串是否齐全，否则就报错 if (length &lt;= 2 || (*str != '/' &amp;&amp; *(str + 1) != '*')) &#123; my_error(ER_SQL_NO_SOURCE, MYF(0)); DBUG_RETURN(ER_NO); &#125; while (*str != '\0' &amp;&amp; *(str + 1) != '\0') &#123; if (*str=='*' &amp;&amp; *(str+1) == '/') &#123; found = TRUE; break; &#125; str++; &#125; ... //获取注释部分的 comment = (char*)my_malloc(str - sql + 1, MY_ZEROFILL); memcpy(comment, sql, str - sql); str_comment = strtok(comment, "*/"); //按照分号切分出token strToken = strtok(str_comment, ";"); while (strToken != NULL) &#123; length = strlen(strToken); while (length &gt; 0 &amp;&amp; my_isspace(thd-&gt;charset(), *strToken)) &#123; strToken++; length--; &#125; isql_option[++i] = strToken; strToken = strtok(NULL, ";"); &#125; //按照字符串例如--user=dba，解析出信息 //基本上是MySQL原生态代码 ho_error = my_handle_options(&amp;++i, &amp;isql_option, my_isql_options, NULL, NULL, errmsg); //设置Inception操作类型 if (global_source.query_print == 1) thd-&gt;thd_sinfo-&gt;optype = INCEPTION_TYPE_PRINT; else if (global_source.split == 1) thd-&gt;thd_sinfo-&gt;optype = INCEPTION_TYPE_SPLIT; else if (global_source.execute == 1) thd-&gt;thd_sinfo-&gt;optype = INCEPTION_TYPE_EXECUTE; else if (global_source.check== 1) thd-&gt;thd_sinfo-&gt;optype = INCEPTION_TYPE_CHECK; //将解析出的信息赋值给thd-&gt;thd_sinfo //这里给出部分代码 strcpy(thd-&gt;thd_sinfo-&gt;host, global_source.host); thd-&gt;thd_sinfo-&gt;port = global_source.port; ...&#125; my_isql_options是my_option结构体组成的数组，具体实例如下: 1234567891011121314151617181920212223242526272829sinfo_t global_source;struct my_option my_isql_options[]=&#123; &#123;"host", 0, "remote server address.", &amp;global_source.host, &amp;global_source.host, 0, GET_STR_ALLOC, REQUIRED_ARG, 0, 0, 0, 0, 0, 0&#125;, &#123;"password", 0, "the user's password.", &amp;global_source.password, &amp;global_source.password, 0, GET_STR_ALLOC, REQUIRED_ARG, 0, 0, 0, 0, 0, 0&#125;, ...&#125;typedef struct source_info_struct sinfo_t;struct source_info_struct&#123; char* host; char* password; char* user; uint port; uint check;//check or execute uint execute; uint force; uint backup; uint ignore_warnings; uint split; uint query_print; ulonglong sleep_nms;&#125;; 这里看到，comment还可以包括其他一些信息，具体这些参数含义参照Inception支持选项及意义文档。 SQL命令解析对于如下的一行SQL（这里为了显示方便，分为多行）： 12345"/*--user=dba;--password=xxx;--host=10.xxx;--enable-check=1;--port=5627;*/inception_magic_start;set names utf8mb4;alter table sbtest.cc_order_user engine=Innodb;inception_magic_commit; dispatch_command流程123456789101112131415161718192021222324252627bool dispatch_command(enum enum_server_command command, THD *thd,char* packet, uint packet_length)&#123; //对比MySQL，Inception只支持COM_QUERY类型的SQL命令 switch (command) &#123; case COM_QUERY: //进行SQL语法解析，执行相关命令 Parser_state parser_state; mysql_parse(thd, thd-&gt;query_length(), &amp;parser_state); //如果是多行SQL，含有分号，按照分号切换进行多次解析以及执行 while (!thd-&gt;killed &amp;&amp; (parser_state.m_lip.found_semicolon != NULL) &amp;&amp; ! thd-&gt;is_error() &amp;&amp; !thd-&gt;parse_error) &#123; //中间有对sql进行一下预处理，去除前缀的space parser_state.reset(beginning_of_next_stmt, length); //再次执行解析 mysql_parse(thd, length, &amp;parser_state); &#125; ... case COM_QUIT: //处理quit default: my_error(ER_NOT_SUPPORTED_YET, MYF(0)); &#125;&#125; 执行命令-Inception命令主要执行命令的函数在mysql_show_print_and_execute_simple(sql/sql_parse.cc)，其主要功能对应MySQL源码中的mysql_execute_command(sql/sql_parse.cc)的功能，词法分析后执行不同类型的SQL命令。 12345678910111213141516171819202122int mysql_show_print_and_execute_simple(THD *thd)&#123; switch(thd-&gt;lex-&gt;sql_command) &#123; case SQLCOM_INCEPTION_START: res = mysql_init_sql_cache(thd); break; case SQLCOM_INCEPTION_COMMIT: //在inception_magic_commit且选项参数为execute的之后才真正执行远程命令 res = mysql_execute_commit(thd); break; case SQLCOM_SET_OPTION: if (!thd-&gt;have_begin) res = FALSE; else res = ER_WARNING; break; default: res = ER_WARNING; break; &#125; &#125; 执行命令-原生态SQL命令Check规则对于mysql的一些SQL规则的检查主要在mysql_check_command函数中实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384int mysql_check_command(THD *thd)&#123; int err; LEX *lex= thd-&gt;lex; SELECT_LEX *select_lex= &amp;lex-&gt;select_lex; TABLE_LIST *first_table= select_lex-&gt;table_list.first; thd-&gt;thread_state = INCEPTION_STATE_CHECKING; DBUG_ENTER("mysql_check_command"); ... switch (thd-&gt;lex-&gt;sql_command) &#123; case SQLCOM_CHANGE_DB: err = mysql_check_change_db(thd); break; case SQLCOM_SET_OPTION: err = mysql_set_option_check(thd); break; case SQLCOM_CREATE_DB: err = mysql_check_create_db(thd); break; case SQLCOM_INSERT: err = mysql_check_insert(thd); break; case SQLCOM_DELETE: //case SQLCOM_DELETE_MULTI: err = mysql_check_delete(thd); break; case SQLCOM_UPDATE: //case SQLCOM_UPDATE_MULTI: err = mysql_check_update(thd); break; case SQLCOM_SELECT: err = mysql_check_select(thd); break; case SQLCOM_CREATE_TABLE: err = mysql_check_create_table(thd); break; case SQLCOM_ALTER_TABLE: err = mysql_check_alter_table(thd); break; case SQLCOM_INSERT_SELECT: err = mysql_check_insert_select(thd); break; case SQLCOM_INCEPTION: err = mysql_execute_inception_command(thd); break; case SQLCOM_CREATE_INDEX: case SQLCOM_RENAME_TABLE: case SQLCOM_DROP_INDEX: my_error(ER_INDEX_USE_ALTER_TABLE, MYF(0)); mysql_errmsg_append(thd); err = 1; break; case SQLCOM_TRUNCATE: err = mysql_check_truncate_table(thd); break; case SQLCOM_DROP_TABLE: err = mysql_check_drop_table(thd); break; default: my_error(ER_NOT_SUPPORTED_YET, MYF(0)); mysql_errmsg_append(thd); err = 1; &#125; DBUG_RETURN(err);&#125;]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Inception执行远程命令分析]]></title>
    <url>%2F2019-03-07-Inception%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[背景在使用Inception过程中，线上有数据库字符集默认字符集是latin1的，出现过中文乱码问题。因此在使用Inception的时候，兼容表情字符，强制添加set names utf8mb4。 具体demo如下: 1234567import MySQLdbsql='/*--user=dba;--password=xx;--host=10.xx;--execute=1;--port=5627;*/\inception_magic_start;\use sakila;\set names utf8mb4;\alter table actor engine=Innodb;\inception_magic_commit;' 只是在execute的部分加了，但是没有check的部分加，后来发现通过inception osc percent无法获取的osc进度。因此针对这个问题，研究一下inception的源码。 Inception执行远程命令通过gdb调试，Inception执行远程命令的部分主要在mysql_execute_statement（sql/sql_parse.cc）中，具体如下: 123456789101112131415161718int mysql_execute_statement( THD* thd, MYSQL* mysql, char* statement, sql_cache_node_t* sql_cache_node)&#123; if (sql_cache_node-&gt;use_osc) &#123; mysql_execute_alter_table_osc(thd, mysql, statement, sql_cache_node) &#125; else &#123; mysql_real_query(mysql, statement, strlen(statement)) &#125;&#125; 根据判断的条件use_osc是执行osc命令，还是直接SQL命令。直接执行SQL命令比较简单，直接调用MySQL C API的mysql_read_query函数。这里问题关键是这个远程连接MYSQL结构如何初始化的？ 打印对应的堆栈结构如下: 1234567891011121314(gdb) bt#0 mysql_execute_statement#1 mysql_remote_execute_command#2 mysql_execute_all_statement#3 mysql_execute_commit#4 mysql_show_print_and_execute_simple#5 mysql_process_command #6 mysql_parse #7 dispatch_command #8 do_command #9 do_handle_one_connection #10 handle_one_connection #11 start_thread #12 clone () 可以看到主题结构还是MySQL影响连接的过程，因为Inception本身就是基于MySQL5.6.10版本的改的哈。 远程命令的连接如何产生？mysql连接产生的地方通过上面的bt路径逐个往上翻，在mysql_execute_all_statement(sql/sql_parse.cc)中: 12345678910111213141516int mysql_execute_all_statement(THD* thd)&#123; MYSQL* mysql = NULL; if ((mysql = thd-&gt;get_audit_connection()) == NULL) return TRUE; //循环遍历上面python demo中多条语句 //set names utf8mb4 //use sakila //alter table actor engine=Innodb sql_cache_node = LIST_GET_FIRST(thd-&gt;sql_cache-&gt;field_lst); while (!thd-&gt;killed &amp;&amp; sql_cache_node != NULL) &#123; mysql_remote_execute_command(thd, mysql, sql_cache_node)) sql_cache_node = LIST_GET_NEXT(link, sql_cache_node); &#125;&#125; 主要是通过THD::get_audit_connection获取到mysql连接，然后在遍历链表执行远程命令。 mysql连接初始化Inception对MySQL原生态的THD类进行修改，添加如下部分: 12345678910111213141516171819public: MYSQL* get_audit_connection(); MYSQL* get_backup_connection(); void close_all_connections(); private: bool init_audit_connection(); bool audit_conn_inited; struct &#123; MYSQL mysql; char user[USERNAME_CHAR_LENGTH + 1]; char passwd[MAX_PASSWORD_LENGTH + 1]; char host[HOSTNAME_LENGTH + 1]; uint port; &#125; audit_conn; bool init_backup_connection(); bool backup_conn_inited; MYSQL backup_conn; 每个THD维护一个audit_conn对象，根据audit_conn_inited进行判断只初始化一次，如果存在就直接返回。 连接初始化部分如下： 12345678910111213141516bool THD::init_audit_connection()&#123; MYSQL *mysql = &amp;audit_conn.mysql; mysql_init(mysql); ... //尽管这里有设置utf8，但是在Latin1库，还是遇到乱码，故在语句中强制设置set names utf8mb4 mysql_options(mysql, MYSQL_SET_CHARSET_NAME, system_charset_info-&gt;csname); ... if (mysql_real_connect(mysql, thd_sinfo-&gt;host, thd_sinfo-&gt;user thd_sinfo-&gt;password, NULL, thd_sinfo-&gt;port, NULL, client_flag) == 0) &#123; //返回错误 &#125; //将host、user、passwd赋值给THD的thd_sinfo，用于get_audit_conn复用判断&#125; osc部分上面分析完直接执行远程命令，觉得很简单的吧。osc部分就相对比较复杂，Inception是MySQL多线程模式，可以直接多个osc，每个osc直接通过sqlsha1值进行区分，首先来研究这个sqlsha1如何产生的？ osc中sqlsha1值生成原理1234567891011121314151617181920212223242526272829303132void mysql_compute_sql_sha1(THD* thd, sql_cache_node_t* sql_cache_node)&#123; str_t sqlinfo_space; str_t* sqlinfo; char port[10]; //只有使用OSC的时候，才会返回这个HASH值 if (!sql_cache_node-&gt;use_osc) return; sqlinfo = str_init(&amp;sqlinfo_space); sqlinfo = str_append(sqlinfo, sql_cache_node-&gt;dbname); sqlinfo = str_append(sqlinfo, thd-&gt;thd_sinfo-&gt;password); sqlinfo = str_append(sqlinfo, thd-&gt;thd_sinfo-&gt;host); sqlinfo = str_append(sqlinfo, thd-&gt;thd_sinfo-&gt;user); sprintf(port, "%d", thd-&gt;thd_sinfo-&gt;port); sqlinfo = str_append(sqlinfo, port); //add the seqno, to solve execute same sql in different database sprintf(port, "%d", sql_cache_node-&gt;seqno); sqlinfo = str_append(sqlinfo, port); sqlinfo = str_append_with_length(sqlinfo, thd-&gt;query(), thd-&gt;query_length()); char m_hashed_password_buffer[CRYPT_MAX_PASSWORD_SIZE + 1]; String str(str_get(sqlinfo), system_charset_info); //dbname、password、host、user、port、seqno以及query组成的字符串 //再调用mysql原生态的生成password的函数产生这个sqlsha1值 calculate_password(&amp;str, m_hashed_password_buffer); strcpy(sql_cache_node-&gt;sqlsha1, m_hashed_password_buffer); str_deinit(sqlinfo);&#125; 由于添加seqno的，代码上注释也说明，此seqno是为了支持在不同的db中执行相同SQL。故如下两种情况: 1234567sql='/*--user=dba;--password=xxx;--host=10.xx;\--enable-check=1;--port=5627;*/\inception_magic_start;\## 是否有这个set namesset names utf8mb4;\alter table sbtest.cc_order_user engine=Innodb;\inception_magic_commit;' 两种情况对应的seqno，一个是0，一个是1，尽管在str这个字符中只有1位之差，其对应的sqlsha1就完全不同。（这里一开始在gdb调试的时候，没有发现这个，误以为和字符集system_charset_info有关，排查好久） osc执行过程12345678910111213141516171819202122232425int mysql_execute_alter_table_osc( THD* thd, MYSQL* mysql, char* statement, sql_cache_node_t* sql_cache_node)&#123; //拼接pt-online-schema-change的命令 oscargv[count++] = strdup("pt-online-schema-change"); oscargv[count++] = strdup("--alter"); ... //调用封装的process，fork子进程异步执行pt-osc process proc (thd, sql_cache_node, oscargv, "r"); //主进程进此osc_percent加入到全局变量global_osc_cache.osc_lst中 mysql_add_new_percent_cache_node(sql_cache_node, &amp;proc); if (NULL != proc.pipe() &amp;&amp; !proc.error()) &#123; while(tmp &amp;&amp; !proc.error() ) &#123; //循环判断proc的标准输出，更新percent信息 mysql_analyze_osc_output(thd, tmp, sql_cache_node); tmp = my_fgets (out, out_len, proc.pipe()); &#125; &#125;&#125; osc中percent状态更新通过上面的while循环逐行分析proc的结果输出，更新percent信息 12345678910111213141516171819202122232425262728293031323334353637383940414243int mysql_analyze_osc_output( THD* thd, char* tmp, sql_cache_node_t* sql_cache_node )&#123; sprintf(Successfully, "Successfully altered `%s`.`%s`.", sql_cache_node-&gt;dbname, sql_cache_node-&gt;tablename); if (!strcasecmp(Successfully, tmp)) &#123; //如果发现Successfully，将percent设置为100 percent = 100; strcpy(timeremain, "00:00"); sql_cache_node-&gt;oscpercent = 100; &#125; else &#123; //从proc标准输出解析percent和timerremain sscanf(tmp, "Copying %*s %d%*s %s remain", &amp;percent, timeremain); if(percent==-1)&#123; //如果没有解析到，返回再进行上一层的循环 &#125; &#125; //如果解析到，遍历global_osc_cache.osc_list更新percent //使用mutex保护这个list mysql_mutex_lock(&amp;osc_mutex); osc_percent_node = LIST_GET_FIRST(global_osc_cache.osc_lst); while(osc_percent_node) &#123; //根据sqlsha1进行比较 if (!strcasecmp(osc_percent_node-&gt;sqlsha1, sql_cache_node-&gt;sqlsha1)) &#123; osc_percent_node-&gt;percent = percent; strcpy(osc_percent_node-&gt;remaintime, timeremain); break; &#125; //遍历下一个节点 osc_percent_node = LIST_GET_NEXT(link, osc_percent_node); &#125; //如果都没有找到，重新创建添加到osc_list中 mysql_mutex_unlock(&amp;osc_mutex);&#125; osc中get osc percent执行过程如果获取osc percent，Inception提供的命令如下: 1inception get osc percent '*94389A9158CEDA0F698B08EEB418A9CFCFCD568A' 这个就比较简单了，通过遍历上面的global_osc_cache.osc_list进行判断sqlsha1的判断，具体代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940int mysql_execute_inception_osc_show(THD* thd)&#123; //还是通过mutex进行保护 mysql_mutex_lock(&amp;osc_mutex); osc_percent_node = LIST_GET_FIRST(global_osc_cache.osc_lst); while(osc_percent_node) &#123; if (!strcasecmp(osc_percent_node-&gt;sqlsha1, wild)) break; osc_percent_node = LIST_GET_NEXT(link, osc_percent_node); &#125; ... //设置返回列的信息 field_list.push_back(new Item_empty_string("DBNAME", FN_REFLEN)); field_list.push_back(new Item_empty_string("TABLENAME", FN_REFLEN)); field_list.push_back(new Item_empty_string("SQLSHA1", FN_REFLEN)); field_list.push_back(new Item_return_int("PERCENT", 20, MYSQL_TYPE_LONG)); field_list.push_back(new Item_empty_string("REMAINTIME", FN_REFLEN)); field_list.push_back(new Item_empty_string("INFOMATION", FN_REFLEN)); //设置各个字段信息 if (osc_percent_node) &#123; protocol-&gt;prepare_for_resend(); protocol-&gt;store(osc_percent_node-&gt;dbname, system_charset_info); protocol-&gt;store(osc_percent_node-&gt;tablename, system_charset_info); protocol-&gt;store(osc_percent_node-&gt;sqlsha1, system_charset_info); protocol-&gt;store(osc_percent_node-&gt;percent); protocol-&gt;store(osc_percent_node-&gt;remaintime, system_charset_info); protocol-&gt;store(str_get(osc_percent_node-&gt;sql_cache_node-&gt;oscoutput), system_charset_info); protocol-&gt;write(); &#125; mysql_mutex_unlock(&amp;osc_mutex); my_eof(thd); //这一部分也是标准的返回结果给client的过程&#125; 总结通过分析线上具体的问题，进一步对Inception的代码熟悉和了解，尽管过程花时间比较有点多，但最终还是解决了，还是蛮开心的哈。主要分析的过程是通过grep关键字，找到对应的函数，然后gdb发现上下调用栈，然后找到关键的函数再进行分析。通过源码分析，更加了解事物本质，是以后努力方向。尽管现在还是一知半解，越来越觉得，搞了多就好多了。]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL美化]]></title>
    <url>%2F2019-02-15-SQL%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[背景公司内部SQL工单系统中使用SQL格式化的功能，一开始使用python的sqlparse包，它还有个在线网站https://sqlformat.org/。随着公司工单数据越来越多，发现有些SQL它就格式化不好，故选择其他方案进行替换。 sqlparse格式效果如下 12345678910111213INSERT INTO `wk_adsense`.`wk_cct_extend_area`(`business_type`,`province_id`,`city_id`,`remark`,`create_time`,`tencent_id`)VALUES (290, 101, 101001, "北京", unix_timestamp(now()), 110100),(290, 102, 102001, "天津", unix_timestamp(now()), 120100),(290,... SQL更多内容可以参照git input.sql Druid项目发现Druid中有SQL格式的功能，具体文档如https://github.com/alibaba/druid/wiki/SQL_Format。 测试代码12345678910111213141516171819202122232425262728293031323334import com.alibaba.druid.sql.SQLUtils;import com.alibaba.druid.util.JdbcConstants;import org.apache.commons.cli.Options;import org.apache.commons.cli.CommandLineParser;import org.apache.commons.cli.DefaultParser;import org.apache.commons.cli.CommandLine;import org.apache.commons.io.FileUtils;import java.io.File;public class FormatSQL &#123; public static void main(String []args)&#123; Options options = new Options(); options.addOption("f", true, "sql file"); String filePath; try&#123; CommandLineParser parser = new DefaultParser(); CommandLine cmd = parser.parse( options, args); if (cmd.hasOption("f"))&#123; filePath = cmd.getOptionValue("f"); String sql = FileUtils.readFileToString(new File(filePath), "UTF-8"); String result = SQLUtils.format(sql, JdbcConstants.MYSQL); System.out.println(result); // 缺省大写格式 &#125;else&#123; System.out.println("Not found option file"); &#125; &#125;catch (Exception e)&#123; System.err.println(e); &#125; &#125;&#125; 依赖的Maven项目: 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.13&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-cli&lt;/groupId&gt; &lt;artifactId&gt;commons-cli&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 运行Jar包1java -cp FormatSQL.jar FormatSQL -f ./input.sql &gt; out.sql Druid格式效果如下: 12345678910INSERT INTO `wk_adsense`.`wk_cct_extend_area` (`business_type`, `province_id`, `city_id`, `remark`, `create_time` , `tencent_id`)VALUES (290, 101, 101001, '北京', unix_timestamp(now()) , 110100), (290, 102, 102001, '天津', unix_timestamp(now()) , 120100), (290, 105, 105001, '石家庄', unix_timestamp(now()) , 130100), (290, 105, 105005, '唐山', unix_timestamp(now()) , 130200), 具体代码见git SQL 实例: comment关键字缺少空格内部SQL审核平台遇到一个SQL执行的问题，具体SQL如下： 12ALTER TABLE wk_cck_gifts ADD COLUMN source TINYINT NOT NULL DEFAULT '0'COMMENT '礼包成单来源，0--正常，1--种草' 注意到comment的位置，comment和前面的default值之间没有空格 这条SQL在MySQL解析是正常的，也可以正常执行，但是使用pt-online-schema-change的时候，会出现错误。具体错误信息如下： 12Use of uninitialized value $1 in concatenation (.) or string at /usr/bin/pt-online-schema-change line 10219 在测试pt-online-schema-change最新版本3.0.13也有问题，出问题的版本是3.0.9。由于Inception可以通过此类SQL的check，所以最好在sqlformat的时候解决，否则在执行错误的时候才发现类似的问题，再手动修改，比较费时。 亲测，sqlparse无法识别此问题，使用Druid的format可以解决此问题。 Js 版本的format在github上有一个开源的SQL审核平台archery，它使用到下面的SQL format方式，https://github.com/zeroturnaround/sql-formatter 测试可以解决上面的SQL缺少空格问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL-Insert-操作加锁分析]]></title>
    <url>%2F2019-01-11-MySQL-Insert-%E6%93%8D%E4%BD%9C%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[背景看微博上丁奇大牛转发的一条微博，看作者分析的过程有疑问，Insert操作会有插入意向锁的判断，文中没有提到， 故查看源码试着分析一下。 问题描述1234567891011121314151617181920212223 CREATE TABLE `z` ( `id` int(11) NOT NULL AUTO_INCREMENT, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `b` (`b`)) ENGINE=InnoDBINSERT INTO z (id, b)VALUES (1,2),(3,4),(5,6),(7,8),(9,10);/* session A */begin;select * from z where b=6 for update;/* session B*/insert into z values(0,4); /*blocked*/insert into z values(-1,4); /*success*/insert into z values(4,8); /*blocked*/insert into z values(8,8); /*success*/ 文中提到的(id=5,b=6)前面有Gap Lock这点觉得有疑问。 Innodb打印出的锁信息设置参数开启Innodb打印SQL加锁详情12set global innodb_status_output_locks=1;set global innodb_status_output=1; 在RR模式下运行session A123456789101112131415161718192021222324## select * from z where b=6 for update4 lock struct(s), heap size 1248, 3 row lock(s)MySQL thread id 1, OS thread handle 0x7fff65ce9700, query id 15 localhost root cleaning upTABLE LOCK table `test`.`z` trx id 102152 lock mode IX### 索引b上的Next-keyRECORD LOCKS space id 57 page no 4 n bits 80 index `b` of table `test`.`z` trx id 102152 lock_mode XRecord lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 0: len 4; hex 80000006; asc ;; ### b字段，值为6 1: len 4; hex 80000005; asc ;; ### 主键id字段，值为5### 主键索引上记录锁RECORD LOCKS space id 57 page no 3 n bits 80 index `PRIMARY` of table `test`.`z` trx id 102152 lock_mode X locks rec but not gapRecord lock, heap no 4 PHYSICAL RECORD: n_fields 4; compact format; info bits 0 0: len 4; hex 80000005; asc ;; ### 主键id字段，值为5 1: len 6; hex 00000001890b; asc ;; ### 事务id，此行最近一次被更新的事务id，占6个字节 2: len 7; hex 8b0000013d0128; asc = (;; ### 回滚段指针DB_ROLL_PTR，用于MVCC 3: len 4; hex 80000006; asc ;; ### b字段，值为6### 索引b上的GAP锁RECORD LOCKS space id 57 page no 4 n bits 80 index `b` of table `test`.`z` trx id 102152 lock_mode X locks gap before recRecord lock, heap no 5 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 0: len 4; hex 80000008; asc ;; ## b字段，值为8 1: len 4; hex 80000007; asc ;; ## 主键id，值为7 可以看出此SQL语句加锁为索引b上的(4,8) = (4,6]的Next-key锁，(6,8)之间的GAP锁，主键上[5]。这里就是疑问点。 在RR模式下运行session B插入(0,4)1234567891011121314151617---TRANSACTION 102153, ACTIVE 689 sec insertingmysql tables in use 1, locked 1LOCK WAIT 2 lock struct(s), heap size 376, 1 row lock(s), undo log entries 1MySQL thread id 2, OS thread handle 0x7fff65ca8700, query id 26 localhost root updateinsert into z values(0,4)------- TRX HAS BEEN WAITING 7 SEC FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 57 page no 4 n bits 80 index `b` of table `test`.`z` trx id 102153 lock_mode X locks gap before rec insert intention waitingRecord lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 0: len 4; hex 80000006; asc ;; 1: len 4; hex 80000005; asc ;;------------------TABLE LOCK table `test`.`z` trx id 102153 lock mode IXRECORD LOCKS space id 57 page no 4 n bits 80 index `b` of table `test`.`z` trx id 102153 lock_mode X locks gap before rec insert intention waitingRecord lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 0: len 4; hex 80000006; asc ;; 1: len 4; hex 80000005; asc ;; 可以看出sessionB阻塞的原因是插入意向锁，等待b索引上(b=6,id=5)之前的GAP锁。 插入(2,8)123456insert into z values(2,8)------- TRX HAS BEEN WAITING 7 SEC FOR THIS LOCK TO BE GRANTED:RECORD LOCKS space id 57 page no 4 n bits 80 index `b` of table `test`.`z` trx id 102698 lock_mode X locks gap before rec insert intention waitingRecord lock, heap no 5 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 0: len 4; hex 80000008; asc ;; 1: len 4; hex 80000007; asc ;; 等待b索引上(b=8,id=7)之前的GAP锁。 [space, page_no] 可以确定锁对应哪个页，参考下上个月月报最后两个小节，页上每行数据紧接着存放，内部使用一个 heap_no 来表示是第几行数据。因此[space, page_no, heap_no]可以唯一确定一行。 尽管都是同一个page，但是heap_no不同。 Insert Debug调试Insert操作的锁判断给lock_rec_insert_check_and_lock函数添加断点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*********************************************************************//**Checks if locks of other transactions prevent an immediate insert ofa record. If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction andthe query thread to the lock wait state and inserts a waiting requestfor a gap x-lock to the lock queue.@return DB_SUCCESS, DB_LOCK_WAIT, DB_DEADLOCK, or DB_QUE_THR_SUSPENDED */UNIV_INTERNdberr_tlock_rec_insert_check_and_lock(/*===========================*/ ulint flags, /*!&lt; in: if BTR_NO_LOCKING_FLAG bit is set, does nothing */ const rec_t* rec, /*!&lt; in: record after which to insert */ buf_block_t* block, /*!&lt; in/out: buffer block of rec */ dict_index_t* index, /*!&lt; in: index */ que_thr_t* thr, /*!&lt; in: query thread */ mtr_t* mtr, /*!&lt; in/out: mini-transaction */ ibool* inherit)/*!&lt; out: set to TRUE if the new inserted record maybe should inherit LOCK_GAP type locks from the successor record */&#123; ... //当前insert记录的逻辑下一条记录 next_rec = page_rec_get_next_const(rec); next_rec_heap_no = page_rec_get_heap_no(next_rec); ... //判断当前记录的下一条逻辑记录值上是否存在GAP锁或者插入意向锁 //如果存在，返回DB_LOCK_WAIT，当前insert进行等待队列 /* If another transaction has an explicit lock request which locks the gap, waiting or granted, on the successor, the insert has to wait. An exception is the case where the lock by the another transaction is a gap type lock which it placed to wait for its turn to insert. We do not consider that kind of a lock conflicting with our insert. This eliminates an unnecessary deadlock which resulted when 2 transactions had to wait for their insert. Both had waiting gap type lock requests on the successor, which produced an unnecessary deadlock. */ if (lock_rec_other_has_conflicting( ¦ static_cast&lt;enum lock_mode&gt;( ¦ LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION), ¦ block, next_rec_heap_no, trx)) &#123; /* Note that we may get DB_SUCCESS also here! */ trx_mutex_enter(trx); err = lock_rec_enqueue_waiting( LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION, block, next_rec_heap_no, index, thr); trx_mutex_exit(trx); &#125; else &#123; err = DB_SUCCESS; &#125;... 两条Insert操作对应的下一条记录情况insert into z values(0,4)12345678910(gdb) p *next_rec$5 = 128 &apos;\200&apos;(gdb) p next_rec_heap_no$6 = 4TABLE LOCK table `test`.`z` trx id 102153 lock mode IXRECORD LOCKS space id 57 page no 4 n bits 80 index `b` of table `test`.`z` trx id 102153 lock_mode X locks gap before rec insert intention waitingRecord lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 0: len 4; hex 80000006; asc ;; 1: len 4; hex 80000005; asc ;; 打印这个下一行其加锁信息： 12(gdb)p lock-&gt;un_member-&gt;rec_lock$21 = &#123;space = 57, page_no = 4, n_bits = 80&#125; 在没有加锁的情况，此语句插入的记录是(id=10,b=4)，而不是(id=0,b=4)。这是因为主键是Auto_Increment。 insert into z values(-1,4)123456 (gdb) p next_rec$7 = (const rec_t *) 0x7fff6e00808c &quot;\200&quot;(gdb) p *next_rec$8 = 128 &apos;\200&apos;(gdb) p next_rec_heap_no$9 = 3 这里就是为啥插入(-1,4)记录不会阻塞，而(0,4)会阻塞的根本原因。 思考 插入意向锁作用是啥？ insert的时候为啥需要判断逻辑的下一条记录加锁情况呢？ 插入意向锁是针对主键，还是二级索引？ 参考 http://mysql.taobao.org/monthly/2017/12/02/ http://mysql.taobao.org/monthly/2016/01/01/]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python调用Golang-rpc服务]]></title>
    <url>%2F2018-12-18-Python%E8%B0%83%E7%94%A8Golang-rpc%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[背景看open-falcon的transfer部分代码，发现有个python测试脚本，使用python调用golang的rpc服务。故对这个点进行整理一下。python调用golang rpc服务，前提是使用json rpc机制。 Golang Rpc Server代码1234567891011121314151617181920212223242526272829303132333435package mainimport ( "net/rpc" myserver "TestRpc/server" "net" "log" "net/rpc/jsonrpc")func main() &#123; addr := ":1234" server := rpc.NewServer() server.Register(new(myserver.Arith)) l, e := net.Listen("tcp", addr) if e != nil&#123; log.Fatalln("listen error:", e) &#125;else&#123; log.Println("rpc listening ", addr) &#125; defer l.Close() for &#123; conn, err := l.Accept() if err != nil &#123; log.Print("rpc.Serve: accept:", err.Error()) return &#125; go server.ServeCodec(jsonrpc.NewServerCodec(conn)) &#125;&#125; Rpc方法和函数12345678910111213141516171819202122232425262728293031323334353637package serverimport ( "github.com/pkg/errors" "fmt")type Arith inttype Args struct &#123; A,B int&#125;//商和余数type Quotient struct &#123; Quo, Rem int&#125;func (q Quotient)String() string &#123; return fmt.Sprintf("Quo:%d, Rem:%d", q.Quo, q.Rem)&#125;//乘法func (t *Arith)Mulitply(args *Args, reply *int) error &#123; *reply = args.A *args.B return nil&#125;func (t *Arith)Divide(args *Args, quo *Quotient) error &#123; if args.B == 0&#123; return errors.New("Divide by zero") &#125; quo.Quo = args.A/args.B quo.Rem = args.A%args.B return nil&#125; Python调用代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import jsonimport socketimport itertoolsimport timeclass RPCClient(object): def __init__(self, addr, codec=json): self._socket = socket.create_connection(addr) self._id_iter = itertools.count() self._codec = codec def _message(self, name, *params): return dict(id=self._id_iter.next(), params=list(params), method=name) def call(self, name, *params): req = self._message(name, *params) id = req.get('id') """ Golang Rpc 返回的Json格式 type serverResponse struct &#123; Id *json.RawMessage `json:"id"` Result interface&#123;&#125; `json:"result"` Error interface&#123;&#125; `json:"error"` &#125; """ mesg = self._codec.dumps(req) self._socket.sendall(mesg) # This will actually have to loop if resp is bigger resp = self._socket.recv(4096) resp = self._codec.loads(resp) if resp.get('id') != id: raise Exception("expected id=%s, received id=%s: %s" %(id, resp.get('id'), resp.get('error'))) if resp.get('error') is not None: raise Exception(resp.get('error')) return resp.get('result') def close(self): self._socket.close()if __name__ == '__main__': rpc = RPCClient(("127.0.0.1", 1234)) args = &#123;'A':2, 'B':3&#125; print rpc.call("Arith.Mulitply",args) 参考资料 Rpc提供http方式 https://haisum.github.io/2015/10/13/rpc-jsonrpc-gorilla-example-in-golang/ 相似的例子 https://gist.github.com/stevvooe/1164621]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go使用defer机制记录]]></title>
    <url>%2F2018-12-13-Go%E4%BD%BF%E7%94%A8defer%E5%AE%9E%E7%8E%B0python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[defer 多个defer执行顺序如何 如何使用defer机制记录何时进入和退出函数 defer和return返回值 循环体使用defer注意点 多个defer执行顺序123456789101112131415161718func main() &#123; defer A() defer B() defer C() fmt.Println("Main")&#125;func A() &#123; fmt.Println("A Executed")&#125;func B() &#123; fmt.Println("B Executed")&#125;func C() &#123; fmt.Println("C Executed")&#125; 输出结果为: 1234MainC ExecutedB ExecutedA Executed 可以看到最先声明的defer，最后被执行，类似栈的操作FILO。 defer实现python装饰器的功能1234567891011121314151617181920212223242526272829package mainimport ( "time" "log")func bigSlowOperation() &#123; //相当于先初始化trace(XXX)，其他返回值为一个函数f //然后在本函数退出之前执行f() //f := trace("bigSlowOperation") //defer f() defer trace("bigSlowOperation")() log.Println("A") time.Sleep(time.Duration(5)*time.Second) log.Println("B")&#125;func trace(msg string) func() &#123; start := time.Now() log.Printf("Enter %s", msg) return func() &#123; log.Printf("Exit %s, (%s)", msg, time.Since(start)) &#125;&#125;func main() &#123; bigSlowOperation()&#125; defer和return返回值1234567891011import &quot;fmt&quot;func double(x,y float64) (ret float64) &#123; defer func() &#123;ret+=100.0;fmt.Printf(&quot;%.1f+%.1f=%.1f&quot;, x, y, ret)&#125;() ret = x+y return&#125;func main() &#123; double(1.5, 2.5)&#125; defer函数中可以访问函数本身的变量也可以修改返回值。 循环体中使用defer注意点123456789for _,filename := range filenames&#123; f, err := os.Open(filename) if err != nil&#123; return err &#125; defer f.Close() descriptors //...process f...&#125; 在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会被执行。上面的循环可能导致文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭。改进访问是改成调用函数。 1234567891011121314 for _,filename := range filenames&#123; OpenFile(filename) &#125;func OpenFile(filename string) error &#123; f, err := os.Open(filename) if err != nil&#123; return err &#125; defer f.Close() descriptors //...process f...&#125;]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go基准测试]]></title>
    <url>%2F2018-12-05-Go%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Go基准测试记录Go如下编写基准测试用例。 echo.go中定义两个函数12345678910111213141516171819package mainimport ( "strings")func Echo1(args []string, step string) string &#123; s:="" for _,arg := range args&#123; s += arg + step &#125; return s&#125;func Echo2(args []string, step string) string &#123; return strings.Join(args, step)&#125; 基准测试用例 echo_test.go 基础测试必须以Benchmark开头，功能测试以Test开头1234567891011121314151617package mainimport "testing"func BenchmarkEcho1(b *testing.B) &#123; args := []string&#123;"A", "B", "C"&#125; for i:=0;i&lt;b.N;i++&#123; Echo1(args, " ") &#125;&#125;func BenchmarkEcho2(b *testing.B) &#123; args := []string&#123;"A", "B", "C"&#125; for i:=0;i&lt;b.N;i++&#123; Echo2(args, " ") &#125;&#125; 运行测试用例123456789guosong$ go test -bench=.goos: darwingoarch: amd64pkg: TestBenchmarkEcho1-4 10000000 186 ns/opBenchmarkEcho2-4 20000000 92.7 ns/opPASSok Test 4.044s 注意点 可以看出strings.join效率明显高 文件命名规范，源文件echo.go, 测试文件名称echo_test.go，文件必须以_test结尾 参考 https://jimmysong.io/go-practice/docs/go_unit_test.html]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[L14 Longest Common Prefix]]></title>
    <url>%2F2018-11-13-L14-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[题目描述Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1:12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2:12Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot; Explanation: There is no common prefix among the input strings.Note:All given inputs are in lowercase letters a-z. 解题思路1-两两逐个比较思路说明 两个比较，将比较的结果再和第三个比较，然后遍历全部 思路说明图 代码实现 C++ 8ms beats 31.62% 12345678910111213141516171819202122232425262728class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string ret; if(strs.size()==0) return ""; ret = strs[0]; for(int i = 1;i&lt;strs.size();i++)&#123; ret = longestCommonTwoString(strs[i], ret); &#125; return ret; &#125; string longestCommonTwoString(string str1, string str2)&#123; string ret=""; int l1 = str1.length(); int l2 = str2.length(); int lmin = l1&gt;l2?l2:l1; for(int i = 0; i&lt;lmin; i++)&#123; if(str1[i] != str2[i]) break; ret += str1[i]; &#125; return ret; &#125;&#125;; Golang 实现 12345678910111213141516171819202122232425262728func longestCommonPrefix(strs []string) string &#123; if len(strs) == 0 &#123; return "" &#125; ret := strs[0] for k:=1; k&lt;len(strs);k++&#123; str := strs[k] idx:=-1 for i:=0; i&lt;len(ret) &amp;&amp; i&lt;len(str); i++ &#123; if strings.HasPrefix(str, ret[0:i+1])&#123; idx = i+1 &#125;else&#123; break &#125; &#125; if idx == -1 &#123; ret = "" &#125;else&#123; ret = ret[0:idx] &#125; &#125; return ret&#125; 根据前缀获取的str[0:1]=”a”, str[0:0]为空 12345678910In [1]: astr="a"In [2]: astr[0:0]Out[2]: ''In [3]: astr[0:1]Out[3]: 'a'In [6]: astr[0:len(astr)] == astrOut[6]: True Golang和Python支持切片，故使用切片进行判断。 解题思路2 - 分支思想解题思路 Golang 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344func longestCommonPrefix(strs []string) string &#123; if len(strs) == 0 &#123; return "" &#125; return longestCommonPrefixDiv(strs, 0, len(strs)-1)&#125;func longestCommonPrefixDiv(strs[]string, left int, right int) string &#123; if left == right&#123; return strs[left] &#125;else&#123; mid := (left+right)/2 lstr := longestCommonPrefixDiv(strs, left, mid) rstr := longestCommonPrefixDiv(strs, mid+1, right) ret := twoWordLCP(lstr, rstr) return ret &#125;&#125;func twoWordLCP(lstr string, rstr string)string &#123; if len(lstr)&gt;len(rstr) &#123; lstr, rstr = rstr, lstr &#125; ret := lstr idx := -1 for i:=0;i&lt;len(lstr) ;i++ &#123; if strings.HasPrefix(rstr, ret[0:i+1]) &#123; idx = i+1 &#125;else&#123; break &#125; &#125; if idx == -1 &#123; return "" &#125;else&#123; return ret[0:idx] &#125;&#125; C++ 版本递归1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string ret; if(strs.size()==0) return ""; return longestCommonPrefixDiv(strs, 0, strs.size()-1); &#125;private: string longestCommonPrefixDiv(vector&lt;string&gt;&amp;strs, int left, int right) &#123; if(left==right)&#123; return strs[left]; &#125;else&#123; string lstr,rstr; int mid = (left+right)/2; lstr = longestCommonPrefixDiv(strs,left, mid); rstr = longestCommonPrefixDiv(strs,mid+1, right); return longestCommonTwoString(lstr, rstr); &#125; &#125; string longestCommonTwoString(string str1, string str2)&#123; string ret=""; int l1 = str1.length(); int l2 = str2.length(); int lmin = l1&gt;l2?l2:l1; for(int i = 0; i&lt;lmin; i++)&#123; if(str1[i] != str2[i]) break; ret += str1[i]; &#125; return ret; &#125;&#125;; 4ms beats 98%]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L13 Roman to Integer]]></title>
    <url>%2F2018-11-02-L13-Roman-to-Integer%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112131415161718192021222324252627罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。示例 4:输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路 遍历字符串，比较当前字符和后一个字符，判断是否加减当前值 主要问题是如何优化时间？ 使用map Go 12345678910111213141516171819202122func romanToInt(s string) int &#123; m := make(map[byte]int) m['I'] = 1 m['V'] = 5 m['X'] = 10 m['L'] = 50 m['C'] = 100 m['D'] = 500 m['M'] = 1000 l := len(s) r := 0 for i:=0; i&lt;l-1; i++ &#123; if m[s[i]] &gt;= m[s[i+1]]&#123; r += m[s[i]] &#125;else &#123; r -= m[s[i]] &#125; &#125; r += m[s[l-1]] return r&#125; Python 1234567891011121314151617class Solution(object): def romanToInt(self, s): """ :type s: str :rtype: int """ adict=&#123;'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000&#125; r = 0 l = len(s) for i in range(l-1): if adict[s[i]]&gt;=adict[s[i+1]]: r+=adict[s[i]] else: r-=adict[s[i]] r+=adict[s[l-1]] return r C++ 1234567891011121314151617181920212223242526class Solution &#123;public: int romanToInt(string s) &#123; int len = s.size(); int ret = 0; map&lt;char, int&gt; rn_map; rn_map['I'] = 1; rn_map['V'] = 5; rn_map['X'] = 10; rn_map['L'] = 50; rn_map['C'] = 100; rn_map['D'] = 500; rn_map['M'] = 1000; for(int i = 0;i&lt;len-1;i++)&#123; if (rn_map[s[i]]&gt;=rn_map[s[i+1]]) ret += rn_map[s[i]]; else ret -= rn_map[s[i]]; &#125; ret += rn_map[s[len-1]]; return ret; &#125;&#125;; golang时间在30ms，cpp时间在100ms左右， python最慢时间在170ms。 使用hash map1234567891011121314151617181920class Solution &#123;public: int romanToInt(string s) &#123; int len = s.size(); int ret = 0; unordered_map&lt;char, int&gt; rn_map = &#123;&#123;'I',1&#125;,&#123;'V',5&#125;, &#123;'X',10&#125;,&#123;'L',50&#125;,&#123;'C',100&#125;, &#123;'D',500&#125;,&#123;'M',1000&#125;&#125;; for(int i = 0;i&lt;len-1;i++)&#123; if (rn_map[s[i]]&gt;=rn_map[s[i+1]]) ret += rn_map[s[i]]; else ret -= rn_map[s[i]]; &#125; ret += rn_map[s[len-1]]; return ret; &#125;&#125;; 使用unordered_map时间在52ms，比map时间缩短快一倍。 对比golang的执行时间，可以看出golang中map也是hash实现。 两者区别 STL中，map 对应的数据结构是 红黑树。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 O(logN)。而 unordered_map 对应 哈希表，哈希表的特点就是查找效率高，时间复杂度为常数级别 O(1)， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 unordered_map 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 map 容器。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop编写MapReduce程序测试记录]]></title>
    <url>%2F2018-10-16-Hadoop%E7%BC%96%E5%86%99MapReduce%E7%A8%8B%E5%BA%8F%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[背景阅读《Hadoop权威指南》第二章有MaxTemperature的MapReduce演示代码说明。本文主要记录自己测试的过程以及遇到的问题： 如何使用IntelliJ IDEA编写Java版本的MapReduce程序打包以及测试 如何编写MapReduce任务的Python版本代码以及测试 如何在Hadoop集群中运行Python和Java两个MapReduce任务 代码实现源数据存放在/user/hadoop/input/inputs.txt中 123456[hadoop@qbj3-op-hadoop-001 ~]$ hdfs dfs -cat /user/hadoop/input/inputs.txt0067011990999991950051507004...9999999N9+00001+99999999999...0043011990999991950051512004...9999999N9+00221+99999999999...0043011990999991950051518004...9999999N9-00111+99999999999...0043012650999991949032412004...0500001N9+01111+99999999999...0043012650999991949032418004...0500001N9+00781+99999999999... Python版本Mapper1234567891011121314#!/usr/bin/env pythonfrom sys import stdinfrom re import matchseparator = ' 'MISSING = "9999"# input comes from STDIN (standard input)for line in stdin: line = line.strip() year = line[15:19] airTemperature = line[40:45] quality = line[45:46] if airTemperature != MISSING and match("[01459]", quality): print(year + separator + airTemperature) 使用本地数据进行Mapper测试 123456[hadoop@qbj3-op-hadoop-001 20181015]$ cat inputs.txt |python MaxTemperatureMapper.py 1950 +00001950 +00221950 -00111949 +01111949 +0078 Reducer123456789101112131415161718#!/usr/bin/env pythonfrom sys import stdinseparator = ' 'previous_key = NonemaxValue = -9999999999999999for line in stdin: (key, value) = line.strip().split(separator) if previous_key and previous_key != key: print(previous_key + separator + maxValue) maxValue = value else: #initial branch maxValue = str(max(int(maxValue), int(value))) previous_key = keyif previous_key: print(previous_key + separator + maxValue) 使用本地数据进行Reducer测试: 123[hadoop@qbj3-op-hadoop-001 20181015]$ cat inputs.txt |python MaxTemperatureMapper.py |sort|python MaxTemperatureReducer.py 1949 1111950 22 在hadoop集群中运行需要将Mapper和Reducer的代码发送DataNode节点上,然后在NameNode中运行: 12345hadoop jar /home/hadoop/hadoop-2.9.1/share/hadoop/tools/lib/hadoop-streaming-2.9.1.jar -mapper /home/hadoop/opdir/20181015/MaxTemperatureMapper.py -reducer /home/hadoop/opdir/20181015/MaxTemperatureReducer.py -input /user/hadoop/input/inputs.txt -output /user/hadoop/output Hadoop提供MapReduce的API接口Hadoop Streaming，运行使用非Java的其他语言实现自己的map和reduce函数。 Java版本创建Maven项目 1、创建Maven Project 2、设置groupid和artifactsid 3、maven配置确认 如果修改maven仓库地址，需要修改settings.xml进行更新。 4、选择构建目录 5、创建代码目录结构 6、选择java目录设置source root 7、创建package 8、创建class 9、创建input目录 10、创建三个类文件 11、执行main设置 12、本地执行结果 Java源代码 MaxTemperatureMapper.java 123456789101112131415161718192021222324252627282930313233package org.culiu.data;import java.io.IOException;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Mapper;public class MaxTemperatureMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt;&#123; private static final int MISSING = 9999; @Override public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException&#123; String line = value.toString(); String year = line.substring(15,19); int airTemperature; if(line.charAt(40) == '+') &#123; airTemperature = Integer.parseInt(line.substring(41,45)); &#125;else&#123; airTemperature = Integer.parseInt(line.substring(40,45)); &#125; String quality = line.substring(45, 46); if (airTemperature != MISSING &amp;&amp; quality.matches("[01459]"))&#123; context.write(new Text(year), new IntWritable(airTemperature)); &#125; &#125;&#125; MaxTemperatureReducer.java 123456789101112131415161718192021package org.culiu.data;import java.io.IOException;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Reducer;public class MaxTemperatureReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;&#123; @Override public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException&#123; int maxValue = Integer.MIN_VALUE; for (IntWritable value : values)&#123; maxValue = Math.max(maxValue, value.get()); &#125; context.write(key, new IntWritable(maxValue)); &#125;&#125; MaxTemperature.java 123456789101112131415161718192021222324252627282930313233package org.culiu.data;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.io.Text;import org.apache.log4j.BasicConfigurator;public class MaxTemperature &#123; public static void main(String[] args) throws Exception&#123; BasicConfigurator.configure(); Configuration conf = new Configuration(); Job job = Job.getInstance(conf, "Max Temperature"); job.setJarByClass(MaxTemperature.class); job.setMapperClass(MaxTemperatureMapper.class); job.setReducerClass(MaxTemperatureReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); System.exit(job.waitForCompletion(true)? 0 : 1); &#125;&#125; 生成jar包 1、选择Main class 生成class的目录 2、创建jar包 选择Build-&gt;Build Artifacts 3、jar目录结构 在hadoop集群中运行1234567891011121314[hadoop@qbj3-op-hadoop-001 20181016]$ hdfs dfs -rm -r outputDeleted output[hadoop@qbj3-op-hadoop-001 20181016]$ hadoop jar /home/hadoop/opdir/20181016/maxtempature.jar org.culiu.data.MaxTemperature \ ./input/inputs.txt output[hadoop@qbj3-op-hadoop-001 20181016]$ hdfs dfs -ls outputFound 2 items-rw-r--r-- 2 hadoop supergroup 0 2018-10-16 15:21 output/_SUCCESS-rw-r--r-- 2 hadoop supergroup 17 2018-10-16 15:21 output/part-r-00000[hadoop@qbj3-op-hadoop-001 20181016]$ hdfs dfs -cat output/part-r-000001949 1111950 22 参考资料 Real time big data analytics https://www.cnblogs.com/huxinga/p/6868074.html Python执行MapReduce任务]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inception源码改进]]></title>
    <url>%2F2018-09-04-Inception%E6%BA%90%E7%A0%81%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[添加osc的recursion-method dsns方法支持RDS从库延迟保护背景项目在使用Inception的时候，对于大表需要考虑对延迟的控制，会使用到pt-online-schema-change的–recursion-method。公司在使用RDS数据库，故对于osc只能使用–recursion-method=dsn这种方式。目前inception不支持这种方式，故研究其代码。同时也是对MySQL set variable这个SQL对应的背后知识有源码层次的了解。本篇目前在RDS数据库情况，使用Inception对于大表alter的操作保护方案，支持指定从库IP列表的dsn方式。 MySQL gdb调试打印宏变量1gdb --args /usr/local/mysql/bin/Inception --defaults-file=/usr/local/mysql/etc/inception.cnf 针对gdb过程中遇到的 optimized out，参照How to compile without optimizations -O0 using CMake进行处理。选择方式在CMakeLists.txt中加入: 12SET(CMAKE_CXX_FLAGS &quot;-O0 -g3 -gdwarf-2&quot;)SET(CMAKE_C_FLAGS &quot;-O0 -g3 -gdwarf-2&quot;) 123456789101112(gdb) b log_calc_max_agesBreakpoint 1 at 0x19b08c2: file /home/guosong/source/mysql-5.7.17/storage/innobase/log/log0log.cc, line 724.(gdb) r(gdb) p LSN_MAX$2 = 18446744073709551615(gdb) info macro LSN_MAXDefined at /home/guosong/source/mysql-5.7.17/storage/innobase/include/log0types.h:40 included at /home/guosong/source/mysql-5.7.17/storage/innobase/include/mtr0mtr.h:31 included at /home/guosong/source/mysql-5.7.17/storage/innobase/include/buf0buf.ic:33 included at /home/guosong/source/mysql-5.7.17/storage/innobase/include/buf0buf.h:2477 included at /home/guosong/source/mysql-5.7.17/storage/innobase/log/log0log.cc:43#define LSN_MAX IB_UINT64_MAX 使用如下方法 123cmake -DCMAKE_INSTALL_PREFIX=/home/guosong/mysql5717 \-DDOWNLOAD_BOOST=0 -DWITH_BOOST=./boost/boost_1_59_0/ \-DWITH_DEBUG=1 -DCMAKE_C_FLAGS=&quot;-O0 -ggdb3&quot; ctags支持ic文件将下面内容加入到~/.ctags文件中： 123456--c++-kinds=+p--fields=+iaS--extra=+q--langdef=errmsg--regex-errmsg=/^(ER_[A-Z0-9_]+)/\1/--langmap=errmsg:(errmsg*.txt),c:+.ic,yacc:+.yy 参考资料https://dev.mysql.com/doc/dev/mysql-server/8.0.12/EXAMPLE_SETUP_FOR_CTAGS.html 以inception_osc_recursion_method枚举变量为例变量类型 作用域 类型 存储地方 涉及文件 Session SESSION_VAR struct system_variables sql/sql_class.h Global GLOBAL_VAR 按照类型存储 sql/mysqld.cc和sql/mysqld.h set variable调用关系12345678910111213141516171819(gdb) bt#0 find_type (lib=0xfdf370 &lt;Sys_inception_osc_recursion_method+208&gt;, find=0x7ffff0004c00 "processlist", length=11, part_match=false) at /opt/source/inception/sql/strfunc.cc:123#1 0x0000000000707d0f in Sys_var_typelib::do_check (this=0xfdf2a0 &lt;Sys_inception_osc_recursion_method&gt;, thd=0x1005f40, var=0x7ffff0004cc0) at /opt/source/inception/sql/sys_vars.h:288#2 0x00000000006299b4 in sys_var::check (this=0xfdf2a0 &lt;Sys_inception_osc_recursion_method&gt;, thd=0x1005f40, var=0x7ffff0004cc0) at /opt/source/inception/sql/set_var.cc:213#3 0x000000000062a742 in set_var::check (this=0x7ffff0004cc0, thd=0x1005f40) at /opt/source/inception/sql/set_var.cc:624#4 0x00000000006a2fe1 in mysql_execute_inception_set_command (thd=0x1005f40) at /opt/source/inception/sql/sql_parse.cc:4219#5 0x00000000006a31a7 in mysql_execute_inception_command (thd=0x1005f40) at /opt/source/inception/sql/sql_parse.cc:4255#6 0x00000000006add22 in mysql_check_command (thd=0x1005f40) at /opt/source/inception/sql/sql_parse.cc:7794#7 0x00000000006b91e4 in mysql_process_command (thd=0x1005f40, parser_state=0x7ffff7fe8c80) at /opt/source/inception/sql/sql_parse.cc:11636#8 0x00000000006b9261 in mysql_parse (thd=0x1005f40, length=66, parser_state=0x7ffff7fe8c80) at /opt/source/inception/sql/sql_parse.cc:11664#9 0x000000000069ad11 in dispatch_command (command=COM_QUERY, thd=0x1005f40, packet=0x100a4d1 "inception set session inception_osc_recursion_method='processlist'", packet_length=66) at /opt/source/inception/sql/sql_parse.cc:1059#10 0x0000000000698a30 in do_command (thd=0x1005f40) at /opt/source/inception/sql/sql_parse.cc:489#11 0x0000000000673dd0 in do_handle_one_connection (thd_arg=0x1005f40) at /opt/source/inception/sql/sql_connect.cc:926#12 0x0000000000673b9a in handle_one_connection (arg=0x1005f40) at /opt/source/inception/sql/sql_connect.cc:842#13 0x00007ffff7bc6e25 in start_thread () from /lib64/libpthread.so.0#14 0x00007ffff6c96bad in clone () from /lib64/libc.so.6 在find_type中会对参数进行比较进行比较，判断字符串是否和符合预期，不符合预期报语法错误。 支持recursion_method为dsn类型代码分析在Inception中使用Sys_var_enum类型支持recursion_method的设置。这是一个枚举类型，只支持固定的值。 1234567const char *osc_recursion_method[]= &#123;"processlist", "hosts", "none", "dsn", NullS&#125;;static Sys_var_enum Sys_inception_osc_recursion_method( "inception_osc_recursion_method", "Preferred recursion method used to find slaves.", SESSION_VAR(inception_osc_recursion_method), CMD_LINE(REQUIRED_ARG), osc_recursion_method, DEFAULT(recursion_method_processlist), NO_MUTEX_GUARD, NOT_IN_BINLOG); 123456789#sql/sys_vars.henum enum_osc_recursion_method&#123; recursion_method_processlist= 0, recursion_method_hosts= 1, recursion_method_none = 2, recursion_method_unspec=3, recursion_method_dsn=4&#125;; 对osc_recursion_method加dsn之后，可以设置inception_osc_recursion_method为dsn，否则报错。 12345678910mysql&gt; inception set inception_osc_recursion_method='dsn';Query OK, 0 rows affected (2.88 sec)mysql&gt; inception get variables 'inception_osc_recursion_method';+--------------------------------+-------+| Variable_name | Value |+--------------------------------+-------+| inception_osc_recursion_method | dsn |+--------------------------------+-------+1 row in set (0.00 sec) 但是实际pt-osc在设置dsn为如下模式: 1dsn=h=192.40.120.26,P=4500,D=dpadmin,t=dsns_5627 这个不是一个固定的值，而是随着操作端口的不同，t的值是可以变化的，例如dsns_4300。所以这里无法使用enum类型的，如果支持这种的话，需要使用Sys_var_charptr类型。 将enum修改为string类型两者变量继承关系 Sys_var_charptr Sys_var_enum Sys_var_charptr只支持Global变量 修改代码 修改sql/mysqld.h 1extern char* inception_osc_recursion_method; 修改sql/mysqld.ccGlobal变量需要修改sql/mysqld.cc，Session级别变量在sql/sql_class.h中定义即可。 123//Added by Guosong 20180905 STARTchar* inception_osc_recursion_method= NULL;//Added by Guosong 20180905 END sql/sys_var.cc 123456789101112131415//Modified by Guosong START 20180905/*const char *osc_recursion_method[]= &#123;"processlist", "hosts", "none", "dsn", NullS&#125;;static Sys_var_charptr Sys_inception_osc_recursion_method( "inception_osc_recursion_method", "Preferred recursion method used to find slaves.", SESSION_VAR(inception_osc_recursion_method), CMD_LINE(REQUIRED_ARG), osc_recursion_method, DEFAULT("none"), NO_MUTEX_GUARD, NOT_IN_BINLOG);*/static Sys_var_charptr Sys_inception_osc_recursion_method( "inception_osc_recursion_method", "Preferred recursion method used to find slaves.", GLOBAL_VAR(inception_osc_recursion_method), CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG);//Modified by Guosong END 20190905 修改sql/sql_parse.cc 12sprintf(cmd_line, &quot;--recursion-method=%s&quot;, ¦ inception_osc_recursion_method); 测试 123456789101112131415161718192021mysql&gt; inception set inception_osc_recursion_method='processlist';Query OK, 0 rows affected (0.00 sec)mysql&gt; inception get variables 'inception_osc_recursion_method';+--------------------------------+-------------+| Variable_name | Value |+--------------------------------+-------------+| inception_osc_recursion_method | processlist |+--------------------------------+-------------+1 row in set (0.00 sec)mysql&gt; inception set inception_osc_recursion_method='dsn=h=10.40.120.26,P=4300,D=dpadmin,t=dsns_5627';Query OK, 0 rows affected (0.00 sec)mysql&gt; inception get variables 'inception_osc_recursion_method';+--------------------------------+-------------------------------------------------+| Variable_name | Value |+--------------------------------+-------------------------------------------------+| inception_osc_recursion_method | dsn=h=10.40.120.26,P=4300,D=dpadmin,t=dsns_5627 |+--------------------------------+-------------------------------------------------+1 row in set (0.00 sec) 改成Global ReadOnly更合适 123456static Sys_var_charptr Sys_inception_osc_recursion_method( "inception_osc_recursion_method", "Preferred recursion method used to find slaves.", READ_ONLY GLOBAL_VAR(inception_osc_recursion_method), CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG); 12345678910mysql&gt; inception get variables 'inception_osc_recursion_method';+--------------------------------+----------------------+| Variable_name | Value |+--------------------------------+----------------------+| inception_osc_recursion_method | dsn=D=dpadmin,t=dsns |+--------------------------------+----------------------+1 row in set (0.00 sec)mysql&gt; inception set inception_osc_recursion_method='processlist';ERROR 2575 (HY000): Variable 'inception_osc_recursion_method' is a read only variable. 这种方式可以支持dns的方式，不过需要操作的主库存在dpadmin.dsns表，其保存对应的从库IP列表，用于操作大表的保护工作。 Inception的osc调用改进osc调用没有使用到chunk-size的限制尽管Inception的配置文件中设置osc相关chunk限制参数，具体如下： 12345678mysql&gt; inception get variables '%chunk%'; +--------------------------------+----------+| Variable_name | Value |+--------------------------------+----------+| inception_osc_chunk_size | 500 || inception_osc_chunk_size_limit | 4.000000 || inception_osc_chunk_time | 1.000000 |+--------------------------------+----------+ 但是在sql/sql_parse.cc:mysql_execute_alter_table_osc中拼接pt-online-schema-change的命令时候，只使用到chunk_time: 123oscargv[count++] = strdup("--chunk-time");sprintf(cmd_line, "%f", thd-&gt;variables.inception_osc_chunk_time);oscargv[count++] = strdup(cmd_line); 我们使用这样的inception进行线上改大表的时候，遇到超多慢查询情况，原表操作变慢。 因此需要加上chunk_size限制。 123oscargv[count++] = strdup("--chunk-size");sprintf(cmd_line, "%lu", thd-&gt;variables.inception_osc_chunk_size);oscargv[count++] = strdup(cmd_line); 在改大表的时候，可以将这个chunk-size再设置小一些。 将拼接的pt-online-schema-change打印到日志修改sql/sql_parse.cc:mysql_execute_alter_table_osc 123456789101112131415161718192021222324 sprintf(cmd_line, "D=%s,t=%s", sql_cache_node-&gt;dbname, sql_cache_node-&gt;tablename); oscargv[count++] = strdup(cmd_line); oscargv[count++] = NULL; //Added by guosong 2019-02-21-START DYNAMIC_STRING command; init_dynamic_string(&amp;command, oscargv[0],1024,1024); for(int i=1; i&lt;count-1;i++)&#123; dynstr_append(&amp;command, " "); dynstr_append(&amp;command, oscargv[i]); &#125; if(!opt_log_raw) general_log_write(thd, COM_QUERY, command.str, command.length); ////Added by guosong 2019-02-21-END... //Added by guosong 2019-02-21-START if(!opt_log_raw) general_log_write(thd, COM_QUERY, sql_cache_node-&gt;oscoutput-&gt;str, sql_cache_node-&gt;oscoutput-&gt;str_len); dynstr_free(&amp;command); //Added by guosong 2019-02-21-END 将pt-osc执行的结果也打印到日志中，这样方便查看哪些参数是否齐全，调用过程的执行结果，而不是仅仅在标准输出上。 参考 https://blog.csdn.net/slwang001/article/details/77343172 http://ourmysql.com/archives/945 https://www.cnblogs.com/cchust/p/3252117.html https://edu.aliyun.com/a/27029?spm=5176.11182482.0.0.Z8MZrV https://dev.mysql.com/doc/dev/mysql-server/8.0.12/classSys__var__enum.html]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
      <tags>
        <tag>MySQL内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mariadb原理和实现Notes]]></title>
    <url>%2F2018-08-31-Mariadb%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0Notes%2F</url>
    <content type="text"><![CDATA[背景学习Mariadb原理和实现，记录一些notes。 内存分配init_alloc_root测试 test.c 1234567891011121314#include &lt;stdio.h&gt;#include &lt;my_sys.h&gt;int main()&#123; MEM_ROOT mem_root; init_alloc_root(&amp;mem_root, 4096, 0, MY_THREAD_SPECIFIC); //char *p1 = (char*)alloc_root(&amp;mem_root, 128); //char *p2 = (char*)alloc_root(&amp;mem_root, 64); printf("HelloWorld!\n"); free_root(&amp;mem_root, 0); return 0;&#125; Makefile 12345678910MYSQL_INCLUDE= -I /home/guosong/source/mariadb-10.0.36/includeMYSQL_LIB = /home/guosong/source/mariadb-10.0.36/libmysql/libmysqlclient.aWALL = -fPIC -fno-exceptions -fno-rtti -g -DENABLED_DEBUG_SYNC -ggdb3 -DSAFE_MUTEX -DSAFEMALLOC -Wall -Wextra -Wformat-security -Wvla -Woverloaded-virtual -Wno-unused-parameter GCC=&quot;c++&quot;test:test.c $(GCC) -g $(WALL) -c test.c $(MYSQL_INCLUDE) $(GCC) -o test test.o $(MYSQL_LIB) -lpthread -lz -lm -ldl -lssl -lcrypto -ljemallocclean: rm -rf test *.o 方法 通过修改client/CMakeList.txt成功编译模拟编译此文件12MYSQL_ADD_EXECUTABLE(guosongtest guosongtest.c)TARGET_LINK_LIBRARIES(guosongtest mysqlclient) 然后查看其CMakeFiles/guosongtest.dir/link.txt找到其link的方式生成上面的Makefile gdb 123456789101112131415161718192021222324(gdb) l1 #include &lt;stdio.h&gt;2 #include &lt;my_sys.h&gt;34 int main()&#123;5 MEM_ROOT mem_root;6 init_alloc_root(&amp;mem_root, 4096, 4096, MY_THREAD_SPECIFIC);78 char *p1 = (char*)alloc_root(&amp;mem_root, 128);9 char *p2 = (char*)alloc_root(&amp;mem_root, 64);10 printf(&quot;HelloWorld!\n&quot;);(gdb) b 6Breakpoint 1 at 0x4025f8: file test.c, line 6.(gdb) sThe program is not being run.(gdb) rBreakpoint 1, main () at test.c:66 init_alloc_root(&amp;mem_root, 4096, 4096, MY_THREAD_SPECIFIC);(gdb) sinit_alloc_root (mem_root=0x7fffffffe040, block_size=4096, pre_alloc_size=4096, my_flags=65536) at /home/guosong/source/mariadb-10.0.36/mysys/my_alloc.c:6060 DBUG_ENTER(&quot;init_alloc_root&quot;);(gdb) bt#0 init_alloc_root (mem_root=0x7fffffffe040, block_size=4096, pre_alloc_size=4096, my_flags=65536) at /home/guosong/source/mariadb-10.0.36/mysys/my_alloc.c:60#1 0x0000000000402613 in main () at test.c:6]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Django使用多个数据库]]></title>
    <url>%2F2018-07-10-Django%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[背景现在的Django项目需要使用到多个数据库，一个是Django自带的库，一个是元数据库。本文使用Django自带的ORM模式访问多个库。演示的项目基于SQL审核项目基础上添加个性化功能。 步骤创建新的appProject的当前路径为/data/web/AuditSQL，该Project存在多个app，统一放到一个目录下面。 1234567891011[root@qbj3-op-wiki-00 apps]# pwd /data/web/AuditSQL/apps[root@qbj3-op-wiki-00 apps]# tree -L 1.|-- dpadmin|-- __init__.py|-- mstats|-- project_manager|-- __pycache__|-- scheduled_tasks`-- user_manager 所有app放到固定的目录下，故在startapp的时候需要指定目录。 1python manage.py startapp dpadmin /data/web/AuditSQL/apps/dpadmin 将新app添加到project中修改AuditSQL/settings.py中INSTALLED_APPS添加如下： 12345INSTALLED_APPS = [ ... 'scheduled_tasks', 'dpadmin',] 修改DATABASES添加多个DB123456789101112131415161718192021222324252627282930313233DATABASES = &#123; #'default': &#123;&#125;, 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'auditsql', 'USER': 'root', 'HOST': 'localhost', 'PASSWORD': '123.com', 'OPTIONS': &#123; 'init_command': "SET sql_mode='STRICT_TRANS_TABLES'", 'charset': 'utf8mb4' &#125; &#125;, 'dpadmin': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'dpadmin', 'USER': 'dba', 'HOST': 'XXXXXXXXXXX', 'PORT': 4300, 'PASSWORD': 'XXXXXXXXXXXXXXXXXXX', 'OPTIONS':&#123; 'charset': 'utf8' &#125; &#125;&#125;#构建APP和DB的映射关系DATABASE_ROUTERS = ['AuditSQL.database_router.DatabaseAppsRouter']DATABASE_APPS_MAPPING = &#123; 'scheduled_tasks':'default', 'dpadmin': 'dpadmin'&#125; 添加路由关系在AuditSQL Project目录文件夹中创建database_router.py文件，文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: utf-8 -*-from django.conf import settings DATABASE_MAPPING = settings.DATABASE_APPS_MAPPING class DatabaseAppsRouter(object): """ A router to control all database operations on models for different databases. In case an app is not set in settings.DATABASE_APPS_MAPPING, the router will fallback to the `default` database. Settings example: DATABASE_APPS_MAPPING = &#123;'app1': 'db1', 'app2': 'db2'&#125; """ def db_for_read(self, model, **hints): """"Point all read operations to the specific database.""" if model._meta.app_label in DATABASE_MAPPING: return DATABASE_MAPPING[model._meta.app_label] return None def db_for_write(self, model, **hints): """Point all write operations to the specific database.""" if model._meta.app_label in DATABASE_MAPPING: return DATABASE_MAPPING[model._meta.app_label] return None def allow_relation(self, obj1, obj2, **hints): """Allow any relation between apps that use the same database.""" db_obj1 = DATABASE_MAPPING.get(obj1._meta.app_label) db_obj2 = DATABASE_MAPPING.get(obj2._meta.app_label) if db_obj1 and db_obj2: if db_obj1 == db_obj2: return True else: return False return None # for Django 1.4 - Django 1.6 def allow_syncdb(self, db, model): """Make sure that apps only appear in the related database.""" if db in DATABASE_MAPPING.values(): return DATABASE_MAPPING.get(model._meta.app_label) == db elif model._meta.app_label in DATABASE_MAPPING: return False return None # Django 1.7 - Django 1.11 def allow_migrate(self, db, app_label, model_name=None, **hints): print db, app_label, model_name, hints if db in DATABASE_MAPPING.values(): return DATABASE_MAPPING.get(app_label) == db elif app_label in DATABASE_MAPPING: return False return None 通过inspectdb获取指定数据库对应models.py文件从Django文档中可知: 123--database DATABASESpecifies the database to introspect. Defaults to default. 默认只创建default，故创建dpadmin新APP对应的models.py文件命令如下: 12345#默认创建该库下面对应的所有表python manage.py inspectdb --database &apos;dpadmin&apos; &gt; models.py#创建指定表node_infopython manage.py inspectdb --database &apos;dpadmin&apos; node_info &gt; models.py 将该models.py拷贝到dpadmin新App下： 1mv models.py ./apps/dpadmin/models.py 测试使用shell交互模式进行测试，并使用ipython终端利于tab键提示和补全关键字： 12345678(venv_py36) [root@d89b6a65640c AuditSQL]# python manage.py shell -i ipythonPython 3.6.4 (default, May 17 2018, 06:03:23) Type 'copyright', 'credits' or 'license' for more informationIPython 6.4.0 -- An enhanced Interactive Python. Type '?' for help.In [1]: from dpadmin.models import NodeInfoIn [4]: NodeInfo.objects.count()Out[4]: 121 参考文档 Django 多数据库联用 Django inspectdb指定单个DB]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python性能分析]]></title>
    <url>%2F2018-05-18-Python%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Python性能分析 Python web 应用性能调优 Python profiling]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Profile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Graph 深度遍历]]></title>
    <url>%2F2018-05-18-graph-dfs%2F</url>
    <content type="text"><![CDATA[图表示 邻接矩阵 邻接链表 图遍历 BFS 使用队列 DFS 使用栈 DFS Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from collections import defaultdictclass Graph: def __init__(self): self.graph = defaultdict(list) def addEdge(self, u, v): self.graph[u].append(v) def DFSUtils(self, v, visited): visited[v] = True print(v) for i in self.graph[v]: if not visited[i]: self.DFSUtils(i, visited) def DFS(self, v): visited = [False] * len(self.graph) print("DFS results:") self.DFSUtils(v, visited) def BFS(self, v): visited = [False] * len(self.graph) queue = [v] visited[v] = True print("BFS results:") while queue: s = queue.pop(0) print(s, " ") for i in self.graph[s]: if not visited[i]: queue.append(i) visited[i] = Truedef main(): g = Graph() g.addEdge(0, 1) g.addEdge(0, 2) g.addEdge(1, 2) g.addEdge(2, 0) g.addEdge(2, 3) g.addEdge(3, 3) print("Following is DFS from (staring from vertex 2)") g.DFS(2) g.BFS(2)if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vimgdb]]></title>
    <url>%2F2018-04-09-vimgdb%2F</url>
    <content type="text"><![CDATA[说明单独使用gdb时候，需要通过另外一个窗口看代码。有点麻烦，所以产生了vimgdb，vim和gdb的结合。 配置vimgdb https://github.com/cpiger/vimgdb-for-vim7.4 https://blog.easwy.com/archives/advanced-vim-skills-vim-gdb-vimgdb-faq/ 检查vim是否包括gdb 12[guosong@dev-00 11:04:34 ~]$vim --version|grep gdb+cindent +gdb +multi_lang +termresponse 测试 启动vimgdb之后按space键 12file /home/guosong/mysql5627/bin/mysqldrun --defaults-file=/home/guosong/mysql5627/etc/my5627.cnf 打断点 1234b do_commandb dispatch_commandb mysql_parseb mysql_execute_command 使用截图 使用快捷键将屏幕竖着 12ctrl+wshift+l]]></content>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cache2go源码阅读]]></title>
    <url>%2F2018-03-14-cache2go%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[背景介绍cache2go是具有并发安全golang缓存库，其key具有过期特性。本文研究其代码，学习Go的并发编程。 主要类和函数说明创建CacheTable创建以myCache为名字的CacheTable结构指针 12// Accessing a new cache table for the first time will create it.cache := cache2go.Cache("myCache") Cache在cache.go中进行定义。以myCache作为key的map，其value为CacheTable结构体指针，支持多个CacheTable，其对应的名字为string类型。 1cache = make(map[string]*CacheTable) 如果这个map中不存在myCache的话，重新创建一个。 123456789101112131415161718192021func Cache(table string) *CacheTable &#123; mutex.RLock() t, ok := cache[table] mutex.RUnlock() if !ok &#123; mutex.Lock() t, ok = cache[table] // Double check whether the table exists or not. if !ok &#123; t = &amp;CacheTable&#123; name: table, items: make(map[interface&#123;&#125;]*CacheItem), &#125; cache[table] = t &#125; mutex.Unlock() &#125; return t&#125; 这些涉及到RLock以及Lock，从而保证并行安全，RLock为读锁, Lock为互斥锁。判断以table为名对应CacheTable结构体是否存在使用RLock，如果不存在，使用Mutex进行创建。这里涉及到CacheTable以及CacheItem两个struct，其关系如下图。 CacheTableCacheTable定义1234567891011121314151617181920212223type CacheTable struct &#123; sync.RWMutex // The table's name. name string // All cached items. items map[interface&#123;&#125;]*CacheItem // Timer responsible for triggering cleanup. cleanupTimer *time.Timer // Current timer duration. cleanupInterval time.Duration // The logger used for this table. logger *log.Logger // Callback method triggered when trying to load a non-existing key. loadData func(key interface&#123;&#125;, args ...interface&#123;&#125;) *CacheItem // Callback method triggered when adding a new item to the cache. addedItem func(item *CacheItem) // Callback method triggered before deleting an item from the cache. aboutToDeleteItem func(item *CacheItem)&#125; CacheTable 结构体说明 成员 成员类型 说明 sync.RWMutex 继承一个读写锁 name string cacheTable名称 items map类型，key为任意类型，value为CacheItem cacheTable的各个item cleanupTimer time.Timer 定时器，用于过期处理 cleanupInterval time.Duration 定时扫描interval logger log.Logger 日志句柄 loadData function 回调函数，加载key使用 addedItem function 添加一个item，参数为CacheItem aboutToDeleteItem function 在删除item之前回调 CacheTable函数 Count 123456// Count returns how many items are currently stored in the cache.func (table *CacheTable) Count() int &#123; table.RLock() defer table.RUnlock() return len(table.items)&#125; 这里加读锁，返回map的长度，比较简单。 Foreach 123456789// Foreach all itemsfunc (table *CacheTable) Foreach(trans func(key interface&#123;&#125;, item *CacheItem)) &#123; table.RLock() defer table.RUnlock() for k, v := range table.items &#123; trans(k, v) &#125;&#125; Foreach读操作，遍历map，并使用trans回调函数进行处理。 Set Callback 12345678910111213141516171819202122// SetAddedItemCallback configures a callback, which will be called every time// a new item is added to the cache.func (table *CacheTable) SetAddedItemCallback(f func(*CacheItem)) &#123; table.Lock() defer table.Unlock() table.addedItem = f&#125;// SetAboutToDeleteItemCallback configures a callback, which will be called// every time an item is about to be removed from the cache.func (table *CacheTable) SetAboutToDeleteItemCallback(f func(*CacheItem)) &#123; table.Lock() defer table.Unlock() table.aboutToDeleteItem = f&#125;// SetLogger sets the logger to be used by this cache table.func (table *CacheTable) SetLogger(logger *log.Logger) &#123; table.Lock() defer table.Unlock() table.logger = logger&#125; 使用Mutex锁。 expirationCheck 每次过期检查的时候，使用table.Lock进行控制。 123456789101112131415161718192021222324// To be more accurate with timers, we would need to update 'now' on every// loop iteration. Not sure it's really efficient though.now := time.Now()smallestDuration := 0 * time.Secondfor key, item := range table.items &#123; // Cache values so we don't keep blocking the mutex. item.RLock() lifeSpan := item.lifeSpan accessedOn := item.accessedOn item.RUnlock() if lifeSpan == 0 &#123; continue &#125; if now.Sub(accessedOn) &gt;= lifeSpan &#123; // Item has excessed its lifespan. table.deleteInternal(key) &#125; else &#123; // Find the item chronologically closest to its end-of-lifespan. if smallestDuration == 0 || lifeSpan-now.Sub(accessedOn) &lt; smallestDuration &#123; smallestDuration = lifeSpan - now.Sub(accessedOn) &#125; &#125;&#125; 遍历table.items这个map，判断当前时间时间和每个item的access时间以及生命周期liftSpan，如果过期，将其删除，否则判断全局最小时间smallestDuration，用于下次过期检查。 1234567// Setup the interval for the next cleanup run.table.cleanupInterval = smallestDurationif smallestDuration &gt; 0 &#123; table.cleanupTimer = time.AfterFunc(smallestDuration, func() &#123; go table.expirationCheck() &#125;)&#125; 这里涉及到time定时器。定时器等到smallestDuration之后，再进行新一轮的过期检查。 deleteInternal 123456789101112131415161718192021222324252627func (table *CacheTable) deleteInternal(key interface&#123;&#125;) (*CacheItem, error) &#123; r, ok := table.items[key] if !ok &#123; return nil, ErrKeyNotFound &#125; // Cache value so we don't keep blocking the mutex. aboutToDeleteItem := table.aboutToDeleteItem table.Unlock() // Trigger callbacks before deleting an item from cache. if aboutToDeleteItem != nil &#123; aboutToDeleteItem(r) &#125; r.RLock() defer r.RUnlock() if r.aboutToExpire != nil &#123; r.aboutToExpire(key) &#125; table.Lock() table.log("Deleting item with key", key, "created on", r.createdOn, "and hit", r.accessCount, "times from table", table.name) delete(table.items, key) return r, nil&#125; 首先判断要删除的key是否存在。存在的话，先解锁（table.Unlock），这里是为了不影响其他并发。回调删除前item需要做的函数。同样适用读锁，调用aboutToExpire(key)。这些操作完成之后，再table.Lock，真正进行map删除。 addInternal 123456789101112131415161718192021func (table *CacheTable) addInternal(item *CacheItem) &#123; // Careful: do not run this method unless the table-mutex is locked! // It will unlock it for the caller before running the callbacks and checks table.log("Adding item with key", item.key, "and lifespan of", item.lifeSpan, "to table", table.name) table.items[item.key] = item // Cache values so we don't keep blocking the mutex. expDur := table.cleanupInterval addedItem := table.addedItem table.Unlock() // Trigger callback after adding an item to cache. if addedItem != nil &#123; addedItem(item) &#125; // If we haven't set up any expiration check timer or found a more imminent item. if item.lifeSpan &gt; 0 &amp;&amp; (expDur == 0 || item.lifeSpan &lt; expDur) &#123; table.expirationCheck() &#125;&#125; 添加一样，添加操作前提是已经获取table.Lock。调用addedItem。 Add和Delete封装 1234567891011121314151617func (table *CacheTable) Add(key interface&#123;&#125;, lifeSpan time.Duration, data interface&#123;&#125;) *CacheItem &#123; item := NewCacheItem(key, lifeSpan, data) // Add item to cache. table.Lock() table.addInternal(item) return item&#125;// Delete an item from the cache.func (table *CacheTable) Delete(key interface&#123;&#125;) (*CacheItem, error) &#123; table.Lock() defer table.Unlock() return table.deleteInternal(key)&#125; Exists 和NotFoundAdd 1234567891011121314151617181920212223242526// Exists returns whether an item exists in the cache. Unlike the Value method// Exists neither tries to fetch data via the loadData callback nor does it// keep the item alive in the cache.func (table *CacheTable) Exists(key interface&#123;&#125;) bool &#123; table.RLock() defer table.RUnlock() _, ok := table.items[key] return ok&#125;// NotFoundAdd tests whether an item not found in the cache. Unlike the Exists// method this also adds data if they key could not be found.func (table *CacheTable) NotFoundAdd(key interface&#123;&#125;, lifeSpan time.Duration, data interface&#123;&#125;) bool &#123; table.Lock() if _, ok := table.items[key]; ok &#123; table.Unlock() return false &#125; item := NewCacheItem(key, lifeSpan, data) table.addInternal(item) return true&#125; Value 123456789101112131415161718192021222324252627// Value returns an item from the cache and marks it to be kept alive. You can// pass additional arguments to your DataLoader callback function.func (table *CacheTable) Value(key interface&#123;&#125;, args ...interface&#123;&#125;) (*CacheItem, error) &#123; table.RLock() r, ok := table.items[key] loadData := table.loadData table.RUnlock() if ok &#123; // Update access counter and timestamp. r.KeepAlive() return r, nil &#125; // Item doesn't exist in cache. Try and fetch it with a data-loader. if loadData != nil &#123; item := loadData(key, args...) if item != nil &#123; table.Add(key, item.lifeSpan, item.data) return item, nil &#125; return nil, ErrKeyNotFoundOrLoadable &#125; return nil, ErrKeyNotFound&#125; 根据key获取相关CacheItem，如果key存在的话，更新相关访问时间r.KeepAlive；如果不存在，判断是否设置loadData回调函数，如果设置的话，按照loadData规则创建相关key。 如例子中使用这种方法创建key： 12345678910111213141516171819202122232425func main() &#123; cache := cache2go.Cache("myCache") // The data loader gets called automatically whenever something // tries to retrieve a non-existing key from the cache. cache.SetDataLoader(func(key interface&#123;&#125;, args ...interface&#123;&#125;) *cache2go.CacheItem &#123; // Apply some clever loading logic here, e.g. read values for // this key from database, network or file. val := "This is a test with key " + key.(string) // This helper method creates the cached item for us. Yay! item := cache2go.NewCacheItem(key, 0, val) return item &#125;) // Let's retrieve a few auto-generated items from the cache. for i := 0; i &lt; 10; i++ &#123; res, err := cache.Value("someKey_" + strconv.Itoa(i)) if err == nil &#123; fmt.Println("Found value in cache:", res.Data()) &#125; else &#123; fmt.Println("Error retrieving value from cache:", err) &#125; &#125;&#125; Flush 12345678910111213// Flush deletes all items from this cache table.func (table *CacheTable) Flush() &#123; table.Lock() defer table.Unlock() table.log("Flushing table", table.name) table.items = make(map[interface&#123;&#125;]*CacheItem) table.cleanupInterval = 0 if table.cleanupTimer != nil &#123; table.cleanupTimer.Stop() &#125;&#125; Flush key重新分配items，历史的交给Go内存回收。 log 12345678// Internal logging method for convenience.func (table *CacheTable) log(v ...interface&#123;&#125;) &#123; if table.logger == nil &#123; return &#125; table.logger.Println(v)&#125; 日志封装，使用Println。 MostAccessed 12345678910111213// CacheItemPair maps key to access countertype CacheItemPair struct &#123; Key interface&#123;&#125; AccessCount int64&#125;// CacheItemPairList is a slice of CacheIemPairs that implements sort.// Interface to sort by AccessCount.type CacheItemPairList []CacheItemPairfunc (p CacheItemPairList) Swap(i, j int) &#123; p[i], p[j] = p[j], p[i] &#125;func (p CacheItemPairList) Len() int &#123; return len(p) &#125;func (p CacheItemPairList) Less(i, j int) bool &#123; return p[i].AccessCount &gt; p[j].AccessCount &#125; 创建CacheItemPair结构体，统计最常访问的key，实现Swap|Len|Less接口函数，为了sort.Sort排序创建仿函数。 1234567891011121314151617181920212223242526272829// MostAccessed returns the most accessed items in this cache tablefunc (table *CacheTable) MostAccessed(count int64) []*CacheItem &#123; table.RLock() defer table.RUnlock() p := make(CacheItemPairList, len(table.items)) i := 0 for k, v := range table.items &#123; p[i] = CacheItemPair&#123;k, v.accessCount&#125; i++ &#125; sort.Sort(p) var r []*CacheItem c := int64(0) for _, v := range p &#123; if c &gt;= count &#123; break &#125; item, ok := table.items[v.Key] if ok &#123; r = append(r, item) &#125; c++ &#125; return r&#125; 使用读锁，将map中items转换为CacheItemPair进行排序，返回访问次数大于count的CacheItem。 CacheItemCacheItem struct说明12345678910111213141516171819202122// CacheItem is an individual cache item// Parameter data contains the user-set value in the cache.type CacheItem struct &#123; sync.RWMutex // The item's key. key interface&#123;&#125; // The item's data. data interface&#123;&#125; // How long will the item live in the cache when not being accessed/kept alive. lifeSpan time.Duration // Creation timestamp. createdOn time.Time // Last access timestamp. accessedOn time.Time // How often the item was accessed. accessCount int64 // Callback method triggered right before removing the item from the cache aboutToExpire func(key interface&#123;&#125;)&#125; 成员名称 类型 说明 sync.RWMutex 继承读写锁 key interface{} key支持任意类型 data interace{} value支持任意类型 lifSpan time.Duration 寿命周期，单位为纳秒 createdOn time.Time 创建时间 accessedOn time.Time 访问时间 accessCount int64 访问次数 aboutToExpire func 在删除item之前调用的触发函数 CacheItem函数说明 NewCacheItem 1234567891011121314151617// NewCacheItem returns a newly created CacheItem.// Parameter key is the item's cache-key.// Parameter lifeSpan determines after which time period without an access the item// will get removed from the cache.// Parameter data is the item's value.func NewCacheItem(key interface&#123;&#125;, lifeSpan time.Duration, data interface&#123;&#125;) *CacheItem &#123; t := time.Now() return &amp;CacheItem&#123; key: key, lifeSpan: lifeSpan, createdOn: t, accessedOn: t, accessCount: 0, aboutToExpire: nil, data: data, &#125;&#125; KeepAlive 1234567// KeepAlive marks an item to be kept for another expireDuration period.func (item *CacheItem) KeepAlive() &#123; item.Lock() defer item.Unlock() item.accessedOn = time.Now() item.accessCount++&#125; 这里使用读写锁 元素获取 12345678910111213141516171819202122232425262728293031323334353637// LifeSpan returns this item's expiration duration.func (item *CacheItem) LifeSpan() time.Duration &#123; // immutable return item.lifeSpan&#125;// AccessedOn returns when this item was last accessed.func (item *CacheItem) AccessedOn() time.Time &#123; item.RLock() defer item.RUnlock() return item.accessedOn&#125;// CreatedOn returns when this item was added to the cache.func (item *CacheItem) CreatedOn() time.Time &#123; // immutable return item.createdOn&#125;// AccessCount returns how often this item has been accessed.func (item *CacheItem) AccessCount() int64 &#123; item.RLock() defer item.RUnlock() return item.accessCount&#125;// Key returns the key of this cached item.func (item *CacheItem) Key() interface&#123;&#125; &#123; // immutable return item.key&#125;// Data returns the value of this cached item.func (item *CacheItem) Data() interface&#123;&#125; &#123; // immutable return item.data&#125; 可能修改的数据，使用读锁，不修改的数据不加锁。 SetAboutToExpireCallback 1234567// SetAboutToExpireCallback configures a callback, which will be called right// before the item is about to be removed from the cache.func (item *CacheItem) SetAboutToExpireCallback(f func(interface&#123;&#125;)) &#123; item.Lock() defer item.Unlock() item.aboutToExpire = f&#125; 测试mycachedapp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( "fmt" "time" "github.com/muesli/cache2go" "os" "log")// Keys &amp; values in cache2go can be of arbitrary types, e.g. a struct.type myStruct struct &#123; text string moreData []byte&#125;func main() &#123; // Accessing a new cache table for the first time will create it. cache := cache2go.Cache("myCache") //Aadded for debug log := log.Logger&#123;&#125; log.SetOutput(os.Stdout) cache.SetLogger(&amp;log) // We will put a new item in the cache. It will expire after // not being accessed via Value(key) for more than 5 seconds. val := myStruct&#123;"This is a test!", []byte&#123;&#125;&#125; cache.Add("someKey", 5*time.Second, &amp;val) fmt.Printf("Now: %v.\n", time.Now()) // Let's retrieve the item from the cache. res, err := cache.Value("someKey") if err == nil &#123; fmt.Println("Found value in cache:", res.Data().(*myStruct).text) &#125; else &#123; fmt.Println("Error retrieving value from cache:", err) &#125; // Wait for the item to expire in cache. time.Sleep(10 * time.Second) res, err = cache.Value("someKey") if err != nil &#123; fmt.Println("Item is not cached (anymore).") &#125; // Add another item that never expires. cache.Add("someKey", 0, &amp;val) // cache2go supports a few handy callbacks and loading mechanisms. cache.SetAboutToDeleteItemCallback(func(e *cache2go.CacheItem) &#123; fmt.Println("Deleting:", e.Key(), e.Data().(*myStruct).text, e.CreatedOn()) &#125;) // Remove the item from the cache. cache.Delete("someKey") // And wipe the entire cache table. cache.Flush()&#125; 输出： 123456789101112131415[Adding item with key someKey and lifespan of 5s to table myCache][In Expiration check....][Expiration check installed for table myCache]Now: 2018-03-16 18:06:18.421989715 +0800 CST m=+0.000683071.Found value in cache: This is a test![In Expiration check....][Expiration check triggered after 4.999843946s for table myCache][In Expiration check....][Expiration check triggered after 161.058µs for table myCache][Deleting item with key someKey created on 2018-03-16 18:06:18.421813674 +0800 CST m=+0.000507035 and hit 1 times from table myCache]Item is not cached (anymore).[Adding item with key someKey and lifespan of 0s to table myCache]Deleting: someKey This is a test! 2018-03-16 18:06:28.42451005 +0800 CST m=+10.002926414[Deleting item with key someKey created on 2018-03-16 18:06:28.42451005 +0800 CST m=+10.002926414 and hit 0 times from table myCache][Flushing table myCache] 使用协程进行过期的判断。]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>cache2go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TiDB初始篇]]></title>
    <url>%2F2018-03-09-TiDB%E5%88%9D%E5%A7%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言看到TiDB发布的微信公众账号文章，TiDB 源码阅读系列文章，开始研究TiDB学习一些基本的Go开发以及SQL开发知识。更多的可以参照TiDB官方博客 TiDB编译源码编译 go环境 12bogon:tidb guosong$ go versiongo version go1.10 darwin/amd64 编译二进制 123git clone https://github.com/pingcap/tidb.git $GOPATH/src/github.com/pingcap/tidbcd $GOPATH/src/github.com/pingcap/tidbmake IDE工具源码使用intelliJ IDEA工具,打开tidb-server的main.go进行run 测试默认密码为空，完全支持MySQL协议123456789101112131415161718192021222324252627282930313233bogon:tidb guosong$ mysql -h 127.0.0.1 -P 4000 -u root -pEnter password:Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 1Server version: 5.7.1-TiDB-None MySQL Community Server (Apache License 2.0)Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; \s--------------mysql Ver 14.14 Distrib 5.6.20, for osx10.8 (x86_64) using EditLine wrapperConnection id: 1Current database:Current user: root@127.0.0.1SSL: Not in useCurrent pager: stdoutUsing outfile: &apos;&apos;Using delimiter: ;Server version: 5.7.1-TiDB-None MySQL Community Server (Apache License 2.0)Protocol version: 10Connection: 127.0.0.1 via TCP/IPServer characterset: latin1Db characterset: latin1Client characterset: utf8Conn. characterset: utf8TCP port: 4000]]></content>
      <tags>
        <tag>TiDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L5 Longest Palindromic Substring]]></title>
    <url>%2F2018-03-06-L5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[题目描述Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: 123Input: &quot;babad&quot;Output: &quot;bab&quot; Note: “aba” is also a valid answer. Example:123Input: &quot;cbbd&quot;Output: &quot;bb&quot; 解题思路 使用O(NNlogN)时间复杂度算法各个子串进行逐一判断，获取最长的回文子串 Go代码实现Go代码实现1——时间复杂度O(NNlogN)1234567891011121314151617181920212223242526272829303132333435func isPalindrome(str string) bool &#123; if len(str) == 0&#123; return false &#125; s := 0 e := len(str)-1 for s&lt;e &#123; if str[s] != str[e] &#123; return false &#125; s++ e-- &#125; return true&#125;func longestPalindrome(s string) string &#123; n := len(s) if n &lt;=1 &#123; return s &#125; maxInt:=0 ret := "" for i:=0;i&lt;n-1;i++ &#123; for j:=n;j&gt;i ;j-- &#123; if isPalindrome(s[i:j]) &amp;&amp; j-i+1&gt;maxInt &#123; maxInt = j-i+1 ret = s[i:j] &#125; &#125; &#125; return ret&#125; Runtime:756ms, 5.11%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L64 Minimum Path Sum]]></title>
    <url>%2F2018-03-06-L64-Minimum-Path-Sum%2F</url>
    <content type="text"><![CDATA[题目描述Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time.1234Example 1:[[1,3,1], [1,5,1], [4,2,1]] Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum. 解题思路 二维DP问题参照动态规划入门 优化存储空间的二维DP Go代码实现Go动态规划实现——二维1234567891011121314151617181920212223242526272829303132333435func min(a int, b int)int &#123; if a&lt;b &#123; return a &#125;else &#123; return b &#125;&#125;func minPathSum(grid [][]int) int &#123; n := len(grid) m := len(grid[0]) if n==0 || m==0 &#123; return 0 &#125; s := make([][]int,n) for i:=0; i&lt;n;i++ &#123; s[i] = make([]int,m) &#125; for i:=0;i&lt;n ;i++ &#123; for j:=0;j&lt;m ; j++ &#123; if i==0 &amp;&amp; j==0 &#123; s[i][j] = grid[i][j] &#125;else if i==0 &amp;&amp; j&gt;0 &#123; s[i][j] = grid[i][j] + s[i][j-1] &#125;else if i&gt;0 &amp;&amp; j==0 &#123; s[i][j] = grid[i][j] + s[i-1][j] &#125;else&#123; s[i][j] = grid[i][j] + min(s[i][j-1], s[i-1][j]) &#125; &#125; &#125; return s[n-1][m-1]&#125; Runtime:12ms, 100.0% Go代码实现——直接修改grid123456789101112131415161718192021222324252627282930func min(a int, b int)int &#123; if a&lt;b &#123; return a &#125;else &#123; return b &#125;&#125;func minPathSum(grid [][]int) int &#123; n := len(grid) m := len(grid[0]) if n==0 || m==0 &#123; return 0 &#125; for i:=0;i&lt;n ;i++ &#123; for j:=0;j&lt;m ; j++ &#123; if i==0 &amp;&amp; j==0 &#123; continue &#125;else if i==0 &amp;&amp; j&gt;0 &#123; grid[i][j] += grid[i][j-1] &#125;else if i&gt;0 &amp;&amp; j==0 &#123; grid[i][j] += grid[i-1][j] &#125;else&#123; grid[i][j] +=min(grid[i][j-1], grid[i-1][j]) &#125; &#125; &#125; return grid[n-1][m-1]&#125; Runtime:12ms, 100.0%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L300 Longest Increasing Subsequence]]></title>
    <url>%2F2018-03-05-L300-Longest-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[题目描述Given an unsorted array of integers, find the length of longest increasing subsequence. For example,Given [10, 9, 2, 5, 3, 7, 101, 18],The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? 解题思路 动态规划思想，状态转移方程式 1dp[i] = max&#123;dp[j]+1&#125; 其中j&lt;i &amp;&amp; A[j]&lt;=A[i] O(NlogN)时间复杂度 Go代码实现Go代码实现1——动态规划，O(N*N)时间复杂度12345678910111213141516171819202122func lengthOfLIS(nums []int) int &#123; n:=len(nums) if n == 0 &#123; return 0 &#125; ret:=1 dp := make([]int, n) for i:=0;i&lt;n;i++ &#123; dp[i] = 1 for j:=0; j&lt;i;j++ &#123; if nums[j]&lt;nums[i] &amp;&amp; dp[j]+1&gt;dp[i] &#123; dp[i] = dp[j]+1 &#125; if dp[i]&gt;ret&#123; ret = dp[i] &#125; &#125; &#125; return ret&#125; Go代码实现2——O(N*logN)时间复杂度12345678910111213141516171819202122232425262728293031323334func upper_bound(nums []int, target int, s int, e int) int &#123; if nums[e]&lt;target &#123; return e+1 &#125; for s&lt;e &#123; mid := s + (e-s)/2 if nums[mid]&lt;target &#123; s = mid+1 &#125;else &#123; e = mid &#125; &#125; return s&#125;func lengthOfLIS(nums []int) int &#123; n:=len(nums) if n == 0 &#123; return 0 &#125; end := make([]int, n+1) end[1] = nums[0] len := 1 for i:=1;i&lt;n;i++ &#123; pos := upper_bound(end,nums[i], 1,len) end[pos] = nums[i] if len&lt;pos &#123; len = pos &#125; &#125; return len&#125; 参考资料https://www.felix021.com/blog/read.php?1587]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L746 Min Cost Climbing Stairs]]></title>
    <url>%2F2018-03-05-L746-Min-Cost-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[题目描述On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1:12Input: cost = [10, 15, 20]Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.Example 2:12Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].Note:cost will have a length in the range [2, 1000].Every cost[i] will be an integer in the range [0, 999]. 解题思路 动态规划思想dp[i] = min(cost[i-1]+dp[i-1], cost[i-2]+dp[i-2]) Go代码实现Go代码实现——数组存储子问题解1234567891011121314151617181920212223242526func min(a int, b int)int &#123; if a&lt;b &#123; return a &#125;else&#123; return b &#125;&#125;func minCostClimbingStairs(cost []int) int &#123; n := len(cost) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return cost[0] &#125; dp := make([]int, n+1) for i:=2;i&lt;n+1;i++ &#123; dp[i] = min(cost[i-1]+dp[i-1], cost[i-2]+dp[i-2]) &#125; return dp[n]&#125; Runtime: 8ms Go代码实现——数组存储子问题解123456789101112131415161718192021222324252627func min(a int, b int)int &#123; if a&lt;b &#123; return a &#125;else&#123; return b &#125;&#125;func minCostClimbingStairs(cost []int) int &#123; n := len(cost) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return cost[0] &#125; dp := make([]int, n) dp[0] = cost[0] dp[1] = cost[1] for i:=2;i&lt;n;i++ &#123; dp[i] = min(dp[i-1], dp[i-2]) + cost[i] &#125; return min(dp[n-1],dp[n-2])&#125; Go代码实现——dp空间优化1234567891011121314151617181920func minCostClimbingStairs(cost []int) int &#123; n := len(cost) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return cost[0] &#125; a := 0 b := 0 for i:=0;i&lt;n;i++ &#123; t := min(a,b) + cost[i] a = b b = t &#125; return min(a,b)&#125; 参考资料：http://www.cnblogs.com/grandyang/p/8343874.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L322 Climbing Stairs]]></title>
    <url>%2F2018-03-02-L322-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[题目描述You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1:123456Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2:1234567Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 解题思路 动态规划思想dp[i] = dp[i-2] + dp[i-1]注意初始化条件dp[0] = 0dp[1] = 1dp[2] = {dp[1]+1（爬1个）,dp[0]+2（爬2个）} = dp[1] + dp[0]&lt;–more–&gt; Go代码实现Go动态规划实现——使用n个存储1234567891011121314151617181920func climbStairs(n int) int &#123; if n == 0 &#123; return 0 &#125; if n==1 &#123; return 1 &#125; dp := make([]int, n) dp[0] = 1 dp[1] = 2 for i:=2;i&lt;n;i++ &#123; dp[i] = dp[i-2]+dp[i-1] &#125; return dp[n-1]&#125; Runtime:0ms, 4.84% Go动态规划优化——使用三个变量实现12345678910111213141516171819202122func climbStairs(n int) int &#123; if n == 0 &#123; return 0 &#125; if n==1 &#123; return 1 &#125; a := 1 b := 2 ret := b for i:=2;i&lt;n;i++ &#123; ret = a+b a = b b = ret &#125; return ret&#125; 参考资料 http://www.cnblogs.com/grandyang/p/4079165.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L198 House Robber]]></title>
    <url>%2F2018-03-01-L198-House-Robber%2F</url>
    <content type="text"><![CDATA[L198题目描述You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Credits:Special thanks to @ifanchu for adding this problem and creating all test cases. Also thanks to @ts for adding additional test cases. 关键点给一组数，不能取相邻的两个数，获取最大和。例如数组nums[3, 10, 20, 32, 4]，其最大和为10+32=42 解题思路 使用动态规划思想 d(i) = max{d(i-2)+nums[i], d(i-1)} 判断依据是否获取当前值，结果返回d最后一个值即可。 Go代码实现Go代码实现112345678910111213141516171819202122232425262728func max(a int, b int) int &#123; if a&gt;b &#123; return a &#125;else&#123; return b &#125;&#125;func rob(nums []int) int &#123; n := len(nums) if n == 0&#123; return 0 &#125; if n == 1 &#123; return nums[0] &#125; sums := make([]int, n) sums[0] = nums[0] sums[1] = max(nums[0], nums[1]) for i:=2;i&lt;n;i++ &#123; sums[i] = max(sums[i-2]+nums[i], sums[i-1]) &#125; return sums[n-1]&#125; Runtime:0ms, 29.82% Go代码实现2从动态规划总结的表达式d(i) = max{d[i-2]+nums[i], d[i-1]}可以看出子问题的解只依赖于d[i-1]和d[i-2]两个变量，使用两个变量而不是sums数组进行一步优化动态规划的程序。 123456789101112131415161718192021222324252627282930func max(a int, b int) int &#123; if a&gt;b &#123; return a &#125;else&#123; return b &#125;&#125;func rob(nums []int) int &#123; n := len(nums) if n == 0&#123; return 0 &#125; if n == 1 &#123; return nums[0] &#125; a := 0 b := 0 maxSum := 0 for i:=0; i&lt;n; i++ &#123; maxSum = max(a+nums[i], b) a = b b = maxSum &#125; return maxSum&#125; Rumtime:0ms, 29.82% 相似问题L213 House Robber II题目描述This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. 解题思路 将问题L213转换为L198，进行两次判断包含首个元素和包含最后一个元素，判断两者的最大值。 Go代码实现1234567891011121314151617181920212223242526272829303132333435func max(a int, b int) int &#123; if a&gt;b &#123; return a &#125;else&#123; return b &#125;&#125;func rob(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return nums[0] &#125; return max(robNoCycle(nums[0:n-1]), robNoCycle(nums[1:]))&#125;func robNoCycle(nums []int) int &#123; n := len(nums) a := 0 b := 0 maxSum := 0 for i:=0; i&lt;n; i++ &#123; maxSum = max(a+nums[i], b) a = b b = maxSum &#125; return maxSum&#125; Runtime:0ms, 35.71%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L53-Maximum-Subarray]]></title>
    <url>%2F2018-02-28-53-Maximum-Subarray%2F</url>
    <content type="text"><![CDATA[题目描述Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. 解题思路动态规划思想以nums数组[-2,1,-3,4,-1]为例 dp[0]为-2 dp[1] = max(dp[0]+nums[1],1)=max(-2,1)=1 dp[2] = max(dp[1]+nums[2],-3)=max(1-3,-3)=-2 当前的sum为dp[i-1]+nums[i], nums[i]最大值 然后将maxSum和sum进行比较，取最大值 Go代码实现Go代码实现11234567891011121314151617181920212223242526272829func max(a int, b int)int &#123; if a&gt;b &#123; return a &#125;else&#123; return b &#125;&#125;func maxSubArray(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; if n == 1 &#123; return nums[0] &#125; sums := make([]int, n) maxSum := nums[0] sums[0] = nums[0] for i:=1;i&lt;n ; i++ &#123; sums[i] = max(sums[i-1]+nums[i], nums[i]) maxSum = max(sums[i], maxSum) &#125; return maxSum&#125; Go代码实现21234567891011121314151617181920212223func maxSubArray(nums []int) int &#123; n := len(nums) if n == 0 &#123; return 0 &#125; maxSum := nums[0] curSum := nums[0] for i:=1;i&lt;n ; i++ &#123; if curSum&lt;0 &#123; curSum = nums[i] &#125;else&#123; curSum += nums[i] &#125; if curSum&gt;maxSum &#123; maxSum = curSum &#125; &#125; return maxSum&#125; 参考文档 http://blog.csdn.net/liu2012huan/article/details/51296635]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L414-Third-Maximum-Number]]></title>
    <url>%2F2018-02-26-414-Third-Maximum-Number%2F</url>
    <content type="text"><![CDATA[题目描述Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). 12345678910111213141516Example 1:Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1.Example 2:Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead.Example 3:Input: [2, 2, 3, 1]Output: 1 Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 解题思路 使用三个变量 Go代码Go代码实现1234567891011121314151617181920212223import "math"func thirdMax(nums []int) int &#123; ret := []int&#123;math.MinInt64, math.MinInt64, math.MinInt64&#125; for _,n := range nums&#123; if n == ret[0] || n == ret[1] || n == ret[2] &#123; continue &#125; if n &gt; ret[0]&#123; ret = []int&#123;n, ret[0], ret[1]&#125; &#125;else if n&gt;ret[1] &#123; ret = []int&#123;ret[0], n, ret[1]&#125; &#125;else if n&gt;ret[2]&#123; ret = []int&#123;ret[0], ret[1], n&#125; &#125; &#125; if ret[2] == math.MinInt64&#123; return ret[0] &#125;else&#123; return ret[2] &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划入门]]></title>
    <url>%2F2018-02-01-dynamic-planning%2F</url>
    <content type="text"><![CDATA[硬币问题问题描述我们有面值为1元、3元和5元的硬币若干，如何使用更少的硬币凑成11元？ 问题分析规定dp[i] = j 表示凑成i元至少需要j个硬币。 i = 0，显然需要0个硬币凑成0元，即有dp[0] = 0i = 1，凑成1元需要硬币的数目为dp[1] = dp[0] + 1 = 1i = 2，凑成2元需要硬币的数目为dp[2] = dp[1] + 1 = 2i = 3，凑成3元需要硬币的数目有两种情况，dp[3] = dp[2] + 1 = 2 + 1= 3 , 还可以dp[3] = dp[3-3] + 1 = dp[0] + 1 = 1。通过比较两个最小值，可以获得dp[3] = 1i = 4，可以使用1元硬币dp[4] = dp[4-1] + 1 = 2 ，也可以使用3元硬币dp[4] = dp[4-3] + 1 = dp[1] + 1 = 2i = 5，要凑5元，可以使用下面三种： 使用1元硬币，dp[5] = dp[5-1] + 1 = dp[4] + 1 = 3 使用3元硬币，dp[5] = dp[5-3] + 1 = dp[2] + 1 = 3 使用5元硬币，dp[5] = dp[5-5] + 1 = dp[0] + 1 = 1于是dp[5] = 1 可以递归公式：d(i) = min{d[i-vj]+1 | vj属于{1,3,5}} 伪代码: 123456789Set Min[i] equal to Infinity for all of iMin[0]=0Min[1:S] = MaxValueFor i = 1 to SFor j = 0 to N - 1 If (Vj&lt;=i AND Min[i-Vj]+1&lt;Min[i])Then Min[i]=Min[i-Vj]+1Output Min[S] Go代码实现123456789101112131415161718package DPfunc testDp(s int) int &#123; v := []int&#123;1,3,5&#125; dp := make([]int,s+1) dp[0] = 0 for i:=1; i&lt;=s;i++ &#123; dp[i] = s for j:=0;j&lt;len(v) ; j++ &#123; if v[j]&lt;=i &amp;&amp; dp[i-v[j]]+1&lt;dp[i] &#123; dp[i] = dp[i-v[j]] + 1 &#125; &#125; &#125; return dp[s]&#125; 总结在求解凑成11元需要多少个硬币，没有直接计算dp[11]，而是将这个问题分解成许多个相同的子问题。依赖这些子问题解得到最终解。 最长非降子序列长度题目描述一个序列有N个数，例如5, 3, 4, 8, 6, 7，求这个序列最长非降子序列长度。 问题分析LIS表示最长非降序子列长度 前1个数的LIS长度为d(1)=1 (序列: 5) 前2个数的LIS长度为d(2)=1 (序列: 3，3前面没有比3小的) 前3个数的LIS长度为d(3)=2 (序列4有一个比它小的3)，所以等于d(2)+1 前4个数的LIS长度为d(4)=(序列: 3, 4, 8)，d(4) = max{d(1), d(2), d(3)} + 1 = 3 前5个数的LIS长度为d(5)=(序列：3，4，6), d(5) = max{d(1), d(2), d(3)} + 1 = 3 1234状态转移方程式d(i) = max&#123;1, d(j)+1&#125;，其中j&lt;i, A[j]&lt;=A[i]d(i)表示前i个数以A[i]结尾的LIS Go代码实现1234567891011121314151617181920212223func LIS(nums []int)int &#123; n := len(nums) dp := make([]int, n) for i:=0;i&lt;n;i++ &#123; dp[i] = 1 &#125; max := 1 j := 1 for j&lt;n &#123; for i:=0;i&lt;j;i++&#123; if nums[j]&gt;nums[i] &amp;&amp; dp[j]&lt;dp[i]+1 &#123; dp[j] = dp[i]+1 if dp[j]&gt;max &#123; max = dp[j] &#125; &#125; &#125; j++ &#125; return max&#125; 二维DP问题——中级题目描述平面上有N*M个格子，每个格子放着一定数量的苹果。从左上角的格子开始，每一步只能向下或者向右走，每次走到一个格子上就把格子里的苹果都收集起来。问最多能收集多少个苹果？ 解题思路 状态状态S[i][j]表示走到第(i,j)格子，最多能收集的苹果数目。从左边来S[i-1][j],从上边来S[i][j-1]。 状态转移方程式 1S[i][j] = A[i][j] + max&#123;S[i-1][j] if i &gt;0, S[i][j-1] if j &gt; 0&#125; Go代码实现Go代码实现123456789101112131415161718192021222324func TwoDiDp(nums [][]int) int &#123; n := len(nums) m := len(nums[0]) s := make([][]int,n) for i:=0;i&lt;n ;i++ &#123; s[i] = make([]int,m) &#125; for i:=0;i&lt;n;i++&#123; for j:=0;j&lt;m ;j++ &#123; if i==0 &amp;&amp;j == 0 &#123; s[i][j] = nums[i][j] &#125;else if i==0&amp;&amp;j&gt;0 &#123; s[i][j] = nums[i][j] + max(0, s[i][j-1]) &#125;else if j==0 &amp;&amp; i&gt;0 &#123; s[i][j] = nums[i][j] + max(s[i-1][j], 0) &#125;else&#123; s[i][j] = nums[i][j]+max(s[i-1][j], s[i][j-1]) &#125; &#125; &#125; return s[n-1][m-1]&#125; 测试用例12345678func TestCase3(t *testing.T) &#123; nums := [][]int&#123;&#123;7,8,9&#125;,&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;10,11,12&#125;&#125; ret := TwoDiDp(nums) if ret != 45 &#123; t.Error("TestCase3 failed") &#125;&#125; LeetCode测试题目 L64. Minimum Path Sum 参考文档 动态规划专题 http://www.cnblogs.com/skydreamteam/p/3652971.html 动态规划入门之硬币问题 http://blog.csdn.net/kerryfish/article/details/25563937 动态规划：从新手到专家 http://www.hawstein.com/posts/dp-novice-to-advanced.html]]></content>
      <tags>
        <tag>Dynamic Planning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L541 Reverse String II]]></title>
    <url>%2F2018-01-31-L541-Reverse-String-II%2F</url>
    <content type="text"><![CDATA[题目描述Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. 123Example:Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot; Restrictions:The string consists of lower English letters only.Length of the given string and k will in the range [1, 10000] 解题思路 在Python和Go中string都是const，不可以直接替换，故将其转换为list 使用二分进行reverse，reverse函数接收list、low、high，list为全量，只需要调整low和high即可 Go实现Go实现112345678910111213141516171819202122232425262728package L541import ( "strings")func reverse(strs []string, low int, high int) &#123; for low&lt;high &#123; strs[low], strs[high] = strs[high], strs[low] low++ high-- &#125;&#125;func reverseStr(s string, k int) string &#123; strs := strings.Split(s, "") n := len(strs) i := 0 for i&lt;n &#123; if i+k&gt;n &#123; reverse(strs, i, n-1) &#125;else&#123; reverse(strs, i, i+k-1) &#125; i = i+2*k &#125; return strings.Join(strs, "")&#125; Runtime: 9 ms 16.67% Go实现2 不使用strings库函数，使用bytes数组，将bytes和string之间进行转换 12345678910111213141516171819202122func reverse(bytes []byte, low int, high int) &#123; for low&lt;high &#123; bytes[low], bytes[high] = bytes[high], bytes[low] low++ high-- &#125;&#125;func reverseStr(s string, k int) string &#123; bytes := []byte(s) n := len(bytes) i := 0 for i&lt;n &#123; if i+k&gt;n &#123; reverse(bytes, i, n-1) &#125;else&#123; reverse(bytes, i, i+k-1) &#125; i = i+2*k &#125; return string(bytes)&#125; Runtime 5ms 58.33% 类似题目L557 Reverse Words in a String III12345678910111213141516171819202122232425func reverse(bytes []byte, low int, high int) &#123; for low&lt;high &#123; bytes[low], bytes[high] = bytes[high], bytes[low] low++ high-- &#125;&#125;func reverseWords(s string) string &#123; bytes := []byte(s) n := len(s) low := 0 high := 0 for high&lt;n &#123; for high&lt;n &amp;&amp; s[high]!= ' ' &#123; high++ &#125; reverse(bytes, low, high-1) low = high+1 high++ &#125; return string(bytes)&#125; Runtime:8ms, 100.00%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Auto_Jump 准备工作1]]></title>
    <url>%2F2018-01-26-Auto-Jump%2F</url>
    <content type="text"><![CDATA[背景刷微信公众账号的时候看到一篇文章AI 玩跳一跳的正确姿势，Auto-Jump 算法详解，觉得挺感兴趣的。再加上现在AI这么火，故按照文章上相关资料进行尝试。本系列文章记录尝试的过程以及遇到的问题。 OpencvOpencv安装在Mac安装Opencv，主要参照文章Mac下安装使用Python-OpenCV。遇到主要问题是brew update时候遇到git错误，后来通过重新安装brew根本解决。 Opencv测试人脸识别参照Face Recognition with Python, in Under 25 Lines of Code实现第一个人脸识别Python Demo。 123456789101112131415161718192021222324252627282930import sysimport cv2def test(image_path, casc_path): newPath = "new_" + image_path faceCascade = cv2.CascadeClassifier(casc_path) image = cv2.imread(image_path) gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) faces = faceCascade.detectMultiScale( gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30), flags=cv2.CASCADE_SCALE_IMAGE ) print "Found &#123;0&#125; faces!".format(len(faces)) # Draw a rectangle around the faces for (x, y, w, h) in faces: cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 1) cv2.imwrite(newPath, image)if __name__ == "__main__": imagePath = sys.argv[1] cascPath = sys.argv[2] test(imagePath, cascPath) 运行参数：1python2.7 Test_Face.py head.jpeg haarcascade_frontalface_default.xml 其中第一个参数为图片，第二个参数为frontface检查器。 程序中最关键的是face检测，也就是Line 37，结果返回检测的faces在图片的坐标，通过rectangle将这些face使用矩形框标记。 WebDriverAgent安装参照git上给出连接搭建WebDriverAgent，期间由于mac、IOS以及Xcode版本过低，统一都进行了升级。具体版本如下： Mac 10.13.3 High Sierra IOS 11.2.5 Xcode 9.2 端口转发 文档中给出是imobiledevice，在mac实现测试使用libimobiledevice。 1brew install libimobiledevice 测试使用iproxy进行端口转发 1iproxy 8100 8100 sign配置]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Opencv</tag>
        <tag>WebDriverAgent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L459 Repeated Substring Pattern]]></title>
    <url>%2F2018-01-18-L459-Repeated-Substring-Pattern%2F</url>
    <content type="text"><![CDATA[题目描述Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. 12345678910111213141516Example 1:Input: &quot;abab&quot;Output: TrueExplanation: It&apos;s the substring &quot;ab&quot; twice.Example 2:Input: &quot;aba&quot;Output: FalseExample 3:Input: &quot;abcabcabcabc&quot;Output: TrueExplanation: It&apos;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.) 解题思路思路1 从字符串str[0:n/2]分成n/2子串，判断是否以这个子串repeated成字符串str，如果是返回true，否则继续检查 O(N**2)时间复杂度 思路2 KMP算法思想，http://blog.csdn.net/v_july_v/article/details/7041827 Go代码实现Go代码实现112345678910111213141516171819202122232425262728func repeatedSubstringPattern(s string) bool &#123; n := len(s) mid := n/2 for i:=1;i&lt;=mid;i++ &#123; substr :=s[0:i] m := len(substr) flag := true for k:=0;k&lt;n; &#123; t:= m+k if m+k&gt;n&#123; t = n-1 &#125; tmp := s[k:t] if tmp != substr &#123; flag = false break &#125; k += m &#125; if flag &#123; return true &#125; &#125; return false&#125; Runtime: 20 ms 33.33% KMP算法代码实现1234567891011121314151617181920func repeatedSubstringPattern(s string) bool &#123; n := len(s) kmp := make([]int, n+1) i, j := 1, 0 for i&lt;n &#123; if s[i] == s[j] &#123; i++ j++ kmp[i] = j &#125;else if j==0 &#123; i++ &#125;else &#123; j = kmp[j] &#125; &#125; return kmp[n] != 0 &amp;&amp; (kmp[n] % (n-kmp[n]) == 0)&#125; 时间复杂度为O(n)，Runtime: 24 ms， 33.33% Go实现3 将s[1:]和s[0:n-1]组合一个字符串new_s，判断new_s是否在s中，通过系统的库函数进行判断。 12345678910func repeatedSubstringPattern(s string) bool &#123; sub1 := s[1:] sub2 := s[:len(s)-1] bigdick := sub1 + sub2 if strings.Contains(bigdick,s)&#123; return true &#125;else&#123; return false &#125;&#125; Runtime:19ms, 33.33% KMP算法思想问题描述有一个文本串S，和一个模式串P，现在要查找P在S中的位置。例如文本串S “BBC ABCDAB ABCDABCDABDE”，模式串P “ABCDABD”，结果P在S中的位置是15。 暴力匹配暴力匹配思想假设现在文本串S匹配到i位置，模式串P匹配到j位置，则有： 如果S[i] 等于 P[j]， 则i++,j++，继续匹配下一个字符 如果S[i] 不等于 P[j], 则将i回溯为i-j+1, j=0。匹配失败，重新归零和回溯。 如果所有S字符匹配完成之后，判断j是否等于模式串的长度，如果是，返回i-j，否则返回-1（未匹配上） 暴力匹配Go实现123456789101112131415161718192021func VolientMatch(s string, p string) int &#123; ns := len(s) np := len(p) i,j:=0, 0 for i&lt;ns &amp;&amp; j &lt;np &#123; if s[i] == p[j] &#123; i++ j++ &#125;else&#123; i = i - j + 1 fmt.Printf("i = %d\n", i) j = 0 &#125; &#125; if j == np &#123; return i-j &#125;else&#123; return -1 &#125;&#125; 针对给出例子，可以看出来i是0-15，文本串S中前15个字符都进行匹配了。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L387 First Unique Character in a String]]></title>
    <url>%2F2018-01-18-L387-First-Unique-Character-in-a-String%2F</url>
    <content type="text"><![CDATA[题目描述Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Examples: 12345s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. Note: You may assume the string contain only lowercase letters. 解题思路 题目中note说是字符串中包含的只有小写字母，故可以包含26个int的数组表示各个字符出现的次数 然后再从新遍历字符串，首次只出现一次的字符串的index返回 Go代码实现Go代码实现112345678910111213141516func firstUniqChar(s string) int &#123; m := make([]int, 26) for _, c := range s&#123; idx := int(c-'a') m[idx]++ &#125; for i, c := range s&#123; if m[c-'a'] == 1 &#123; return i &#125; &#125; return -1&#125; Runtime: 20ms 73.91% Go代码实现2123456789101112131415func firstUniqChar(s string) int &#123; var m [128]int for _, c := range s&#123; m[c]++ &#125; for i, c := range s&#123; if m[c] == 1 &#123; return i &#125; &#125; return -1&#125; 注意不能使用byte数组，存在越界情况,数组表示字符出现的次数，故不限制byte上限127]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L443 String Compression]]></title>
    <url>%2F2018-01-17-L443-String-Compression%2F</url>
    <content type="text"><![CDATA[题目描述Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array. Follow up:Could you solve it using only O(1) extra space? 12345678910111213141516171819202122232425262728293031Example 1:Input:[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Output:Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]Explanation:&quot;aa&quot; is replaced by &quot;a2&quot;. &quot;bb&quot; is replaced by &quot;b2&quot;. &quot;ccc&quot; is replaced by &quot;c3&quot;.Example 2:Input:[&quot;a&quot;]Output:Return 1, and the first 1 characters of the input array should be: [&quot;a&quot;]Explanation:Nothing is replaced.Example 3:Input:[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]Output:Return 4, and the first 4 characters of the input array should be: [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;].Explanation:Since the character &quot;a&quot; does not repeat, it is not compressed. &quot;bbbbbbbbbbbb&quot; is replaced by &quot;b12&quot;.Notice each digit has it&apos;s own entry in the array.Note:All characters have an ASCII value in [35, 126].1 &lt;= len(chars) &lt;= 1000. 解题思路 对连续的字符进行压缩，压缩的结果是字符以及对应的连续的次数，如果连续次数为1，不显示次数 返回结果为压缩后字符的总长度 同时，需要将chars修改为压缩后结果 Go代码实现Go代码实现11234567891011121314151617181920212223242526272829mport ( "strconv")func compress(chars []byte) int &#123; n:=len(chars) idx := 0 for i:=0;i&lt;n;i++ &#123; char := chars[i] count := 0 for i&lt;n &amp;&amp; chars[i] == char &#123; count++ i++ &#125; i-- chars[idx] = char idx++ if count &gt; 1 &#123; countStr := strconv.Itoa(count) for k:=0;k&lt;len(countStr);k++ &#123; chars[idx] = countStr[k] idx++ &#125; &#125; &#125; return idx&#125; Runtime 35ms 0.00%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L434 Number of Segments in a String]]></title>
    <url>%2F2018-01-17-L434-Number-of-Segments-in-a-String%2F</url>
    <content type="text"><![CDATA[题目描述Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. Example:12Input: &quot;Hello, my name is John&quot;Output: 5 解题思路 使用库函数 使用基本算法 更简洁做法：判断当前不为空以及前一个字符为空，即新增一个seg Go代码实现Go代码实现1123456789101112import "strings"func countSegments(s string) int &#123; c:=0 strs := strings.Split(s, " ") for _,str := range strs&#123; if str != ""&#123; c++ &#125; &#125; return c&#125; Runtime 2ms Go代码实现212345678910111213141516171819202122func countSegments(s string) int &#123; n := len(s) i := 0 for i&lt;n &amp;&amp; s[i] == ' ' &#123; i++ &#125; head := true w := 0 for i&lt;n &#123; if s[i] != ' '&#123; if head &#123; w++ head = false &#125; &#125;else&#123; head = true &#125; i++ &#125; return w&#125; 注意左右部分连续空字符Runtime 1ms Go代码实现31234567891011func countSegments(s string) int &#123; n := len(s) ret := 0 for i:=0;i&lt;n ; i++ &#123; if s[i] != ' ' &amp;&amp; (i==0 || s[i-1] ==' ') &#123; ret++ &#125; &#125; return ret&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L383 Ransom Note]]></title>
    <url>%2F2018-01-17-L383-Ransom-Note%2F</url>
    <content type="text"><![CDATA[题目描述Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note:You may assume that both strings contain only lowercase letters. 123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 解题思路 使用两个map表示字符串，判断第一个map中key是否存在于第二个map中，且value是否小于第二个map 使用一个128位的数组 Go代码实现Go代码实现1——使用map123456789101112131415161718192021222324252627func canConstruct(ransomNote string, magazine string) bool &#123; m1 := map[int32]int&#123;&#125; m2 := map[int32]int&#123;&#125; for _,c := range ransomNote &#123; if _,ok := m1[c];!ok &#123; m1[c] = 1 &#125;else &#123; m1[c] += 1 &#125; &#125; for _,c := range magazine &#123; if _,ok := m2[c];!ok &#123; m2[c] = 1 &#125;else &#123; m2[c] += 1 &#125; &#125; for k,v := range m1&#123; if v1, ok := m2[k];!ok || v&gt;v1 &#123; return false &#125; &#125; return true&#125; Runtime: 45 ms 38.10% Go代码实现212345678910111213141516func canConstruct(ransomNote string, magazine string) bool &#123; letter := make([]int32, 128) for _,n := range magazine&#123; letter[n] += 1 &#125; for _,n := range ransomNote&#123; letter[n]-=1 if letter[n]&lt;0 &#123; return false &#125; &#125; return true&#125; Runtime: 11 ms 80.95%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L345 Reverse Vowels of a String]]></title>
    <url>%2F2018-01-17-L345-Reverse-Vowels-of-a-String%2F</url>
    <content type="text"><![CDATA[题目描述Write a function that takes a string as input and reverse only the vowels of a string. Example 1:Given s = “hello”, return “holle”. Example 2:Given s = “leetcode”, return “leotcede”. Note:The vowels does not include the letter “y”. 解题思路 使用low和high两个索引进行遍历，如果两个是元音字母进行交换，否则哪个非元音字母进行low、high跳位 Go代码实现Go代码实现11234567891011121314151617181920212223242526272829303132import "strings"func isVowels(c string) bool &#123; vowels := []string&#123;"a", "e", "i", "o", "u", "A", "E", "I", "O", "U"&#125; for _,v := range vowels&#123; if c == v &#123; return true &#125; &#125; return false&#125;func reverseVowels(s string) string &#123; arr := strings.Split(s, "") low := 0 high := len(s)-1 for low&lt;high &#123; if isVowels(arr[low]) &amp;&amp; isVowels(arr[high])&#123; arr[low], arr[high] = arr[high], arr[low] low++ high-- &#125;else if !isVowels(arr[low]) &#123; low++ &#125;else if !isVowels(arr[high]) &#123; high-- &#125; &#125; return strings.Join(arr, "")&#125; Golang中string值不可以直接更改。Runtime: 41 ms 10.00% Go代码实现212345678910111213141516171819202122232425262728293031func isVowels(c byte) bool &#123; vowels := []byte&#123;'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'&#125; for _,v := range vowels&#123; if c == v &#123; return true &#125; &#125; return false&#125;func reverseVowels(s string) string &#123; ret := make([]byte, len(s)) low := 0 high := len(s)-1 for low&lt;=high &#123; if isVowels(s[low]) &amp;&amp; isVowels(s[high])&#123; ret[low], ret[high] = s[high], s[low] low++ high-- &#125;else if !isVowels(s[low]) &#123; ret[low] = s[low] low++ &#125;else if !isVowels(s[high]) &#123; ret[high] = s[high] high-- &#125; &#125; return string(ret)&#125; Runtime: 13 ms 35.00%使用字节数组，而非string数组]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intersection of Two Arrays]]></title>
    <url>%2F2018-01-16-Intersection-of-Two-Arrays%2F</url>
    <content type="text"><![CDATA[题目描述L349Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note:Each element in the result must be unique.The result can be in any order. L350Given two arrays, write a function to compute their intersection. Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.Follow up:What if the given array is already sorted? How would you optimize your algorithm?What if nums1’s size is small compared to nums2’s size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 解题思路 使用map实现 Go代码实现L34912345678910111213141516171819202122232425func intersection(nums1 []int, nums2 []int) []int &#123; m := map[int]int&#123;&#125; ret_map := map[int]int&#123;&#125; ret := []int&#123;&#125; for _,n := range nums1&#123; if _,ok := m[n];!ok &#123; m[n] = 1 &#125; &#125; for _,n := range nums2 &#123; if _,ok := m[n] ;ok&#123; if _,ok2 := ret_map[n]; !ok2&#123; ret_map[n]=1 &#125; &#125; &#125; for k := range ret_map&#123; ret = append(ret, k) &#125; return ret&#125; Runtime: 13 ms 10.53% L3501234567891011121314151617181920212223242526272829func intersect(nums1 []int, nums2 []int) []int &#123; m := map[int]int&#123;&#125; ret := map[int]int&#123;&#125; arr := []int&#123;&#125; for _,n := range nums1&#123; if _,ok := m[n];!ok &#123; m[n] = 1 &#125;else&#123; m[n] += 1 &#125; &#125; for _,n := range nums2 &#123; if _,ok := m[n];ok &#123; ret[n] += 1 &#125; &#125; for n,j := range ret&#123; k,_ := m[n] if k&gt;j &#123; k = j &#125; for i:=0;i&lt;k;i++ &#123; arr = append(arr, n) &#125; &#125; return arr&#125; Runtime: 12ms 15.38%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L448 Find All Numbers Disappeared in an Array]]></title>
    <url>%2F2018-01-15-L448-Find-All-Numbers-Disappeared-in-an-Array%2F</url>
    <content type="text"><![CDATA[题目描述Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: 12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] 解题思路 借助O(n)空间，使用arr表示各个a[i]对应的数是否存在，返回所有0的i+1 不借助额外空间，将a[i]对应的a[a[i]-1]设置为负，统计返回所有a[i]值为正的i+1 Go实现Go实现112345678910111213141516func findDisappearedNumbers(nums []int) []int &#123; arr := make([]int, len(nums)) for _,n := range nums&#123; arr[n-1] = 1 &#125; ret := []int&#123;&#125; for i,v := range arr&#123; if v == 0 &#123; ret = append(ret, i+1) &#125; &#125; return ret&#125; Runtime: 1308 ms 45.45% Go实现21234567891011121314151617181920func findDisappearedNumbers(nums []int) []int &#123; ret := []int&#123;&#125; for _,n := range nums&#123; if n&lt;0 &#123; n = -n &#125; val := n-1 if nums[val]&gt;0 &#123; nums[val] = - nums[val] &#125; &#125; for i,n := range nums&#123; if n &gt; 0&#123; ret = append(ret, i+1) &#125; &#125; return ret&#125; Runtime: 1516ms 18.18%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L654 Maximum Binary Tree]]></title>
    <url>%2F2018-01-10-L654-Maximum-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given an integer array with no duplicates. A maximum tree building on this array is defined as follow: The root is the maximum number in the array.The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.Construct the maximum tree by the given array and output the root node of this tree. Example 1: 12345678910Input: [3,2,1,6,0,5]Output: return the tree root node representing the following tree: 6 / \ 3 5 \ / 2 0 \ 1 Note:The size of the given array will be in the range [1,1000]. 解题思路 找出nums中的最大值以及idx，构建root节点 nums左部分递归生成左子树 nums右部分递归生成右子树 Go代码实现Go递归实现1234567891011121314151617181920212223242526func getMax(nums []int) (int, int) &#123; max := 0 idx := 0 for i,v := range nums&#123; if v&gt;max &#123; max = v idx = i &#125; &#125; return max, idx&#125;func constructMaximumBinaryTree(nums []int) *TreeNode &#123; if len(nums) == 0 &#123; return nil &#125; max, idx := getMax(nums) root := new(TreeNode) root.Val = max root.Left = constructMaximumBinaryTree(nums[0:idx]) root.Right = constructMaximumBinaryTree(nums[idx+1:]) return root&#125; Runtime: 130 ms 55.81% Go代码实现——使用low和high，避免数组分割12345678910111213141516171819202122232425func constructMaximumBinaryTree(nums []int) *TreeNode &#123; if len(nums) == 0 &#123; return nil &#125; return construct(nums, 0, len(nums))&#125;func construct(nums []int, low int, high int) *TreeNode &#123; if low&gt;high &#123; return nil &#125; mid := low for i:=low+1;i&lt;=high;i++&#123; if nums[i]&gt;nums[mid]&#123; mid = i &#125; &#125; root := new(TreeNode) root.Val = nums[mid] root.Left = construct(nums, low, mid-1) root.Right = construct(nums, mid+1, high) return root&#125; Runtime: 120 ms 65.12% 其他解法 http://www.cnblogs.com/grandyang/p/7513099.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L513 Find Bottom Left Tree Value]]></title>
    <url>%2F2018-01-10-L513-Find-Bottom-Left-Tree-Value%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, find the leftmost value in the last row of the tree. Example 1:123456789101112131415161718192021Input: 2 / \ 1 3Output:1Example 2: Input: 1 / \ 2 3 / / \ 4 5 6 / 7Output:7 Note: You may assume the tree (i.e., the given root node) is not NULL. 解题思路 深度递归遍历，记录各个层row节点信息，返回最深的第一个元素 深度递归遍历，不使用map 层次循环遍历，由左到右 层次遍历，由右到左，返回最后一个元素的val Go代码实现Go代码实现1——深度遍历，使用map12345678910111213141516171819202122232425262728func findBottomLeftValue(root *TreeNode) int &#123; m := map[int][]int&#123;&#125; maxDepth := 0 DFS(root, 0, &amp;maxDepth, m) return m[maxDepth][0]&#125;func DFS(root *TreeNode, level int, maxDepth *int, m map[int][]int) &#123; if root == nil &#123; return &#125; if _,ok := m[level];!ok&#123; m[level] = []int&#123;root.Val&#125; &#125;else&#123; m[level] = append(m[level], root.Val) &#125; if level&gt;*maxDepth &#123; *maxDepth = level &#125; DFS(root.Left, level+1, maxDepth, m) DFS(root.Right, level+1, maxDepth, m)&#125; Runtime: 22 ms 14.29% Go代码实现2——深度递归遍历，使用array123456789101112131415161718192021222324252627func findBottomLeftValue(root *TreeNode) int &#123; if root.Left == nil &amp;&amp; root.Right == nil&#123; return root.Val &#125; ret := []int&#123;&#125; maxDepth := 0 DFS(root, 0, &amp;maxDepth, &amp;ret) return ret[maxDepth-1]&#125;func DFS(root *TreeNode, level int, maxDepth *int, ret *[]int) &#123; if root == nil &#123; return &#125; if level&gt;*maxDepth &#123; *maxDepth = level if len(*ret)+1 == *maxDepth &#123; *ret = append(*ret, root.Val) &#125; &#125; DFS(root.Left, level+1, maxDepth, ret) DFS(root.Right, level+1, maxDepth, ret)&#125; Runtime: 32 ms 7.14% Go代码实现3——循环层次遍历，由左到右12345678910111213141516171819202122232425262728func findBottomLeftValue(root *TreeNode) int &#123; queue := []*TreeNode&#123;&#125; queue = append(queue, root) ret := root.Val for len(queue)&gt;0 &#123; n := len(queue) tmp := []*TreeNode&#123;&#125; for i:=0;i&lt;n;i++ &#123; current := queue[0] queue = queue[1:] if current.Left != nil &#123; tmp = append(tmp, current.Left) &#125; if current.Right != nil &#123; tmp = append(tmp, current.Right) &#125; if i==0 &#123; ret = current.Val &#125; &#125; queue = tmp &#125; return ret&#125; Runtime: 36 ms 7.14% Go代码实现4——层次遍历，由右到左12345678910111213141516171819func findBottomLeftValue(root *TreeNode) int &#123; queue := []*TreeNode&#123;&#125; queue = append(queue, root) current := root for len(queue)&gt;0 &#123; current = queue[0] queue = queue[1:] if current.Right != nil &#123; queue = append(queue, current.Right) &#125; if current.Left != nil &#123; queue = append(queue, current.Left) &#125; &#125; return current.Val&#125; Runtime: 19 ms 21.43%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L515 Find Largest Value in Each Tree Row]]></title>
    <url>%2F2018-01-10-L515-Find-Largest-Value-in-Each-Tree-Row%2F</url>
    <content type="text"><![CDATA[题目描述You need to find the largest value in each row of a binary tree. Example:123456789Input: 1 / \ 3 2 / \ \ 5 3 9 Output: [1, 3, 9] 解题思路 使用queue队列实现层次遍历，比较获取每层的最大值 深度递归实现，将各个level对应的最大值进行递归传递 Go代码实现Go代码实现——使用queue队列循环实现1234567891011121314151617181920212223242526272829303132333435363738func largestValues(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; ret := []int&#123;&#125; queue := []*TreeNode&#123;&#125; queue = append(queue, root) for len(queue)&gt;0 &#123; current := queue[0] max:=current.Val n := len(queue) tmp := []*TreeNode&#123;&#125; for i:=0;i&lt;n;i++ &#123; current = queue[0] queue = queue[1:] if current.Val &gt; max &#123; max = current.Val &#125; if current.Left!=nil &#123; tmp = append(tmp, current.Left) &#125; if current.Right != nil&#123; tmp = append(tmp, current.Right) &#125; &#125; queue = tmp ret = append(ret, max) &#125; return ret&#125; Runtime: 23 ms, 62.5% Go深度递归实现1234567891011121314151617181920212223242526func largestValues(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; ret := []int&#123;&#125; DFS(root, 0, &amp;ret) return ret&#125;func DFS(root *TreeNode, level int, ret *[]int) &#123; if root == nil &#123; return &#125; if len(*ret) &lt;= level &#123; *ret = append(*ret, root.Val) &#125;else&#123; if (*ret)[level] &lt;root.Val &#123; (*ret)[level] = root.Val &#125; &#125; DFS(root.Left, level+1, ret) DFS(root.Right, level+1, ret)&#125; Runtime: 23 ms, 62.5%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L450 Delete Node in a BST]]></title>
    <url>%2F2018-01-10-L450-Delete-Node-in-a-BST%2F</url>
    <content type="text"><![CDATA[题目描述Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove.If the node is found, delete the node.Note: Time complexity should be O(height of tree). Example: 1234567891011121314151617181920212223242526root = [5,3,6,2,4,null,7]key = 3 5 / \ 3 6 / \ \2 4 7Given key to delete is 3. So we find the node with value 3 and delete it.One valid answer is [5,4,6,2,null,null,7], shown in the following BST. 5 / \ 4 6 / \2 7Another valid answer is [5,2,6,null,4,null,7]. 5 / \ 2 6 \ \ 4 7 解题思路 二分遍历BST，发现对应的节点root，查找右子树最小的元素current，将root.left接到current.left上，返回root.right Go代码实现Go代码实现11234567891011121314151617181920212223242526272829303132333435func deleteNode(root *TreeNode, key int) *TreeNode &#123; if root == nil&#123; return root &#125; root = findDelete(root, key) return root&#125;func findDelete(root *TreeNode, key int)*TreeNode&#123; if root == nil &#123; return root &#125; if root.Val == key&#123; if root.Left == nil&#123; return root.Right &#125;else if root.Right == nil &#123; return root.Left &#125; current := root.Right for current.Left != nil &#123; current = current.Left &#125; current.Left = root.Left return root.Right &#125;else if root.Val&gt;key &#123; root.Left = findDelete(root.Left, key) &#125;else&#123; root.Right = findDelete(root.Right, key) &#125; return root&#125; Runtime: 1162 ms 27.78% 参考 https://leetcode.com/problems/delete-node-in-a-bst/discuss/93296/]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L449 Serialize and Deserialize BST]]></title>
    <url>%2F2018-01-10-L449-Serialize-and-Deserialize-BST%2F</url>
    <content type="text"><![CDATA[题目描述Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. 解题思路 使用前序遍历BST，然后按照前序遍历的结果生成二叉树 Python实现Python实现11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Definition for a binary tree node.import unittestclass TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ if not root: return "" data = "#" + str(root.val) data += self.serialize(root.left) data += self.serialize(root.right) return data def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ nums = [int(n) for n in data.split('#') if n != ''] root = self.initBST(nums) return root def initBST(self, nums): root = None for n in nums: root = self.insertNode(root, n) return root def insertNode(self, root, n): if not root: root = TreeNode(n) return root else: if root.val &gt; n: root.left = self.insertNode(root.left, n) else: root.right = self.insertNode(root.right, n) return rootclass Test(unittest.TestCase): code = Codec() def test_1(self): nums = [2, 1, 3] root = self.code.initBST(nums) data = self.code.serialize(root) t = self.code.deserialize(data) data1 = self.code.serialize(t) self.assertEqual(data, data1)if __name__ == '__main__': unittest.main() Runtime: 192 ms 15.49% 精简一下代码 123456789101112131415161718192021222324252627282930313233343536class Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ if not root: return "" data = "#" + str(root.val) data += self.serialize(root.left) data += self.serialize(root.right) return data def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ def doit(root, val): if not root: root = TreeNode(val) return root else: if root.val &gt; val: root.left = doit(root.left, val) else: root.right = doit(root.right,val) return root nums = [int(n) for n in data.split('#') if n != ''] root = None for val in nums: root = doit(root, val) return root Runtime: 173 ms 23.57% Python实现2— BST是BT的一种，故L297的方案解决此问题 https://dolphinsboy.github.io/2018-01-04-L297-Serialize-and-Deserialize-Binary-Tree/]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L437 Path Sum III]]></title>
    <url>%2F2018-01-10-L437-Path-Sum-III%2F</url>
    <content type="text"><![CDATA[题目描述You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. Example: 123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 解题思路思路1 前序递归遍历，记录每条路径以及其和curSum，判断curSum是否和target相同，相同的话加1 同时再判断path路径中是否有从给根开始的路径和等于target，相同的话再加1 思路2— 前序递归各个节点，判断各个节点上是否有路径和等于target 记录前一个节点的和，用于判断使用 Go代码实现Go代码实现1——前序递归遍历，记录路径12345678910111213141516171819202122232425262728func pathSum(root *TreeNode, sum int) int &#123; ret := 0 preOrder(root, []int&#123;&#125;, &amp;ret, 0, sum) return ret&#125;func preOrder(root *TreeNode, path []int, ret *int, curSum int, target int)&#123; if root == nil&#123; return &#125; curSum += root.Val path = append(path, root.Val) if curSum == target &#123; *ret += 1 &#125; t:= curSum for i:=0; i&lt;len(path)-1;i++ &#123; t -= path[i] if t == target &#123; *ret +=1 &#125; &#125; preOrder(root.Left, path, ret, curSum, target) preOrder(root.Right, path, ret, curSum, target)&#125; Go代码实现2——记录前一个节点的和以及递归判断各个节点123456789101112131415161718func pathSum(root *TreeNode, sum int) int &#123; if root == nil&#123; return 0 &#125; return preOrder(root, 0, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum)&#125;func preOrder(root *TreeNode, prev int, sum int) int&#123; if root == nil&#123; return 0 &#125; n := 0 cur := prev + root.Val if cur == sum&#123; n=1 &#125; return n+preOrder(root.Left, cur, sum)+preOrder(root.Right, cur, sum)&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L501 Find Mode in Binary Search Tree]]></title>
    <url>%2F2018-01-09-L501-Find-Mode-in-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.For example:1234567Given BST [1,null,2,2], 1 \ 2 / 2return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). 解题思路 使用map记录各个元素出现的次数，返回次数最多对应的元素list Go代码实现Go代码实现1——使用map123456789101112131415161718192021222324252627282930313233func findMode(root *TreeNode) []int &#123; m := map[int]int&#123;&#125; DFS(root, m) path := []int&#123;&#125; for _,v := range m&#123; path = append(path, v) &#125; sort.Ints(path) n:=len(path)-1 max:= path[n] ret := []int&#123;&#125; for k,v := range m&#123; if v==max &#123; ret = append(ret, k) &#125; &#125; return ret&#125;func DFS(root *TreeNode, m map[int]int) &#123; if root == nil &#123; return &#125; if _,ok := m[root.Val];!ok&#123; m[root.Val] = 1 &#125;else&#123; m[root.Val] += 1 &#125; DFS(root.Left, m) DFS(root.Right, m)&#125; Go代码实现2 https://www.cnblogs.com/grandyang/p/6436150.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L653 Two Sum IV Input is a BST]]></title>
    <url>%2F2018-01-08-L653-Two-Sum-IV-Input-is-a-BST%2F</url>
    <content type="text"><![CDATA[题目描述Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1:12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True Example 2:12345678910Input: 5 / \ 3 6 / \ \2 4 7Target = 28Output: False 解题思路解题思路1— 中序遍历生成有序数据组，然后使用二分法从有序数组中判断是否有两个数的和等于target 时间复杂度为O(N)+O(logN)，空间复杂度为O(N) 解题思路2 遍历BST，判断k-root.val是否这个BST中 时间复杂度为O(NlogN)，空间复杂度为O(1) Go代码实现Go代码实现——递归中序遍历、二分查找1234567891011121314151617181920212223242526272829func findTarget(root *TreeNode, k int) bool &#123; path := inOrder(root) low := 0 high := len(path)-1 for low&lt;high &#123; s:= path[low]+path[high] if s == k &#123; return true &#125;else if s&gt;k &#123; high-- &#125;else&#123; low++ &#125; &#125; return false&#125;func inOrder(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; path := []int&#123;&#125; path = append(path, inOrder(root.Left)...) path = append(path, root.Val) path = append(path, inOrder(root.Right)...) return path&#125; Runtime: 74 ms 29.41% Go代码实现——递归深度遍历+判断target是否在BST中12345678910111213141516171819202122232425262728293031func findTarget(root *TreeNode, k int) bool &#123; return find(root, root, k)&#125;func find(current *TreeNode,root *TreeNode, k int) bool &#123; if current == nil&#123; return false &#125; target := k - current.Val flag := target != current.Val &amp;&amp; isExistsBST(root, target) if flag &#123; return true &#125;else&#123; return find(current.Left, root, k) || find(current.Right, root, k) &#125;&#125;func isExistsBST(root *TreeNode, target int)bool &#123; if root == nil&#123; return false &#125; if target == root.Val &#123; return true &#125;else if target&gt;root.Val &#123; return isExistsBST(root.Right, target) &#125;else&#123; return isExistsBST(root.Left, target) &#125;&#125; Runtime:78ms, 23.53%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L671 Second Minimum Node In a Binary Tree]]></title>
    <url>%2F2018-01-08-L671-Second-Minimum-Node-In-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree. If no such second minimum value exists, output -1 instead. Example 1:12345678Input: 2 / \ 2 5 / \ 5 7Output: 5 Explanation: The smallest value is 2, the second smallest value is 5.Example 2:123456Input: 2 / \ 2 2Output: -1 Explanation: The smallest value is 2, but there isn’t any second smallest value. 解题思路 使用两个变量，一个表是最小，一个表示第二小，初始化为最大值 DFS遍历进行逐个比较 Go实现Go递归实现1234567891011121314151617181920212223242526272829func findSecondMinimumValue(root *TreeNode) int &#123; const MAX = 100000 first := MAX second := first-1 dfs(root, &amp;first, &amp;second) if second != MAX-1 &#123; return second &#125;else&#123; return -1 &#125;&#125;func dfs(root *TreeNode, first *int, second *int) &#123; if root == nil &#123; return &#125; if root.Val&lt;*first &#123; *first = root.Val &#125; if root.Val&lt;*second &amp;&amp; root.Val&gt;*first &#123; *second = root.Val &#125; dfs(root.Left, first, second) dfs(root.Right, first, second)&#125; Runtime: 2 ms 7.14%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L637 Average of Levels in Binary Tree]]></title>
    <url>%2F2018-01-06-L637-Average-of-Levels-in-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.Example 1:1234567Input: 3 / \ 9 20 / \ 15 7Output: [3, 14.5, 11] Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.Hence return [3, 14.5, 11].Note:The range of node’s value is in the range of 32-bit signed integer. 解题思路 使用BFS，利用队列循环实现 Go实现Go实现——BFS，队列循环实现1234567891011121314151617181920212223242526272829func averageOfLevels(root *TreeNode) []float64 &#123; if root == nil&#123; return []float64&#123;&#125; &#125; path := []float64&#123;&#125; queue := []*TreeNode&#123;&#125; queue = append(queue, root) for len(queue)&gt;0 &#123; n := len(queue) var s float64 for i:=0;i&lt;n ; i++ &#123; current := queue[0] queue = queue[1:] s+= float64(current.Val) if current.Left != nil &#123; queue = append(queue, current.Left) &#125; if current.Right != nil &#123; queue = append(queue, current.Right) &#125; &#125; path = append(path, s/float64(n)) &#125; return path&#125; Runtime: 44 ms 30.56%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L617 Merge Two Binary Trees]]></title>
    <url>%2F2018-01-06-L617-Merge-Two-Binary-Trees%2F</url>
    <content type="text"><![CDATA[题目描述Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1:1234567891011121314Input: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 Output: Merged tree: 3 / \ 4 5 / \ \ 5 4 7 Note: The merging process must start from the root nodes of both trees. 解题思路 同时递归先序遍历t1和t2 如果t1和t2都不为nil，将t1.val+=t2.val，返回t1 如果t1为nil, t2非nil，返回t2 其他返回t1 Go实现Go递归实现12345678910111213func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode &#123; if t1 != nil &amp;&amp; t2 != nil &#123; t1.Val += t2.Val t1.Left = mergeTrees(t1.Left, t2.Left) t1.Right = mergeTrees(t1.Right, t2.Right) return t1 &#125;else if t1 == nil &amp;&amp; t2 != nil&#123; return t2 &#125;else&#123; return t1 &#125;&#125; Runtime: 62 ms 72.46%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L606 Construct String from Binary Tree]]></title>
    <url>%2F2018-01-06-L606-Construct-String-from-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. Example 1:Input: Binary tree: [1,2,3,4]1234567891011121314151617181920212223 1 / \ 2 3 / 4 Output: &quot;1(2(4))(3)&quot;Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;, but you need to omit all the unnecessary empty parenthesis pairs. And it will be &quot;1(2(4))(3)&quot;.Example 2:Input: Binary tree: [1,2,3,null,4] 1 / \ 2 3 \ 4 Output: &quot;1(2()(4))(3)&quot;Explanation: Almost the same as the first example, except we can&apos;t omit the first parenthesis pair to break the one-to-one mapping relationship between the i 解题思路 先序遍历 判断如果左子树为nil，而右子树非nil，左子树作为()输出 Go实现Go实现——递归方法12345678910111213141516171819func tree2str(t *TreeNode) string &#123; if t == nil &#123; return "" &#125; s := "" s += strconv.Itoa(t.Val) if t.Left != nil &amp;&amp; t.Right != nil &#123; s += "(" + tree2str(t.Left) + ")" s += "(" + tree2str(t.Right) + ")" &#125; else if t.Left == nil &amp;&amp; t.Right != nil &#123; s += "()" s += "(" + tree2str(t.Right) + ")" &#125; else if t.Left != nil &amp;&amp; t.Right == nil &#123; s += "(" + tree2str(t.Left) + ")" &#125; return s&#125; Go实现——非递归方法 https://leetcode.com/problems/construct-string-from-binary-tree/discuss/103991]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L563. Binary Tree Tilt]]></title>
    <url>%2F2018-01-05-L563-Binary-Tree-Tilt%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes’ tilt. Example:12345678910Input: 1 / \ 2 3Output: 1Explanation: Tilt of node 2 : 0Tilt of node 3 : 0Tilt of node 1 : |2-3| = 1Tilt of binary tree : 0 + 0 + 1 = 1 Note:The sum of node values in any subtree won’t exceed the range of 32-bit integer.All the tilt values won’t exceed the range of 32-bit integer. 解题思路 使用后续遍历，计算每个节点左右节点之和，将两者差值的绝对值进行累加 Go代码实现Go递归实现123456789101112131415161718192021222324252627func findTilt(root *TreeNode) int &#123; if root == nil&#123; return 0 &#125; ret := 0 dfs(root, &amp;ret) return ret&#125;func dfs(root *TreeNode, ret *int) int &#123; if root == nil &#123; return 0 &#125; s := 0 sLeft :=dfs(root.Left, ret) sRight := dfs(root.Right, ret) s += root.Val+sLeft+sRight if sLeft &gt;sRight &#123; *ret += sLeft-sRight &#125;else&#123; *ret += sRight-sLeft &#125; return s&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L543 Diameter of Binary Tree]]></title>
    <url>%2F2018-01-05-L543-Diameter-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example:Given a binary tree12345 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 解题思路 使用深度遍历，计算各个节点左右节点的高度是否小于一个最大值max 返回这个max Go实现Go递归实现1234567891011121314151617181920212223242526func diameterOfBinaryTree(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; d := 0 height(root, &amp;d) return d&#125;func height(root *TreeNode, d *int) int &#123; if root == nil&#123; return 0 &#125; hLeft := height(root.Left, d) hRight := height(root.Right, d) if *d&lt;hLeft+hRight &#123; *d = hLeft + hRight &#125; if hLeft&gt;hRight &#123; return hLeft+1 &#125;else&#123; return hRight+1 &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L538. Convert BST to Greater Tree]]></title>
    <url>%2F2018-01-05-L538-Convert-BST-to-Greater-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: Input: The root of a Binary Search Tree like this:123 5 / \2 13 Output: The root of a Greater Tree like this:123 18 / \20 13 解题思路 使用类中序遍历（右中左） 先遍历右子树，将根节点加上右子树所有节点的和s，将根节点val修改为s 然后遍历左子树，将左子树每个节点加上s Go实现Go实现——递归12345678910111213141516func convertBST(root *TreeNode) *TreeNode &#123; s := 0 convert(root, &amp;s) return root&#125;func convert(root *TreeNode, s *int)&#123; if root == nil&#123; return &#125; convert(root.Right, s) root.Val += *s *s = root.Val convert(root.Left, s)&#125; Go实现——循环12345678910111213141516171819202122232425262728func convertNoRecursion(root *TreeNode) *TreeNode &#123; if root == nil &#123; return root &#125; stack := []*TreeNode&#123;&#125; stack = append(stack, root) s := 0 for len(stack)&gt;0 &#123; current := stack[len(stack)-1] for current != nil &#123; stack = append(stack, current.Right) current = current.Right &#125; stack = stack[0:len(stack)-1] if len(stack)&gt;0 &#123; current = stack[len(stack)-1] stack = stack[0:len(stack)-1] current.Val += s s=current.Val stack = append(stack,current.Left) &#125; &#125; return root&#125; Runtime: 535 ms 73.91% Go实现——O(n*n)时间复杂度 12345678910111213141516171819202122232425262728293031323334353637383940var all_path []intfunc convertBST(root *TreeNode) *TreeNode &#123; all_path = inOrder(root) DFS(root) return root&#125;func inOrder(root *TreeNode) []int &#123; if root == nil&#123; return []int&#123;&#125; &#125; path := []int&#123;&#125; path = append(path, inOrder(root.Left)...) path = append(path, root.Val) path = append(path, inOrder(root.Right)...) return path&#125;func greaterSum(val int) int &#123; s:=0 for _,v := range all_path&#123; if v&gt;val &#123; s+=v &#125; &#125; return s&#125;func DFS(root *TreeNode) &#123; if root == nil&#123; return &#125; root.Val += greaterSum(root.Val) DFS(root.Left) DFS(root.Right)&#125; Runtime: 782 ms 13.04%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L297. Serialize and Deserialize Binary Tree]]></title>
    <url>%2F2018-01-04-L297-Serialize-and-Deserialize-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. For example, you may serialize the following tree 12345 1 / \2 3 / \ 4 5 as “[1,2,3,null,null,4,5]”, just the same as how LeetCode OJ serializes a binary tree.You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. 解题思路 本题目完全使用Discuss https://discuss.leetcode.com/topic/28041/recursive-preorder-python-and-c-o-n Python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# Definition for a binary tree node.import unittestclass TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ def doit(node): if node: vals.append(str(node.val)) doit(node.left) doit(node.right) else: vals.append('#') vals = [] doit(root) n = len(vals) - 1 while vals[n] == '#': n -= 1 return ','.join(vals[0:n + 1]) def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ def doit(): try: val = next(vals) if val == '#': return None node = TreeNode(int(val)) node.left = doit() node.right = doit() return node except StopIteration: pass vals = iter(data.split(',')) return doit()class Test(unittest.TestCase): s = Codec() def test_case1(self): data = "1,2,3,#,#,4,5" root = self.s.deserialize(data) ret = self.s.serialize(root) self.assertEquals(ret, data) def test_case2(self): data = "1,2,3,#,#,4" root = self.s.deserialize(data) ret = self.s.serialize(root) self.assertEquals(ret, data) def test_case3(self): data = "5,2,3,#,#,2,4,3,1" ret = self.s.serialize(self.s.deserialize(data)) self.assertEquals(ret, data)]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L222 Count Complete Tree Nodes]]></title>
    <url>%2F2018-01-03-L222-Count-Complete-Tree-Nodes%2F</url>
    <content type="text"><![CDATA[题目描述Given a complete binary tree, count the number of nodes. Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.It can have between 1 and 2**h nodes inclusive at the last level h. 解题思路 使用深度遍历以及广度遍历都是执行超时，这些算法时间复杂度都是O(N) 使用二分法以及判断是否为满二叉树计算，时间复杂度为O(logN) 完全二叉树 满二叉树 Python代码实现——二分法Python代码实现——二分法递归1234567891011121314151617181920212223242526class Solution(object): def countNodes(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 hLeft= 0 hRight = 0 pLeft = root pRight = root while pLeft: hLeft+=1 pLeft = pLeft.left while pRight: hRight+=1 pRight = pRight.right if hLeft == hRight: return pow(2,hLeft)-1 else: return self.countNodes(root.left) + self.countNodes(root.right) + 1]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L129 Sum Root to Leaf Numbers]]></title>
    <url>%2F2018-01-02-L129-Sum-Root-to-Leaf-Numbers%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. For example, 123 1 / \2 3 The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13. Return the sum = 12 + 13 = 25. 解题思路 深度遍历，使用map保存parent信息，通过叶子节点回溯到root 深度遍历递归 深度遍历非递归 Go代码实现map保存parent信息123456789101112131415161718192021222324252627282930313233343536373839404142func sumNumbers(root *TreeNode) int &#123; parent := map[*TreeNode]*TreeNode&#123;&#125; parent[root] = nil ret := 0 sumPath(root, parent, &amp;ret) return ret&#125;func count(p *TreeNode, parent map[*TreeNode]*TreeNode) int &#123; path := []int&#123;&#125; for p != nil &#123; path = append(path, p.Val) p = parent[p] &#125; n := len(path)-1 ret := 0 for i:=n;i&gt;=0;i-- &#123; ret = ret*10 + path[i] &#125; return ret&#125;func sumPath(root *TreeNode, parent map[*TreeNode]*TreeNode, ret *int)&#123; if root == nil&#123; return &#125; if root.Left == nil &amp;&amp; root.Right==nil &#123; *ret += count(root, parent) &#125; if root.Left != nil &#123; parent[root.Left] = root sumPath(root.Left, parent, ret) &#125; if root.Right != nil &#123; parent[root.Right] = root sumPath(root.Right, parent, ret) &#125;&#125; 深度递归，使用path1234567891011121314151617181920212223242526272829func sumNumbers(root *TreeNode) int &#123; path2 := []int&#123;&#125; ret := 0 dfs(root, path2, &amp;ret) return ret&#125;func dfs(root *TreeNode, path []int, ret *int) &#123; if root == nil &#123; return &#125; path = append(path, root.Val) if root.Left == nil &amp;&amp; root.Right == nil &#123; s := 0 for i:=0;i&lt;len(path);i++ &#123; s = s*10 + path[i] &#125; *ret += s &#125; if root.Left != nil &#123; dfs(root.Left, path, ret) &#125; if root.Right != nil&#123; dfs(root.Right, path, ret) &#125;&#125; 深度遍历，非递归12345678910111213141516171819202122232425262728293031func sumNumbers(root *TreeNode) int&#123; if root == nil&#123; return 0 &#125; var stack []*TreeNode stack = append(stack,root) s := 0 for len(stack) &gt;0 &#123; current := stack[len(stack)-1] stack = stack[0:len(stack)-1] if current.Right != nil &#123; current.Right.Val += current.Val*10 stack = append(stack, current.Right) &#125; if current.Left != nil &#123; current.Left.Val += current.Val*10 stack = append(stack, current.Left) &#125; if current.Left == nil &amp;&amp; current.Right == nil &#123; s += current.Val &#125; &#125; return s&#125; 广度遍历，非递归12345678910111213141516171819202122232425262728293031323334353637func sumNumbers(root *TreeNode) int &#123; return bfsNoRecursion(root)&#125;func bfsNoRecursion(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; queue := []*TreeNode&#123;&#125; queue = append(queue, root) s := 0 for len(queue)&gt;0 &#123; current := queue[0] queue = queue[1:] if current.Left != nil &#123; current.Left.Val += current.Val*10 queue = append(queue, current.Left) &#125; if current.Right != nil &#123; current.Right.Val += current.Val*10 queue = append(queue, current.Right) &#125; if current.Left == nil &amp;&amp; current.Right == nil &#123; s += current.Val &#125; &#125; return s&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Populating Next Right Pointers in Each Node I&II]]></title>
    <url>%2F2018-01-02-L116-Populating-Next-Right-Pointers-in-Each-Node%2F</url>
    <content type="text"><![CDATA[L116 Populating Next Right Pointers in Each Node题目描述Given a binary tree12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space.You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).For example,Given the following perfect binary tree, 12345 1 / \ 2 3 / \ / \4 5 6 7 After calling your function, the tree should look like:12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL 解题思路空间复杂度O(n) 深度遍历，将相同level节点保存到list中，然后遍历list设置next指针 广度遍历，将相同level节点保存到队列中，下一层的节点保存到临时队列中，然后遍历list设置next指针 这里两个思路都可以解决L117的问题 使用常量空间复杂度 使用两个指针,依赖于上层已经建立的next关系 通过上层的next指针访问到右兄弟 此方案适合完全二叉树 Python代码实现深度遍历，空间复杂度O(n)12345678910111213141516171819202122232425262728class Solution: # @param root, a tree link node # @return nothing def connect(self, root): m = &#123;&#125; self.levelOrder(root, m, 0) for i in m: n = len(m[i]) k = 0 head = m[i][0] while k&lt;n-1: head.next = m[i][k+1] k += 1 head = head.next head.next = None def levelOrder(self, root, m, level): if not root: return if level in m: m[level].append(root) else: m[level] = [root] self.levelOrder(root.left, m, level+1) self.levelOrder(root.right, m, level+1) 广度遍历，空间复杂度O(n)123456789101112131415161718192021class Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return root queue = [] queue.append(root) while len(queue): n = len(queue) tmp = [] for i in range(n): if i&lt;n-1: queue[i].next = queue[i+1] if queue[i].left: tmp.append(queue[i].left) if queue[i].right: tmp.append(queue[i].right) queue = tmp L117 Populating Next Right Pointers in Each Node II题目描述Follow up for problem “Populating Next Right Pointers in Each Node”. What if the given tree could be any binary tree? Would your previous solution still work? Note: You may only use constant extra space.For example,Given the following binary tree, 12345 1 / \ 2 3 / \ \4 5 7 After calling your function, the tree should look like: 12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \4-&gt; 5 -&gt; 7 -&gt; NULL 解题思路 使用上述的深度遍历和广度遍历都可以AC，但是空间复杂度为O(n) 使用层次遍历 Python实现1234567891011121314151617181920class Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return root while root: dummy = TreeLinkNode(0) t = dummy while root: if root.left: t.next = root.left t = t.next if root.right: t.next = root.right t = t.next root = root.next root = dummy.next]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L230 Kth Smallest Element in a BST]]></title>
    <url>%2F2018-01-01-L230-Kth-Smallest-Element-in-a-BST%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Follow up:What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently?How would you optimize the kthSmallest routine? 解题思路 使用中序遍历，然后将path保存，返回path[k-1]的元素 Go代码实现 中序遍历，然后path[k-1] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package L230/** * Definition for a binary tree node. */type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func initBST(nums []int) *TreeNode &#123; var root *TreeNode for _,v := range nums&#123; root = insertNode(root,v) &#125; return root&#125;func insertNode(root *TreeNode, n int) *TreeNode &#123; if root == nil &#123; root = new(TreeNode) root.Val = n &#125;else&#123; if root.Val&gt;n &#123; root.Left = insertNode(root.Left, n) &#125;else&#123; root.Right = insertNode(root.Right, n) &#125; &#125; return root&#125;func kthSmallest(root *TreeNode, k int) int &#123; var path []int inOrder(root, &amp;path) return path[k-1]&#125;func inOrder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; inOrder(root.Left, path) *path = append(*path, root.Val) inOrder(root.Right, path)&#125; Runtime: 22 ms 83.3% 123456789101112131415161718func kthSmallest(root *TreeNode, k int) int &#123; ret := 0 n := 0 inOrder(root, &amp;ret,&amp;n,k) return ret&#125;func inOrder(root *TreeNode, ret *int, n *int, k int) &#123; if root == nil &#123; return &#125; inOrder(root.Left, ret, n, k) *n += 1 if *n==k &#123; *ret = root.Val &#125; inOrder(root.Right, ret, n,k)&#125; Go代码实现——中序递归加入K个数判断1234567891011121314151617181920func kthSmallest(root *TreeNode, k int) int &#123; var path []int inOrder(root, &amp;path, k) return path[k-1]&#125;func inOrder(root *TreeNode, path *[]int, k int) &#123; if root == nil &#123; return &#125; inOrder(root.Left, path, k) if len(*path) &lt; k &#123; *path = append(*path, root.Val) &#125;else&#123; return &#125; inOrder(root.Right, path, k)&#125; Runtime: 44ms 效果反而更差了。 Go代码实现——中序循环迭代实现11234567891011121314151617181920212223func kthSmallest(root *TreeNode, k int) int &#123; var stack []*TreeNode stack = append(stack, root) path := []int&#123;&#125; for len(stack)&gt;0 &#123; current := stack[len(stack)-1] for current!=nil&#123; current = current.Left stack = append(stack, current) &#125; stack = stack[0:len(stack)-1] if len(stack)&gt;0 &#123; current = stack[len(stack)-1] stack = stack[0:len(stack)-1] path = append(path, current.Val) stack = append(stack, current.Right) &#125; &#125; return path[k-1]&#125; 12345678910111213141516171819202122232425262728func kthSmallest(root *TreeNode, k int) int &#123; var stack []*TreeNode ret := 0 stack = append(stack, root) for len(stack) &gt;0 &#123; current := stack[len(stack)-1] for current!=nil &#123; current = current.Left stack = append(stack, current) &#125; stack = stack[0:len(stack)-1] if len(stack)&gt;0 &#123; current = stack[len(stack)-1] stack = stack[0:len(stack)-1] k-- if k==0 &#123; ret = current.Val break &#125; stack = append(stack, current.Right) &#125; &#125; return ret&#125; Go代码实现——中序循环迭代实现21234567891011121314151617func kthSmallest(root *TreeNode, k int) int &#123; var stack []*TreeNode path := []int&#123;&#125; for root != nil || len(stack)&gt;0 &#123; if root != nil &#123; stack = append(stack, root) root = root.Left &#125;else&#123; root = stack[len(stack)-1] stack = stack[0:len(stack)-1] path = append(path, root.Val) root = root.Right &#125; &#125; return path[k-1]&#125; 1234567891011121314151617181920func kthSmallest(root *TreeNode, k int) int &#123; var stack []*TreeNode ret := 0 for root != nil || len(stack)&gt;0 &#123; if root != nil &#123; stack = append(stack, root) root = root.Left &#125;else&#123; root = stack[len(stack)-1] stack = stack[0:len(stack)-1] k-- if k==0 &#123; ret =root.Val break &#125; root = root.Right &#125; &#125; return ret&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L173 Binary Search Tree Iterator]]></title>
    <url>%2F2017-12-31-L173-Binary-Search-Tree-Iterator%2F</url>
    <content type="text"><![CDATA[题目描述Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.Calling next() will return the next smallest number in the BST.Note: next() and hasNext() should run in average O(1) time and uses O(h) memory,where h is the height of the tree. 解题思路解题思路1——保存中序遍历结果 二叉搜索树有序就是中序遍历，先将中序遍历保存到list中——空间复杂度为O(n) 解题思路2——实现O(h)空间复杂度 初始化的时候先中所有的left节点保存到stack中 next的时候stack栈顶元素，判断当前节点的right对应left节点压入栈。 Python代码实现Python实现——空间复杂度为O(n)12345678910111213141516171819202122232425262728class BSTIterator(object): def __init__(self, root): """ :type root: TreeNode """ self.nodes = [] self.preOrder(root, self.nodes) def preOrder(self, root, nodes): if not root: return self.preOrder(root.left, nodes) nodes.append(root.val) self.preOrder(root.right, nodes) def hasNext(self): """ :rtype: bool """ return len(self.nodes) &gt; 0 def next(self): """ :rtype: int """ if len(self.nodes): return self.nodes.pop(0) Python实现——空间复杂度为O(h)123456789101112131415161718192021222324252627class BSTIterator(object): def __init__(self, root): """ :type root: TreeNode """ self.stack = [] while root: self.stack.append(root) root = root.left def hasNext(self): """ :rtype: bool """ return len(self.stack) != 0 def next(self): """ :rtype: int """ current = self.stack[-1] left = current.right self.stack.pop(-1) while left: self.stack.append(left) left = left.left return current.val]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L199 Binary Tree Right Side View]]></title>
    <url>%2F2017-12-31-L199-Binary-Tree-Right-Side-View%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, imagine yourself standing on the right side of it,return the values of the nodes you can see ordered from top to bottom. For example:Given the following binary tree, 12345 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- You should return [1, 3, 4]. 解题思路深度遍历 深度遍历，将各个节点保存到属于同一个level的map中 按照level由小到大的顺序，返回各个level中最后一个节点 广度遍历 广度的遍历思想是使用队列 在广度遍历嵌套一个当前level的节点遍历，判断是当前level最后的一个节点则加入path中 Go代码实现Go代码实现——深度遍历记录各个level对应的节点并保存到map中1234567891011121314151617181920212223242526272829303132func rightSideView(root *TreeNode) []int &#123; m := map[int][]int&#123;&#125; h := travel(root, 0, m) path := []int&#123;&#125; for i:=0;i&lt;h; i++ &#123; arr := m[i] k := len(arr)-1 path = append(path,arr[k]) &#125; return path&#125;func travel(root *TreeNode, level int, m map[int][]int) int&#123; if root == nil &#123; return level &#125; if _, ok := m[level]; !ok &#123; m[level] = []int&#123;root.Val&#125; &#125; else &#123; m[level] = append(m[level], root.Val) &#125; l := travel(root.Left, level+1, m) r := travel(root.Right, level+1, m) if l&lt;r &#123; return r &#125;else&#123; return l &#125;&#125; Go代码实现——广度遍历123456789101112131415161718192021222324252627282930func rightSideView(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; var queue []*TreeNode queue = append(queue, root) path := []int&#123;&#125; for len(queue) &gt; 0 &#123; n := len(queue) for i := 0; i &lt; n; i++ &#123; current := queue[0] queue = queue[1:] if i == n-1 &#123; path = append(path, current.Val) &#125; if current.Left != nil &#123; queue = append(queue, current.Left) &#125; if current.Right != nil &#123; queue = append(queue, current.Right) &#125; &#125; &#125; return path&#125; Go代码实现——深度遍历高效的方法1234567891011121314151617181920212223func rightSideView(root *TreeNode) []int &#123; path := []int&#123;&#125; rightView(root, 0, &amp;path) return path&#125;func rightView(root *TreeNode, currentDepth int, path *[]int) &#123; if root == nil &#123; return &#125; if currentDepth == len(*path) &#123; *path = append(*path, root.Val) &#125; if root.Right != nil &#123; rightView(root.Right, currentDepth+1, path) &#125; if root.Left != nil &#123; rightView(root.Left, currentDepth+1, path) &#125;&#125; 深度遍历，右节点先遍历，判断当前currentDepth是否等于len(path)。注意前提条件是右节点先遍历。 参考资料本题目 https://www.geeksforgeeks.org/print-right-view-binary-tree-2/ https://leetcode.com/problems/binary-tree-right-side-view/discuss/56012/?page=1 Level遍历 https://www.geeksforgeeks.org/level-order-tree-traversal/ 广度遍历——使用队列12345678910111213141516171819202122232425func rightSideView(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; var queue []*TreeNode queue = append(queue, root) path := []int&#123;&#125; for len(queue) &gt; 0 &#123; current := queue[0] queue = queue[1:] path = append(path, current.Val) if current.Left != nil &#123; queue = append(queue, current.Left) &#125; if current.Right != nil &#123; queue = append(queue, current.Right) &#125; &#125; return path&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L236 Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2F2017-12-31-L236-Lowest-Common-Ancestor-of-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.According to the definition of LCA on Wikipedia:“The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” 1234567 _______3______ / \ ___5__ ___1__/ \ / \6 _2 0 8 / \ 7 4 For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3.Another example is LCA of nodes 5 and 4 is 5,since a node can be a descendant of itself according to the LCA definition. 解题思路 利用深度遍历，将各个节点的parent节点以及level保存在map 将p和q调整到同一个level，然后回溯其parent节点 Python代码实现Python基础代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ parent = &#123;&#125; level_map = &#123;&#125; self.dfs(root, parent, 0, level_map) if level_map[p] &gt; level_map[q]: p,q = q,p while level_map[q] &gt; level_map[p]: q = parent[q] while p != q: p = parent[p] q = parent[q] return p def initTree(self, root, nums, i, n): if i &lt; n: if nums[i] == -1: root = None return root else: root = TreeNode(nums[i]) root.left = self.initTree(root.left, nums, 2 * i + 1, n) root.right = self.initTree(root.right, nums, 2 * i + 2, n) return root return root def dfs(self, root, parent, level, level_map): if not root: return level_map[root] = level if root.left: parent[root.left] = root self.dfs(root.left, parent, level + 1, level_map) if root.right: parent[root.right] = root self.dfs(root.right, parent, level + 1, level_map) def preorder(self, root, path, nodes): if not root: return path.append(root.val) nodes.append(root) self.preorder(root.left, path,nodes) self.preorder(root.right, path,nodes) def printTree(self, root): path = [] self.preorder(root, path, []) return ' '.join([str(n) for n in path]) Runtime: 116 ms 44.69% Python测试用例12345678910111213141516171819class TestCase(unittest.TestCase): s = Solution() def test_1(self): nums = [3, 5, 1, 6, 2, 0, 8, -1, -1, 7, 4] root = self.s.initTree(None, nums, 0, len(nums)) ret = self.s.printTree(root) self.assertEqual(ret, "3 5 6 2 7 4 1 0 8") def test_2(self): nums = [3, 5, 1, 6, 2, 0, 8, -1, -1, 7, 4] root = self.s.initTree(None, nums, 0, len(nums)) nodes = [] self.s.preorder(root,[],nodes) lca_node = self.s.lowestCommonAncestor(root,nodes[1], nodes[-1]) self.assertEqual(lca_node, root)if __name__ == '__main__': unittest.main() 类似的题目 L235 其解题思路：利用二叉搜索树的顺序性 代码实现]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L404 Sum of Left Leaves]]></title>
    <url>%2F2017-12-29-L404-Sum-of-Left-Leaves%2F</url>
    <content type="text"><![CDATA[题目描述Find the sum of all left leaves in a given binary tree. Example: 12345 3 / \9 20 / \ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively.Return 24. 解题思路 使用深度遍历 记录前一个节点prev，判断prev.Left是否等于当前叶子节点，如果等于说明才是其左叶子节点。 递归和循环都实现一下 Go代码实现Go代码实现——递归1234567891011121314151617181920212223func sumOfLeftLeaves(root *TreeNode) int &#123; sum := 0 sumOfLeft(root, root, &amp;sum) return sum&#125;func sumOfLeft(root *TreeNode, prev *TreeNode, sum *int) &#123; if root == nil &#123; return &#125; if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; prev.Left == root &#123; *sum += root.Val &#125; if root.Left != nil &#123; sumOfLeft(root.Left, root, sum) &#125; if root.Right != nil &#123; sumOfLeft(root.Right, root, sum) &#125;&#125; Go代码实现——循环123456789101112131415161718192021222324252627282930func sumOfLeftLeaves(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; sum := 0 var stack []*TreeNode stack = append(stack, root) prev := root for len(stack)&gt;0 &#123; current := stack[len(stack)-1] stack = stack[0:len(stack)-1] if current.Left == nil &amp;&amp; current.Right == nil &amp;&amp; prev.Left == current &#123; sum += current.Val &#125; if current.Right != nil &#123; stack = append(stack, current.Right) prev = current &#125; if current.Left != nil &#123; stack = append(stack, current.Left) prev = current &#125; &#125; return sum&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L145 Binary Tree Postorder Traversal]]></title>
    <url>%2F2017-12-29-L145-Binary-Tree-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, return the postorder traversal of its nodes’ values. For example:Given binary tree {1,#,2,3},123451 \ 2 /3 return [3,2,1]. Note: Recursive solution is trivial, could you do it iteratively? 解题思路 后续递归，使用指针数组 后续递归，不使用指针数组 使用循环迭代 Go代码实现Go代码实现——后续递归，使用指针数组1234567891011121314151617181920func postorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; postOrder(root, &amp;path) return path&#125;func postOrder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; if root.Left != nil &#123; postOrder(root.Left, path) &#125; if root.Right != nil &#123; postOrder(root.Right, path) &#125; *path = append(*path, root.Val)&#125; Go代码实现——后续递归，不使用指针数组1234567891011func postorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; if root == nil &#123; return path &#125; path = append(path, postorderTraversal(root.Left)...) path = append(path, postorderTraversal(root.Right)...) path = append(path, root.Val) return path&#125; Go代码实现——使用stack循环迭代1234567891011121314151617181920212223242526272829303132func postorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; if root == nil &#123; return path &#125; var stack []*TreeNode stack = append(stack, root) head := root for len(stack)&gt;0 &#123; t := stack[len(stack)-1] if (t.Left == nil &amp;&amp; t.Right == nil) || t.Left == head || t.Right == head &#123; path = append(path, t.Val) stack = stack[0:len(stack)-1] head = t &#125;else&#123; if t.Right != nil &#123; stack = append(stack, t.Right) &#125; if t.Left != nil &#123; stack = append(stack, t.Left) &#125; &#125; &#125; return path&#125; Go代码实现——使用stack循环迭代，每个节点入栈2次12345678910111213141516171819202122232425262728293031func postorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; if root == nil &#123; return path &#125; var stack []*TreeNode stack = append(stack, root) stack = append(stack, root) for len(stack)&gt;0 &#123; current := stack[len(stack)-1] stack = stack[0:len(stack)-1] if len(stack)&gt;0 &amp;&amp; current == stack[len(stack)-1] &#123; if current.Right!=nil &#123; stack = append(stack, current.Right) stack = append(stack, current.Right) &#125; if current.Left != nil &#123; stack = append(stack, current.Left) stack = append(stack, current.Left) &#125; &#125;else &#123; path = append(path, current.Val) &#125; &#125; return path&#125; 保持栈的元素顺序为root.Left,root.Right,root(栈底)。对每个节点入栈2次，判断current是否为栈顶元素，如果是说明之前已经入栈过一次，无需再入栈了。 参考资料 http://www.cnblogs.com/grandyang/p/4251757.html http://www.cnblogs.com/rain-lei/p/3705680.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L144 Binary Tree Preorder Traversal]]></title>
    <url>%2F2017-12-29-L144-Binary-Tree-Preorder-Traversal%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, return the preorder traversal of its nodes’ values. For example:Given binary tree [1,null,2,3], 123451 \ 2 /3 return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 解题思路 前序遍历递归，使用指针数组 前序遍历递归，不使用指针数组 使用stack循环实现, 右节点先入栈，左节点后入栈 Go代码实现Go代码实现1——前序递归遍历，使用指针数组123456789101112131415func preorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; preorder(root, &amp;path) return path&#125;func preorder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; *path = append(*path, root.Val) preorder(root.Left, path) preorder(root.Right, path)&#125; Go代码实现2–前序递归遍历，不使用指针数组123456789101112func preorderTraversal(root *TreeNode) []int &#123; if root == nil &#123; return []int&#123;&#125; &#125; path := []int&#123;&#125; path = append(path, root.Val) path = append(path, preorderTraversal(root.Left)...) path = append(path, preorderTraversal(root.Right)...) return path&#125; Go代码实现3——使用stack循环实现123456789101112131415161718192021222324func preorderTraversal(root *TreeNode) []int &#123; path := []int&#123;&#125; if root == nil &#123; return path &#125; var stack []*TreeNode stack = append(stack, root) for len(stack)&gt;0 &#123; root := stack[len(stack)-1] stack = stack[0:len(stack)-1] path = append(path, root.Val) if root.Right != nil &#123; stack = append(stack, root.Right) &#125; if root.Left != nil &#123; stack = append(stack, root.Left) &#125; &#125; return path&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L572 Subtree of Another Tree]]></title>
    <url>%2F2017-12-29-L572-Subtree-of-Another-Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given two non-empty binary trees s and t,check whether tree t has exactly the same structure and node values with a subtree of s.A subtree of s is a tree consists of a node in s and all of this node’s descendants.The tree s could also be considered as a subtree of itself. Example 1:Given tree s:12345 3 / \ 4 5 / \1 2 Given tree t:123 4 / \1 2 Return true, because t has the same structure and node values with a subtree of s.Example 2:Given tree s:1234567 3 / \ 4 5 / \1 2 / 0 Given tree t:123 4 / \1 2 Return false. 解题思路 先找到s和t的相同的节点，然后再比较s和t是否相同 如果当前子树不相同，再比较其他子树 Go实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package L572/** * Definition for a binary tree node. */ type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode &#125;func initTree(root *TreeNode, nums []int, index int, n int) *TreeNode &#123; if index&lt;n &#123; if nums[index] == -1 &#123; root = nil return root &#125;else&#123; root := new(TreeNode) root.Val = nums[index] root.Left = initTree(root.Left, nums, 2*index+1, n) root.Right = initTree(root.Right, nums, 2*index+2, n) return root &#125; &#125; return root&#125;func inorder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; inorder(root.Left, path) *path = append(*path, root.Val) inorder(root.Right, path)&#125;func isSubtree(s *TreeNode, t *TreeNode) bool &#123; if t == nil &#123; return true &#125; if s == nil &#123; return false &#125; result := false if s.Val == t.Val &#123; result = isSame(s, t) &#125; if !result&#123; result = isSubtree(s.Left, t) &#125; if !result &#123; result = isSubtree(s.Right, t) &#125; return result&#125;func isSame(s *TreeNode, t *TreeNode) bool &#123; if s!= nil &amp;&amp; t != nil &amp;&amp; s.Val == t.Val &#123; return isSame(s.Left, t.Left) &amp;&amp; isSame(s.Right, t.Right) &#125;else if s == nil &amp;&amp; t == nil&#123; return true &#125;else&#123; return false &#125;&#125; 这里判断两个TreeNode节点是否，是比较其Val是否相同。如果Val相同才有比较子树是否相同的可能。即使树中出现多个Val相同的情况，除非子树相同，否则就不会返回是子树。Runtime: 39 ms 80.00%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Combination Sum]]></title>
    <url>%2F2017-12-28-Combination-Sum%2F</url>
    <content type="text"><![CDATA[题目描述L39题目描述Given a set of candidate numbers (C) (without duplicates) and a target number (T),find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is:1234[ [7], [2, 2, 3]] L40题目描述Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is: 123456[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 解题思路 使用DFS遍历 引入三个变量，ret记录所有路径，path记录当前路径，index记录索引，t为target-nums[i] Go代码实现L39 Go实现12345678910111213141516171819202122232425262728293031323334package L39import "sort"func combinationSum(candidates []int, target int) [][]int &#123; ret :=[][]int&#123;&#125; sort.Ints(candidates) path := []int&#123;&#125; combination(&amp;ret,path, candidates, target, 0) return ret&#125;func combination(ret *[][]int, path []int, nums []int, target int, index int) &#123; for i:=index; i&lt;len(nums); i++ &#123; t := target - nums[i] if t&lt;0 &#123; return &#125;else&#123; path = append(path, nums[i]) if t == 0 &#123; tmp := make([]int, len(path)) copy(tmp, path) *ret = append(*ret, tmp) &#125;else&#123; combination(ret, path, nums, t, i) &#125; path = path[0:len(path)-1] &#125; &#125;&#125; L39是当前的元素可以被重复考虑Runtime: 6 ms 91.53% L40代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package L40import "sort"func combinationSum2(candidates []int, target int) [][]int &#123; ret :=[][]int&#123;&#125; sort.Ints(candidates) path := []int&#123;&#125; combination(&amp;ret,path, candidates, target, 0) return ret&#125;func isInArray(ret [][]int, arr []int) bool &#123; for _,v := range ret &#123; flag := true for j,n := range arr&#123; if v[j] != n &#123; flag = false break &#125; &#125; if flag &#123; return true &#125; &#125; return false&#125;func combination(ret *[][]int, path []int, nums []int, target int, index int) &#123; for i:=index; i&lt;len(nums); i++ &#123; t := target - nums[i] if t&lt;0 &#123; return &#125;else&#123; path = append(path, nums[i]) if t==0 &#123; tmp := make([]int, len(path)) copy(tmp, path) if isInArray(*ret, tmp) != true&#123; *ret = append(*ret, tmp) &#125; &#125;else &#123; combination(ret, path, nums, t, i+1); &#125; path = path[0:len(path)-1] &#125; &#125;&#125; 每个元素只能被计算一次，故在递归的时候，index设置为i+1。需要判断path是否在ret中出现。Runtime: 9 ms 38.4%。更进一步优化：如何去除数组是否存在的判断？ 12345678910111213141516171819202122232425262728293031323334package L40import "sort"func combinationSum2(candidates []int, target int) [][]int &#123; ret := [][]int&#123;&#125; sort.Ints(candidates) path := []int&#123;&#125; combination(&amp;ret, path, candidates, target, 0) return ret&#125;func combination(ret *[][]int, path []int, nums []int, target int, index int) &#123; for i:=index; i&lt;len(nums); i++ &#123; t := target - nums[i] if t&lt;0 &#123; return &#125;else if i == index || nums[i] != nums[i-1] &#123; #nums[i] != nums[i-1]相同的情况，跳过，避免重复计算 path = append(path, nums[i]) if t==0 &#123; tmp := make([]int, len(path)) copy(tmp, path) *ret = append(*ret, tmp) &#125;else &#123; combination(ret, path, nums, t, i+1) &#125; path = path[0:len(path)-1] &#125; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L33 Search in Rotated Sorted Array]]></title>
    <url>%2F2017-12-28-L33-Search-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[题目描述Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 解题思路 基本思想还是使用二分搜索的思路，但是二分思想是基于有序的数组 通过low++以及high–和target进行比较，将数组变成有序的，然后再进行二分 Go代码实现1234567891011121314151617181920212223242526272829package L33func search(nums []int, target int) int &#123; low := 0 high := len(nums) - 1 for low &lt;= high &#123; for low &lt;= high &amp;&amp; nums[high] &lt; target &#123; high-- &#125; for low &lt;= high &amp;&amp; nums[low] &gt; target &#123; low++ &#125; mid := (low + high) / 2 if nums[mid] == target &#123; return mid &#125; else if nums[mid] &gt; target &#123; high = mid - 1 &#125; else &#123; low = mid + 1 &#125; &#125; return -1&#125; Runtime: 9 ms 10.00%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L34 Search for a Range]]></title>
    <url>%2F2017-12-28-L34-Search-for-a-Range%2F</url>
    <content type="text"><![CDATA[题目描述Given an array of integers sorted in ascending order,find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 解题思路 题目明确使用O(log n)时间复杂度，故采用二分搜索的算法 因为需要找到start以及end，在nums[mid]和target匹配上之后，再进行递归迭代找到所有 Go代码实现Go代码实现——基础功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package L34func searchRange(nums []int, target int) []int &#123; if len(nums) == 0&#123; return []int&#123;-1,-1&#125; &#125; high := len(nums)-1 low := 0 start := high+1 end := -1 ret := []int&#123;&#125; binarySearch(nums, target,low, high, &amp;start, &amp;end) if start == high+1&#123; start = -1 &#125; ret = append(ret, start) ret = append(ret, end) return ret&#125;func binarySearch(nums []int, target int, low int, high int, start *int, end *int) &#123; var mid int for low&lt;=high &#123; mid = (low + high) / 2 if nums[mid] == target &#123; if mid &lt;*start &#123; *start = mid &#125; if mid &gt; *end &#123; *end = mid &#125; if low&lt;=mid-1 &#123; binarySearch(nums,target, low, mid-1, start, end) &#125; if mid+1&lt;=high&#123; binarySearch(nums, target,mid+1, high,start, end) &#125; return &#125; else if nums[mid] &gt; target &#123; high = mid - 1 &#125; else &#123; low = mid + 1 &#125; &#125;&#125; Runtime: 16 ms 61.11% Go代码实现——测试用例1234567891011121314151617181920212223242526272829303132package L34import ( "testing")func TestSearchRangeCase1(t *testing.T) &#123; nums := []int&#123;5, 7, 7, 8, 8, 10&#125; ret := searchRange(nums, 8) if ret[0] != 3 || ret[1] != 4 &#123; t.Error("Test SearchRange Case 1 failed") &#125;&#125;func TestSearchRangeCase2(t *testing.T) &#123; nums := []int&#123;1&#125; ret := searchRange(nums, 0) if ret[0] != -1 || ret[1] != -1 &#123; t.Error("Test SearchRange Case 2 failed") &#125;&#125;func TestSearchRangeCase3(t *testing.T) &#123; nums := []int&#123;&#125; ret := searchRange(nums, 0) if ret[0] != -1 || ret[1] != -1 &#123; t.Error("Test SearchRange Case 3 failed") &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L92 Reverse Linked List II]]></title>
    <url>%2F2017-12-27-L92-Reverse-Linked-List-II%2F</url>
    <content type="text"><![CDATA[题目描述Reverse a linked list from position m to n. Do it in-place and in one-pass. For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4, return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note:Given m, n satisfy the following condition:1 ≤ m ≤ n ≤ length of list. 解题思路 定位到m和n位置对应的节点p1和p2，链表在p2位置断开，这样将链表分为3个部分 将p1进行翻转之后，然后将3个部分链表拼接起来 注意点：p1是否为head Go代码实现Go代码实现——基础功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package L92import ( "strconv")/** * Definition for singly-linked list. */type ListNode struct &#123; Val int Next *ListNode&#125;func reverseBetween(head *ListNode, m int, n int) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; var p1 *ListNode var p2 *ListNode var p *ListNode var p3 *ListNode nList := lenOfList(head) prev := head next := head current := head idx := 1 for idx &lt; m &amp;&amp; idx &lt; nList &#123; prev = current current = current.Next idx++ &#125; p1 = current if p1 != head &#123; next = prev.Next prev.Next = nil current = next &#125; for idx &lt; n &amp;&amp; idx &lt; nList &#123; current = current.Next idx++ &#125; p2 = current p3 = current.Next p2.Next = nil p = reverse(p1) if p1 == head &#123; p1.Next = p3 return p &#125; else &#123; prev.Next = p p1.Next = p3 return head &#125;&#125;func reverse(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; newHead := reverse(head.Next) head.Next.Next = head head.Next = nil return newHead&#125;func lenOfList(head *ListNode) int &#123; n := 1 current := head for current != nil &#123; n++ current = current.Next &#125; return n&#125;func initList(nums []int) *ListNode &#123; head := new(ListNode) current := head for _, n := range nums &#123; node := new(ListNode) node.Val = n current.Next = node current = current.Next &#125; return head.Next&#125;func printList(head *ListNode) string &#123; ret := "" if head == nil &#123; return ret &#125; for head.Next != nil &#123; ret += strconv.Itoa(head.Val) + "-&gt;" head = head.Next &#125; ret += strconv.Itoa(head.Val) return ret&#125; Runtime: 0 ms 50.00% Go代码实现——测试用例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package L92import ( "testing")func TestInitList(t *testing.T) &#123; nums := []int&#123;1, 2, 3, 4&#125; head := initList(nums) ret := printList(head) if ret != "1-&gt;2-&gt;3-&gt;4" &#123; t.Error("Test init List failed") &#125;&#125;func TestReverseBetweenCase1(t *testing.T) &#123; nums := []int&#123;1, 2, 3, 4, 5&#125; head := initList(nums) head = reverseBetween(head, 2, 4) ret := printList(head) if ret != "1-&gt;4-&gt;3-&gt;2-&gt;5" &#123; t.Error("Test reverse between case1 failed") &#125;&#125;func TestReverseBetweenCase2(t *testing.T) &#123; nums := []int&#123;3, 5&#125; head := initList(nums) head = reverseBetween(head, 2, 2) ret := printList(head) if ret != "3-&gt;5" &#123; t.Error("Test reverse between case2 failed") &#125;&#125;func TestReverseBetweenCase3(t *testing.T) &#123; nums := []int&#123;3, 5&#125; head := initList(nums) head = reverseBetween(head, 1, 1) ret := printList(head) if ret != "3-&gt;5" &#123; t.Error("Test reverse between case3 failed") &#125;&#125;func TestReverseBetweenCase4(t *testing.T) &#123; nums := []int&#123;1, 2, 3&#125; head := initList(nums) head = reverseBetween(head, 1, 2) ret := printList(head) if ret != "2-&gt;1-&gt;3" &#123; t.Error("Test reverse between case4 failed") &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L143 Reorder List]]></title>
    <url>%2F2017-12-27-L143-Reorder-List%2F</url>
    <content type="text"><![CDATA[题目描述Given a singly linked list L:$L0&rarr;L1&rarr;&hellip;&rarr;Ln-1&rarr;Ln,$ reorder it to:$L0&rarr;Ln&rarr;L1&rarr;Ln-1&rarr;L2&rarr;Ln-2&rarr;&hellip;$ You must do this in-place without altering the nodes’ values. For example,Given {1,2,3,4}, reorder it to {1,4,2,3}. 解题思路 使用两个指针slow和fast，slow移动一次，fast移动两次，直到fast为最后一个元素 在slow的地方将链表断开，将slow之后的list翻转 将head和slow进行一一merge合并 Go实现12345678910111213141516171819202122232425262728293031323334353637383940func reorderList(head *ListNode) &#123; if head == nil || head.Next == nil&#123; return &#125; slow := head fast := head var prev *ListNode for fast != nil &amp;&amp; fast.Next != nil &#123; fast = fast.Next.Next prev = slow slow = slow.Next &#125; prev.Next = nil current1 := head current2 := reverseList(slow) for current1.Next != nil &amp;&amp; current2.Next != nil&#123; next1 := current1.Next current1.Next = current2 next2 := current2.Next current2.Next = next1 current1 = next1 current2 = next2 &#125; current1.Next = current2&#125;func reverseList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead&#125; Runtime: 25 ms 50.00%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L328 Odd Even Linked List]]></title>
    <url>%2F2017-12-27-L328-Odd-Even-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011121314Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.Note:The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on ...Credits:Special thanks to @DjangoUnchained for adding this problem and creating all test cases. 解题思路 使用两个指针，一个表示odd，一个表示even 然后将event加到odd的最后一个 Go实现Go实现11234567891011121314151617181920212223242526272829func oddEvenList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; var odd_head *ListNode var even_head *ListNode current:= head idx := 1 for current != nil&#123; next := current.Next current.Next = nil if idx % 2 == 0 &#123; even_head = insertNode(even_head, current) &#125;else&#123; odd_head = insertNode(odd_head, current) &#125; current = next idx+=1 &#125; tail := odd_head for tail.Next != nil &#123; tail = tail.Next &#125; tail.Next = even_head return odd_head&#125; Runtime: 39 ms Go实现21234567891011121314151617181920212223242526272829303132333435363738func oddEvenList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; var odd_head *ListNode var odd_tail *ListNode var even_head *ListNode var event_tail *ListNode current := head idx := 1 for current != nil &#123; next := current.Next current.Next = nil if idx%2 == 0 &#123; if even_head == nil&#123; even_head = current event_tail = current &#125;else&#123; event_tail.Next = current event_tail = current &#125; &#125; else &#123; if odd_head == nil&#123; odd_head = current odd_tail = current &#125;else&#123; odd_tail.Next = current odd_tail = current &#125; &#125; current = next idx += 1 &#125; odd_tail.Next = even_head return odd_head&#125; 记录odd以及even的tail节点，直接在tail节点后面插入，而非每次插入节点都找到tail节点Runtime: 9 ms 10% Go程序——测试用例1234567891011121314151617181920212223242526272829303132333435package L328import ( "testing")func TestInitList(t *testing.T) &#123; nums := []int&#123;1, 2, 3, 4&#125; head := initList(nums) ret := printList(head) if ret != "1-&gt;2-&gt;3-&gt;4"&#123; t.Error("Test init List failed") &#125;&#125;func TestOddEvenListCase1(t *testing.T) &#123; nums := []int&#123;1,2,3,4,5&#125; head := initList(nums) head = oddEvenList(head) ret := printList(head) if ret != "1-&gt;3-&gt;5-&gt;2-&gt;4" &#123; t.Error("Test oddEvenList Case1 failed") &#125;&#125;func TestOddEvenListCase2(t *testing.T) &#123; nums := []int&#123;2,1,4,3,6,5,7,8&#125; head := initList(nums) head = oddEvenList(head) ret := printList(head) if ret != "2-&gt;4-&gt;6-&gt;7-&gt;1-&gt;3-&gt;5-&gt;8"&#123; t.Error("test oddEvenList Case2 failed") &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L725 Split Linked List in Parts]]></title>
    <url>%2F2017-12-26-L725-Split-Linked-List-in-Parts%2F</url>
    <content type="text"><![CDATA[题目描述12345678910111213141516171819Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list &quot;parts&quot;.The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.Return a List of ListNode&apos;s representing the linked list parts that are formed.Example 2:Input: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]Explanation:The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.Note:The length of root will be in the range [0, 1000].Each value of a node in the input will be an integer in the range [0, 999].k will be an integer in the range [1, 50]. 解题思路 题目描述很长，首先根据list的长度n以及k算好各个部分的长度，基数为n/k，按照n%k对前面的部分进行加1 遍历list，按照各个部分的长度进行切分 Go代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546func splitListToParts(root *ListNode, k int) []*ListNode &#123; ret := []*ListNode&#123;&#125; n := lenOfList(root) arr := getArr(n, k) current := root for i:=0; i&lt;k; i++ &#123; if current == nil &#123; ret = append(ret, nil) &#125;else&#123; head:= current for j:=0;j&lt;arr[i]-1;j++ &#123; current = current.Next &#125; next := current.Next current.Next = nil current = next ret = append(ret, head) &#125; &#125; return ret&#125;func getArr(n int, k int) []int &#123; delta:=n%k arr := make([]int, k) for i:=0; i&lt;k;i++ &#123; arr[i] = n/k &#125; for i:=0; i&lt;delta;i++ &#123; arr[i] += 1 &#125; return arr&#125;func lenOfList(head *ListNode) int &#123; n := 0 current := head for current != nil &#123; current = current.Next n++ &#125; return n&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L445 Add Two Numbers II]]></title>
    <url>%2F2017-12-26-L445-Add-Two-Numbers-II%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed.Example:Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 解题思路 将各自list转换为int，然后将int转换为list表示，在Go会遇到int越界问题 将各自list转换为array，然后计算两个array相加，并在加的时候生成list 代码实现Python实现1234567891011121314151617181920212223242526272829303132class Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ n1 = self.listToInt(l1) n2 = self.listToInt(l2) return self.intToList(n1+n2) def listToInt(self, head): n = 0 while head: n = n * 10 + head.val head = head.next return n def intToList(self, n): if n == 0: return ListNode(n) #在head前面插入新节点 head = None while n: node = ListNode(n%10) n = n/10 node.next = head head = node return head 需要增加如下的测试，l1=[0] 和l2=[0]的情况Runtime: 142 ms, 39.01.00% Go实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; nums1 := listToArr(l1) nums2 := listToArr(l2) return addTwoArr(nums1, nums2)&#125;func listToArr(head *ListNode) []int &#123; arr := []int&#123;&#125; for head != nil &#123; arr = append(arr, head.Val) head = head.Next &#125; return arr&#125;func addTwoArr(nums1 []int, nums2 []int) *ListNode &#123; n1 := len(nums1)-1 n2 := len(nums2)-1 var head *ListNode ret := 0 n:=0 for n1&gt;=0 || n2&gt;=0 &#123; if n1&gt;=0 &amp;&amp; n2&gt;=0 &#123; n = ret + nums1[n1] + nums2[n2] n1-- n2-- &#125;else if n1&gt;=0 &#123; n = ret + nums1[n1] n1-- &#125;else if n2&gt;=0&#123; n = ret + nums2[n2] n2-- &#125; ret = n/10 n = n % 10 node:= new(ListNode) node.Val = n node.Next = head head = node &#125; if ret &gt;0 &#123; node := new(ListNode) node.Val = ret node.Next = head head = node &#125; return head&#125; Runtime: 35 ms 23.53%]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L148 Sort List]]></title>
    <url>%2F2017-12-26-L148-Sort-List%2F</url>
    <content type="text"><![CDATA[题目描述1Sort a linked list in O(n log n) time using constant space complexity. 解题思路 排序中O(nlogn)时间复杂度有快速排序、归并排序以及对堆排序 适合链表的只有归并排序 代码实现Go代码实现Go代码函数包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package L148import ( "strconv")/** * Definition for singly-linked list. */type ListNode struct &#123; Val int Next *ListNode&#125;func sortList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; slow := head fast := head prev := head for fast != nil &amp;&amp; fast.Next != nil &#123; fast = fast.Next.Next prev = slow slow = slow.Next &#125; prev.Next = nil return merge(sortList(head), sortList(slow))&#125;func merge(head1 *ListNode, head2 *ListNode) *ListNode &#123; if head1 == nil&#123; return head2 &#125; if head2 == nil &#123; return head1 &#125; if head1.Val&lt;head2.Val &#123; head1.Next = merge(head1.Next, head2) return head1 &#125;else&#123; head2.Next = merge(head1, head2.Next) return head2 &#125;&#125;func initList(nums []int) *ListNode &#123; head := new(ListNode) current := head for _, n := range nums &#123; node := new(ListNode) node.Val = n current.Next = node current = current.Next &#125; return head.Next&#125;func printList(head *ListNode) string &#123; ret := "" if head == nil&#123; return ret &#125; for head.Next != nil &#123; ret += strconv.Itoa(head.Val) + "-&gt;" head = head.Next &#125; ret += strconv.Itoa(head.Val) return ret&#125; Go函数测试用例12345678910111213141516171819202122232425262728293031323334353637package L148import ( "testing")func TestInitList(t *testing.T) &#123; nums := []int&#123;1, 2, 3, 4, 5&#125; head := initList(nums) ret := printList(head) if ret != "1-&gt;2-&gt;3-&gt;4-&gt;5" &#123; t.Error("Test Init failed") &#125;&#125;func TestMerge(t *testing.T) &#123; nums1 := []int&#123;1,3,5&#125; nums2 := []int&#123;2,4&#125; head1 := initList(nums1) head2 := initList(nums2) head := merge(head1, head2) ret := printList(head) if ret != "1-&gt;2-&gt;3-&gt;4-&gt;5" &#123; t.Error("Test Merge failed") &#125;&#125;func TestSort(t *testing.T)&#123; nums := []int&#123;5,4,3,2,1&#125; head := initList(nums) head = sortList(head) ret := printList(head) if ret != "1-&gt;2-&gt;3-&gt;4-&gt;5" &#123; t.Error("Test Sort failed") &#125;&#125; Runtime 26 ms Python实现 Python中使用上述相同的代码会遇到RuntimeError: maximum recursion depth exceeded。将merge部分的递归算法修改为使用循环的方式，可以解决这个问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head slow = head fast = head prev = head while fast and fast.next: fast = fast.next.next prev = slow slow = slow.next prev.next = None return self.merge(self.sortList(head), self.sortList(slow)) def merge(self, head1, head2): if not head1: return head2 if not head2: return head1 newHead = ListNode(0) current = newHead while head1 and head2: if head1.val &lt; head2.val: current.next = head1 head1 = head1.next else: current.next = head2 head2 = head2.next current = current.next if head1: current.next = head1 elif head2: current.next = head2 return newHead.next def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([5, 4, 3, 2, 1]) ret = self.s.printList(head) self.assertEqual(ret, "5-&gt;4-&gt;3-&gt;2-&gt;1") def test_2(self): head = self.s.initList([5, 4, 3, 2, 1]) head = self.s.sortList(head) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4-&gt;5") def test_3(self): head = self.s.initList([1, 2, 3, 4, 5]) head = self.s.sortList(head) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4-&gt;5") def test_4(self): head1 = self.s.initList([1, 3, 5]) head2 = self.s.initList([2, 4]) head = self.s.merge(head1, head2) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4-&gt;5")if __name__ == '__main__': unittest.main() Runtime 412 ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L86 Partition List]]></title>
    <url>%2F2017-12-23-L86-Partition-List%2F</url>
    <content type="text"><![CDATA[题目描述12345678Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.You should preserve the original relative order of the nodes in each of the two partitions.For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 解题思路空间复杂度O(n)和时间复杂度O(n) 使用left和right两个指针，构建左右两个子链表，然后把两个子链表连接起来 不使用额外空间 首先计算节点个数以及最后一个节点tail 遍历链表，将节点值大于等于x的节点移动到tail后面 代码实现Python实现1-空间复杂度和时间复杂度都为O(n)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def partition(self, head, x): """ :type head: ListNode :type x: int :rtype: ListNode """ if not head: return head left = None right = None newHead = None newRight = None while head: if head.val&lt;x: if not left: left = ListNode(head.val) newHead = left else: left.next = ListNode(head.val) left = left.next else: if not right: right = ListNode(head.val) newRight = right else: right.next = ListNode(head.val) right = right.next head = head.next if left: left.next = newRight return newHead else: return newRight def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([1, 2, 3, 4]) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4") def test_2(self): head = self.s.initList([1, 4, 3, 2, 5, 2]) head = self.s.partition(head, 3) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5") def test_3(self): head = self.s.initList([1]) head = self.s.partition(head,0) ret = self.s.printList(head) print retif __name__ == '__main__': unittest.main() Runtime 46 ms, 22.16% Python实现-不使用额外空间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def partition(self, head, x): """ :type head: ListNode :type x: int :rtype: ListNode """ if not head or not head.next: return head tail = head n = 1 while tail.next: tail = tail.next n += 1 prev = ListNode(0) prev.next = head current = head tmp = tail idx = 0 while idx&lt;n and current.next: if current.val &gt;=x: if current == head: head = current.next prev.next = head else: prev.next = current.next tmp.next = current current.next = None current = prev.next tmp = tmp.next else: current = current.next prev = prev.next idx+=1 return head def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([1, 2, 3, 4]) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4") def test_2(self): head = self.s.initList([1, 4, 3, 2, 5, 2]) head = self.s.partition(head, 3) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5") def test_3(self): head = self.s.initList([1]) head = self.s.partition(head,0) ret = self.s.printList(head) self.assertEqual(ret, "1") def test_4(self): head = self.s.initList([2,3,4]) head = self.s.partition(head, 1) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;3-&gt;4") def test_5(self): head = self.s.initList([1,2]) head = self.s.partition(head, 2) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2") def test_6(self): head = self.s.initList([2,1]) head = self.s.partition(head, 1) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;1")if __name__ == '__main__': unittest.main()]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L24 Swap Nodes in Pairs]]></title>
    <url>%2F2017-12-23-L24-Swap-Nodes-in-Pairs%2F</url>
    <content type="text"><![CDATA[题目描述1234567Given a linked list, swap every two adjacent nodes and return its head.For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 解题思路 使用三个指针进行处理，prev为前一个节点，p1和p2表示pair，将p1和p2指向进行交换 使用递归的方法,将newHead设置为head，递归head.next.next返回node，将newHead、head以及node的指针调整一下 Python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head p1 = head p2 = head.next newHead = None prev = ListNode(0) while p2: p1.next = p2.next p2.next = p1 prev.next = p2 if not newHead: newHead = prev prev = p1 p1 = p1.next if p1: p2 = p1.next else: break return newHead.next def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([1, 2, 3, 4]) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4") def test_2(self): head = self.s.initList([1, 2, 3, 4]) head = self.s.swapPairs(head) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;1-&gt;4-&gt;3") def test_3(self): head = self.s.initList([1,2]) head = self.s.swapPairs(head) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;1") def test_4(self): head = self.s.initList([1,2,3]) head = self.s.swapPairs(head) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;1-&gt;3")if __name__ == '__main__': unittest.main() Python递归实现123456789101112131415class Solution(object): def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head newHead = head.next node = self.swapPairs(head.next.next) newHead.next = head head.next = node return newHead]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L82 Remove Duplicates from Sorted List II]]></title>
    <url>%2F2017-12-23-L82-Remove-Duplicates-from-Sorted-List-II%2F</url>
    <content type="text"><![CDATA[题目描述123456Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 相似题目 L83 Remove Duplicates from Sorted List 解题思路 在L83中，是删除重复的节点，但是保留一个节点，本题目是不保留，所有都删除 在L83中是slow和fast两个指针就足够 在本题目需要使用3个指针，增加一个prev指针，记录slow前一个节点，slow和fast进行比较 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head slow = head fast = head.next prev = None while fast: flag = False while fast and fast.val == slow.val: slow.next = fast.next fast = fast.next flag = True if not flag: prev = slow else: if prev: prev.next = fast else: head = fast if fast: slow = slow.next fast = fast.next return head def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([1, 2, 3, 3, 4, 4, 5]) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5") def test_2(self): head = self.s.initList([1, 2, 3, 3, 4, 4, 5]) head = self.s.deleteDuplicates(head) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;5") def test_3(self): head = self.s.initList([1, 1, 1, 2, 3]) head = self.s.deleteDuplicates(head) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;3") def test_4(self): head = self.s.initList([1,1]) head = self.s.deleteDuplicates(head) ret = self.s.printList(head) self.assertEqual(ret, "")if __name__ == '__main__': unittest.main() Runtime: 49 ms, beats 67.2% of python submissions]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L61 Rotate List]]></title>
    <url>%2F2017-12-22-L61-Rotate-List%2F</url>
    <content type="text"><![CDATA[题目描述12345678Given a list, rotate the list to the right by k places, where k is non-negative.Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 解题思路解题思路1 计算链表的长度，重新设置k=k%n，保证k都比n小 使用slow和fast两个指针，初始化为head fast移动k步之后，判断fast是否为空，若为空，直接返回head 否则，将fast和slow都移动至fast为链表的最后一个节点 将fast.next指向head，然后slow.next为新的head，将slow.next断开 解题思路2 将链表收尾相连 从head开始走n-k%n步之后，将链表断开 代码实现Python实现1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not head: return head current = head n = 0 while current: current = current.next n += 1 k = k % n fast = head slow = head idx = 0 while fast and idx &lt; k: fast = fast.next idx += 1 if not fast: return head while fast.next: fast = fast.next slow = slow.next fast.next = head fast = slow.next slow.next = None return fast def initList(self, nums): head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): ret = "" if not head: return ret while head.next: ret += "%d-&gt;" % head.val head = head.next ret += "%d" % head.val return retclass Test(unittest.TestCase): s = Solution() def test_1(self): head = self.s.initList([1, 2, 3, 4, 5]) ret = self.s.printList(head) self.assertEqual(ret, "1-&gt;2-&gt;3-&gt;4-&gt;5") def test_2(self): head = self.s.initList([1, 2, 3, 4, 5]) head = self.s.rotateRight(head, 2) ret = self.s.printList(head) self.assertEqual(ret, "4-&gt;5-&gt;1-&gt;2-&gt;3") def test_3(self): head = self.s.initList([1, 2, 3, 4, 5]) head = self.s.rotateRight(head, 4) ret = self.s.printList(head) print ret def test_4(self): head = self.s.initList([1]) head = self.s.rotateRight(head, 99) ret = self.s.printList(head) self.assertEqual(ret, "1") def test_5(self): head = self.s.initList([1, 2]) head = self.s.rotateRight(head, 1) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;1") def test_6(self): head = self.s.initList([1, 2, 3]) head = self.s.rotateRight(head, 2000000000) ret = self.s.printList(head) self.assertEqual(ret, "2-&gt;3-&gt;1")if __name__ == '__main__': unittest.main() Python实现212345678910111213141516171819202122232425262728class Solution(object): def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not head or not head.next: return head current = head n = 1 while current.next: current = current.next n += 1 current.next = head k = n - k % n current = head idx = 1 while idx &lt; k: current = current.next idx += 1 newHead = current.next current.next = None return newHead]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L23 Merge k Sorted Lists]]></title>
    <url>%2F2017-12-21-L23-Merge-k-Sorted-Lists%2F</url>
    <content type="text"><![CDATA[题目描述12Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 解题思路 选择首个非空list作为head，将其他list的数据有序的插入到list中，时间复杂度O(n*k),空间复杂为O(1) 递归合并两个list，合并list算法使用O(m+n)=O(N)时间复杂度，再加上合并时间复杂度O(logK)，总的复杂度为O(N*logN) LeetCode上Discuss中有使用Python库实现的，更快的方法 https://discuss.leetcode.com/topic/10448/python-133ms-solution Python实现 O(n*k)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype: ListNode """ if not lists: return None head = lists[0] idx = 1 n = len(lists) while idx &lt; n: current = lists[idx] idx += 1 if not head: head = current continue else: while current: next = current.next head = self.insertNode(head, current) current = next return head def insertNode(self, head, node): if not head: return node current = head prev = head while current and node.val &gt; current.val: prev = current current = current.next if prev != current: prev.next = node node.next = current return head else: node.next = prev return node def initList(self, nums): if not nums: return None head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node return head def printList(self, head): str = "" if not head: return str while head.next: str += "%d-&gt;" % head.val head = head.next str += "%d" % head.val return strclass Test(unittest.TestCase): s = Solution() def test_1(self): lists = [self.s.initList([]), self.s.initList([-1, 5, 11]), self.s.initList([]), self.s.initList([6, 10])] head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, "-1-&gt;5-&gt;6-&gt;10-&gt;11") def test_2(self): lists = [self.s.initList([]), self.s.initList([])] head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, "") def test_3(self): lists = [self.s.initList([0]), self.s.initList([1])] head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, "0-&gt;1") def test_4(self): lists = [self.s.initList([1]), self.s.initList([0])] head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, "0-&gt;1")if __name__ == '__main__': unittest.main() 使用Python单元测试Runtime: Runtime: 6182 ms Python实现212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution(object): def mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype: ListNode """ if not lists: return None return self.partion(lists, 0, len(lists)-1) def partion(self, lists, low, high): if low == high: return lists[low] else: if low&lt;high: mid = (low+high)/2 node1 = self.partion(lists, low, mid) node2 = self.partion(lists, mid+1, high) return self.mergeList(node1, node2) else: return None def mergeList(self, p, q): if not p: return q if not q: return p head = None current = head while p and q: if not head: if p.val &lt; q.val: head = p p = p.next else: head = q q = q.next current = head else: if p.val &lt; q.val: current.next = p p = p.next else: current.next = q q = q.next current = current.next while p: current.next = p p = p.next current = current.next while q: current.next = q q = q.next current = current.next return head Runtime: 145 ms ###Python实现3-全部使用递归 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# Definition for singly-linked list.import unittestclass ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def mergeKLists(self, lists): &quot;&quot;&quot; :type lists: List[ListNode] :rtype: ListNode &quot;&quot;&quot; if not lists: return None return self.partion(lists, 0, len(lists)-1) def partion(self, lists, low, high): if low == high: return lists[low] else: if low&lt;high: mid = (low+high)/2 node1 = self.partion(lists, low, mid) node2 = self.partion(lists, mid+1, high) return self.mergeList(node1, node2) else: return None def mergeList(self, p, q): if not p: return q if not q: return p if p.val &lt; q.val: p.next = self.mergeList(p.next, q) return p else: q.next = self.mergeList(p, q.next) return q def insertNode(self, head, node): if not head: return node current = head prev = head while current and node.val &gt; current.val: prev = current current = current.next if prev != current: prev.next = node node.next = current return head else: node.next = prev return node def initList(self, twoDArr): lists = [] for nums in twoDArr: if not nums: lists.append(None) continue head = None current = None for n in nums: if not head: head = ListNode(n) current = head else: node = ListNode(n) current.next = node current = node lists.append(head) return lists def printList(self, head): str = &quot;&quot; if not head: return str while head.next: str += &quot;%d-&gt;&quot; % head.val head = head.next str += &quot;%d&quot; % head.val return strclass Test(unittest.TestCase): s = Solution() def test_1(self): lists = self.s.initList([[], [-1, 5, 11], [], [6, 10]]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, &quot;-1-&gt;5-&gt;6-&gt;10-&gt;11&quot;) def test_2(self): lists = self.s.initList([[], []]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, &quot;&quot;) def test_3(self): lists = self.s.initList([[0], [1]]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, &quot;0-&gt;1&quot;) def test_4(self): lists = self.s.initList([[1], [0]]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, &quot;0-&gt;1&quot;) def test_5(self): lists = self.s.initList([[1, 2, 2], [1, 1, 2]]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) self.assertEqual(ret, &quot;1-&gt;1-&gt;1-&gt;2-&gt;2-&gt;2&quot;) def test_6(self): lists = self.s.initList([[1], [2]]) head = self.s.mergeKLists(lists) ret = self.s.printList(head) print ret if __name__ == &apos;__main__&apos;: unittest.main() 将测试用例修改下，输入为二维数组，但是全部递归的程序，触发RuntimeError: maximum recursion depth exceeded]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L19 Remove Nth Node From End of List]]></title>
    <url>%2F2017-12-20-L19-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[题目描述12345678910Given a linked list, remove the nth node from the end of list and return its head.For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Try to do this in one pass. 解题思路 先获取List的长度，获取需要删除的第n个节点的前一个节点 如果当前节点是head，返回head.next 否则，将prev.next设置为current.next Python实现11234567891011121314151617181920212223242526272829303132class Solution(object): def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ if not head: return None current = head length = 0 while current: length+=1 current = current.next if n&gt;=length: n = n%length else: n = length-n current = head idx = 0 prev = current while idx&lt;n: prev = current current = current.next idx+=1 if current != head: prev.next = current.next return head else: return head.next Runtime: 59 ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L326 Power of Three]]></title>
    <url>%2F2017-12-20-L326-Power-of-Three%2F</url>
    <content type="text"></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L203 Range Sum Query Immutable]]></title>
    <url>%2F2017-12-20-L303-Range-Sum-Query-Immutable%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.Example:Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3Note:You may assume that the array does not change.There are many calls to sumRange function. 解题思路 针对每次输入都计算直接使用sum 无需额外空间 计算sum值，根据index输入输出 需要空间 Python实现1123456789101112131415class NumArray(object): def __init__(self, nums): """ :type nums: List[int] """ self.nums = nums def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ return sum(self.nums[i:j+1]) Runtime: 959 ms Python实现212345678910111213141516171819202122class NumArray(object): def __init__(self, nums): """ :type nums: List[int] """ self.sums =[] s = 0 for n in nums: s+=n self.sums.append(s) print self.sums def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ if i==0: return self.sums[j] else: return self.sums[j]-self.sums[i-1] Runtime: 109 ms Python实现31234567891011121314151617class NumArray(object): def __init__(self, nums): """ :type nums: List[int] """ self.sums = [0]*(len(nums)+1) for i in xrange(1,len(nums)+1): self.sums[i] = self.sums[i-1]+nums[i-1] def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ return self.sums[j+1]-self.sums[i] Runtime: 62ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Word Pattern]]></title>
    <url>%2F2017-12-19-L290-Word-Pattern%2F</url>
    <content type="text"><![CDATA[L290题目描述1234567891011Given a pattern and a string str, find if str follows the same pattern.Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.Examples:pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot; should return true.pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot; should return false.pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot; should return false.pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot; should return false.Notes:You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. 解题思路 使用map进行判断，将pattern每个字符作为key，判断对应的str上字符串val 如果pattern中单个字符不在map中，判断对应的val是否已经存在 如果pattern中字符在map中，判断当前的val和map对应的val是否相同 Python实现12345678910111213141516171819202122232425262728293031class Solution(object): def wordPattern(self, pattern, str): """ :type pattern: str :type str: str :rtype: bool """ m = &#123;&#125; tmp_list = str.split() n = len(pattern) if len(pattern) != len(tmp_list): return False for i in range(n): k = pattern[i] v = tmp_list[i] if k not in m: if v in m.values(): return False else: m[k] = v elif m[k] != v: return False return Trues = Solution()print s.wordPattern("abba", "dog cat cat dog")print s.wordPattern("abba", "dog cat cat fish")print s.wordPattern("aaaa", "dog cat cat dog")print s.wordPattern("abba", "dog dog dog dog") Runtime: 32 ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L283 Move Zeroes]]></title>
    <url>%2F2017-12-19-L283-Move-Zeroes%2F</url>
    <content type="text"><![CDATA[题目描述1234567Given an array nums, write a function to move all 0&apos;s to the end of it while maintaining the relative order of the non-zero elements.For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].Note:You must do this in-place without making a copy of the array.Minimize the total number of operations. 解题思路 逐个判断，如果当前数为0，在其后面的数中一个不为0的数与其交换。时间复杂度O(n*2)，无额外空间 使用两个索引进行i,j 初始化i=0,j=1如果nums[i]和nums[j]两个数都为非0，i++,j++如果nums[i]为0，nums[j]非零，将i和j交换，i++,j++如果nums[i]非零，nums[j]为0，将i++如果nums[i]为0，nums[j]非零，将j++ 使用两个索引 初始化pos=0，i=0当遇到nums[i]不为0的时候，将nums[i]赋值给nums[pos]， pos++,i++如果遇到nums[i]为0的时候，将i++将pos到list尾部所有元素，赋值为0 Python实现O(n*2)1234567891011121314151617181920212223242526class Solution(object): def moveZeroes(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ n = len(nums) i = 0 while i&lt;n: if nums[i] == 0: k = i+1 while k&lt;n: if nums[k]: break k+=1 if k&lt;n and nums[k]: nums[i],nums[k] = nums[k], nums[i] i += 1s = Solution()#nums = [0,0,1]nums = [0,1,0,3,12]s.moveZeroes(nums)print nums Runtime: 423 ms Python实现-O(n)1234567891011121314151617181920212223242526272829class Solution(object): def moveZeroes(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ n = len(nums) i = 0 j = 1 while i&lt;n-1 and j&lt;n: if nums[i] and nums[j]: i+=1 j+=1 elif nums[i] == 0 and nums[j]: nums[i], nums[j] = nums[j], nums[i] i+=1 j+=1 elif nums[i] and nums[j] == 0: i+=1 else: j+=1s = Solution()#nums = [2,1]#nums = [0,1,0,3,12]nums = [4,2,4,0,0,3,0,5,1,0]s.moveZeroes(nums)print nums Runtime: 76 ms Python实现-赋值法O(n)123456789101112131415161718class Solution(object): def moveZeroes(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ n = len(nums) pos = 0 i = 0 while i&lt;n: if nums[i] != 0: nums[pos] = nums[i] pos+=1 i+=1 while pos&lt;n: nums[pos]=0 pos+=1 Runtime: 75 ms LeetCode上最优的方案1234567891011class Solution(object): def moveZeroes(self, nums): if nums == []: return pos = 0 for num in nums: if num != 0: nums[pos] = num pos += 1 for i in range(len(nums) - pos): nums[-i-1]=0 Runtime: 46 ms 使用range迭代的效果更高]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L263 Ugly Number]]></title>
    <url>%2F2017-12-18-L263-Ugly-Number%2F</url>
    <content type="text"><![CDATA[题目描述1234Write a program to check whether a given number is an ugly number.Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.Note that 1 is typically treated as an ugly number. 解题思路 判断n是否能被2，3，5整除，如果不可以直接返回false 如果可以将n替换为n/[2,3,5]后，再进行判断 Go实现1123456789101112131415161718192021222324func isUgly(num int) bool &#123; if num&lt;=0&#123; return false &#125; if num == 1 &#123; return true &#125; for num &gt;1 &#123; flag:= false for _,x := range []int&#123;2,3,5&#125;&#123; if num%x==0 &#123; num = num/x flag=true &#125; &#125; if !flag &#123; return false &#125; &#125; return true&#125; Go实现212345678910111213141516func isUgly(num int) bool &#123; if num&lt;=0&#123; return false &#125; if num == 1 &#123; return true &#125; for _,x := range []int&#123;2,3,5&#125;&#123; for num%x==0 &#123; num = num/x &#125; &#125; return num == 1&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L204 Count Primes]]></title>
    <url>%2F2017-12-18-L204-Count-Primes%2F</url>
    <content type="text"><![CDATA[题目描述1Count the number of prime numbers less than a non-negative number, n. 解题思路 遍历n-1到2判断其是否为prime，如果是进行count++。此算法在n&gt;=499979以上会出现超时。 使用数学算法 https://open.163.com/movie/2012/10/0/6/M99VJKUHC_M9ENDUB06.html Go实现——逐一判断123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "fmt" "math")func isPrime(n int) bool &#123; sqrt := int(math.Sqrt(float64(n))) if n==1 &#123; return false &#125; for sqrt&gt;1 &#123; if n%sqrt==0 &#123; return false &#125; sqrt-- &#125; return true&#125;func countPrimes(n int) int &#123; count := 0 n = n-1 for n&gt;0 &#123; if isPrime(n) &#123; count++ &#125; n-- &#125; return count&#125;func main() &#123; fmt.Println(isPrime(3)) //在MacAir测试执行时间会超过2s fmt.Println(countPrimes(499979))&#125; Go实现——埃拉托斯特尼筛法12345678910111213141516171819202122232425262728293031import ( "math")func countPrimes(n int) int &#123; if n&lt;=1&#123; return 0 &#125; count := 0 m :=make([]int, n+2) for i:=2; i&lt;=int(math.Sqrt(float64(n)));i++ &#123; k:=i j:=2 for k*j&lt;n &#123; if m[k*j] ==0 &#123; m[k*j] = 1 &#125; j++ &#125; &#125; for _,v :=range m[2:n]&#123; if v==0 &#123; count++ &#125; &#125; return count&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L235 Lowest Common Ancestor of a Binary Search Tree]]></title>
    <url>%2F2017-12-18-L235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112131415Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” _______6______ / \ ___2__ ___8__ / \ / \ 0 _4 7 9 / \ 3 5For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. 解题思路DFS+Level(适合通用的二叉树) 使用DFS遍历，将各个节点对应的父节点信息保存到map中 使用递归的前序遍历，将各个节点对应的level信息保存到map （由于没有想到如何从DFS遍历中获取level信息，故从新递归计算） 将p和q移动到同一个level，然后逐步回溯其父节点 利用二叉搜索树的特性 保持p.val&lt;q.val 如果p.val&gt;root.val，说明p和q都分布在root右边，向右遍历 如果q.val&lt;root.val，说明p和q都分布在root左边，向左遍历 如果root在p和q之间，这个root就是p和q的LCA 代码实现Python实现——DFS+Level12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Definition for a binary tree node.class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ #获取各个节点对应的parent stack = [] stack.append(root) parent = &#123;root: None&#125; level = &#123;&#125; n = 0 while len(stack)&gt;0: current = stack[len(stack)-1] stack = stack[0:-1] if current.right: stack.append(current.right) parent[current.right] = current if current.left: stack.append(current.left) parent[current.left] = current self.levelorder(root, level, 0) #保证p的level大于q if level[p] &lt; level[q]: p, q = q,p #将p和q移动同一个level while level[p] != level[q]: p = parent[p] #回溯父节点 while p!=q: p = parent[p] q = parent[q] return p def initTree(self, root, nums, i, n): if i &lt; n: if nums[i] == -1: root = None return root else: root = TreeNode(nums[i]) root.left = self.initTree(root.left, nums, 2*i+1, n) root.right = self.initTree(root.right, nums, 2*i+2, n) return root #获取各个节点对应的level def levelorder(self, root, level, n): if not root: return level[root] = n self.levelorder(root.left, level, n+1) self.levelorder(root.right, level, n+1) def preorder(self, root, path): if not root: return print "%d " % root.val, path.append(root) self.preorder(root.left, path) self.preorder(root.right, path)s = Solution()nums = [5,3,6,2,4,-1,-1,1]root = s.initTree(None, nums, 0, len(nums))path = []s.preorder(root, path)printret = s.lowestCommonAncestor(root, path[3],path[1])print ret.val Python实现——利用二叉查找树有序的特性(递归版)12345678910111213141516171819class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; if p.val &gt; q.val: p, q = q, p if q.val &lt; root.val: return self.lowestCommonAncestor(root.left, p, q) elif p.val &gt; root.val: return self.lowestCommonAncestor(root.right, p, q) else: return root Python实现——利用二叉查找树有序的特性(非递归版)123456789101112131415class Solution(object): def lowestCommonAncestor(self, root, p, q): &quot;&quot;&quot; :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode &quot;&quot;&quot; while root: if root.val &gt; p.val and root.val &gt; q.val: root = root.left elif root.val &lt; p.val and root.val &lt; q.val: root = root.right else: return root]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L268 Missing Number]]></title>
    <url>%2F2017-12-15-L268-Missing-Number%2F</url>
    <content type="text"><![CDATA[题目描述12345678910Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.Example 1Input: [3,0,1]Output: 2Example 2Input: [9,6,4,2,3,5,7,0,1]Output: 8 解题思路 使用额外数组表示每一个位，判断其是否为1 计算总和，然后通过减法获取缺失的数 Go实现——使用额外空间1234567891011121314151617func missingNumber(nums []int) int &#123; arr := make([]int, len(nums)+1) ret := 0 for _,v := range nums &#123; arr[v] = 1 &#125; for i,v := range arr &#123; if v==0 &#123; ret = i break &#125; &#125; return ret&#125; ###Go实现——使用n*(n-1)/2获取和，然后计算缺失的数 123456789101112131415161718192021222324252627func missingNumber(nums []int) int &#123; maxInt:=0 s :=0 for _,v:= range nums&#123; if maxInt &lt; v&#123; maxInt=v &#125; s += v &#125; if maxInt == len(nums)&#123; return maxInt*(maxInt+1)/2-s &#125;else&#123; return len(nums) &#125;&#125;func missingNumber(nums []int) (output int) &#123; l := len(nums) output = (l * (l + 1)) / 2 for _, n := range nums &#123; output -= n &#125; return&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L258 Add Digits]]></title>
    <url>%2F2017-12-14-L258-Add-Digits%2F</url>
    <content type="text"><![CDATA[题目描述12345678Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.For example:Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.Follow up:Could you do it without any loop/recursion in O(1) runtime? 解题思路 使用递归的方式，计算各个位数和s是否小于10，如果小于10返回，否则递归求s的各位数和 数根：使用数学公式https://en.wikipedia.org/wiki/Digital_root#Congruence_formula Go递归1234567891011121314func addDigits(num int) int &#123; s:=0 for num&gt;0 &#123; s += num%10 num /= 10 &#125; if s&lt;10 &#123; return s &#125;else&#123; return addDigits(s) &#125;&#125; Go实现O(1)算法123func addDigits(num int) int &#123; return 1 + (num - 1) % 9&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L257 Binary Tree Paths]]></title>
    <url>%2F2017-12-14-L257-Binary-Tree-Paths%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112Given a binary tree, return all root-to-leaf paths.For example, given the following binary tree: 1 / \2 3 \ 5All root-to-leaf paths are:[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;] 解题思路 递归深度遍历 使用循环深度遍历，通过map记录各个节点的父节点，当子节点为叶子节点，根据当前叶子节点和map回溯到root节点 Go递归遍历123456789101112131415161718192021222324252627282930func DFS(root *TreeNode, path []int, ret *[]string) &#123; if root == nil &#123; return &#125; path = append(path, root.Val) if root.Left == nil &amp;&amp; root.Right == nil &#123; s := "" n := len(path) for i:= 0; i&lt;n; i++&#123; if i&lt;n-1 &#123; s += strconv.Itoa(path[i]) + "-&gt;" &#125;else&#123; s += strconv.Itoa(path[i]) &#125; &#125; *ret = append(*ret, s) &#125; DFS(root.Left, path, ret) DFS(root.Right, path, ret)&#125;func binaryTreePaths(root *TreeNode) []string &#123; ret := []string&#123;&#125; path := []int&#123;&#125; DFS(root, path, &amp;ret) return ret&#125; Go循环实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556func getPath(current*TreeNode, parent map[*TreeNode]*TreeNode)string &#123; path := []int&#123;&#125; p := current for p!=nil &#123; path = append(path, p.Val) p = parent[p] &#125; n := len(path)-1 ret := "" for n&gt;=0 &#123; if n&gt;0 &#123; ret += strconv.Itoa(path[n]) + "-&gt;" &#125;else&#123; ret += strconv.Itoa(path[n]) &#125; n-- &#125; return ret&#125;func binaryTreePaths(root *TreeNode) []string &#123; ret := []string&#123;&#125; if root == nil &#123; return ret &#125; var stack []*TreeNode parent := map[*TreeNode]*TreeNode&#123;&#125; stack = append(stack, root) parent[root] = nil for len(stack)&gt;0 &#123; current := stack[len(stack)-1] stack = stack[0:len(stack)-1] if current.Left==nil &amp;&amp; current.Right==nil &#123; path := getPath(current, parent) ret = append(ret,path) &#125; if current.Right != nil &#123; stack = append(stack, current.Right) parent[current.Right] = current &#125; if current.Left != nil &#123; stack = append(stack, current.Left) parent[current.Left] = current &#125; &#125; return ret&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L242 Valid Anagram]]></title>
    <url>%2F2017-12-14-L242-Valid%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011Given two strings s and t, write a function to determine if t is an anagram of s.For example,s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.s = &quot;rat&quot;, t = &quot;car&quot;, return false.Note:You may assume the string contains only lowercase alphabets.Follow up:What if the inputs contain unicode characters? How would you adapt your solution to such case? 解题思路 由于题目说明都是小写字母，使用两个26维数组代表a-z，初始化都是0 将字符串转换为对应的26维数组，将字母出现次进行累加统计 比较两个数组对应的数是否相同，不同则返回false，反之全部相同返回true Go实现12345678910111213141516171819202122232425func isAnagram(s string, t string) bool &#123; if len(s) != len(t) &#123; return false &#125; if len(s) == 0 &amp;&amp; len(s) == 0 &#123; return true &#125; s1 := make([]int, 26) t1 := make([]int, 26) for i:=0;i&lt;len(s);i++ &#123; s1[s[i]-'a'] += 1 t1[t[i]-'a'] += 1 &#125; for i:=0;i&lt;len(s1);i++ &#123; if s1[i] != t1[i] &#123; return false &#125; &#125; return true&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L234 Palindrome Linked List]]></title>
    <url>%2F2017-12-12-L234-Palindrome-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述1234Given a singly linked list, determine if it is a palindrome.Follow up:Could you do it in O(n) time and O(1) space? 解题思路 借助O(n)空间的话，先Linked List的元素转换为数组，然后通过low和high指针判断回文 将Linked List链表进行拆分，对后半部分的链表进行翻转，然后判断其是否相同 Go实现123456789101112131415161718192021222324252627282930313233343536373839404142434445func reverse(head *ListNode) *ListNode &#123; if head.Next == nil &#123; return head &#125; newHead := reverse(head.Next) head.Next.Next = head head.Next = nil return newHead&#125;func isPalindrome(head *ListNode) bool &#123; if head == nil&#123; return true &#125; tmp:=head n := 0 for tmp != nil &#123; n++ tmp = tmp.Next &#125; newHead := head if n%2==0 &#123; for i:=0;i&lt;=n/2-1 ;i++ &#123; newHead = newHead.Next &#125; &#125;else&#123; for i:=0;i&lt;n/2 ;i++ &#123; newHead = newHead.Next &#125; &#125; newHead = reverse(newHead) for newHead != nil &#123; if head.Val != newHead.Val&#123; return false &#125; head = head.Next newHead = newHead.Next &#125; return true&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L231 Power of Two]]></title>
    <url>%2F2017-12-12-L231-Power-of-Two%2F</url>
    <content type="text"><![CDATA[题目描述1Given an integer, write a function to determine if it is a power of two. 解题思路 n=n/2，算n%2获取的商是否为1，1的话返回true，其他返回false 判断其是否是2的幂，例如8对应的二进制表示为：1000，7对应的二进制表示是0111，8&amp;7==0 所以8是2的幂 Go实现1123456789101112131415func isPowerOfTwo(n int) bool &#123; if n&lt;=0 &#123; return false &#125; for n%2 == 0 &#123; n = n/2 &#125; if n == 1&#123; return true &#125;else&#123; return false &#125;&#125; Go实现212345678910func isPowerOfTwo(n int) bool &#123; if n&lt;=0 &#123; return false &#125; if n==1 &#123; return true &#125; return n&amp;(n-1) == 0&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L225 Implement Stack using Queues]]></title>
    <url>%2F2017-12-11-L225-Implement-Stack-using-Queues%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011Implement the following operations of a stack using queues.push(x) -- Push element x onto stack.pop() -- Removes the element on top of the stack.top() -- Get the top element.empty() -- Return whether the stack is empty.Notes:You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).` 解题思路 使用Go的list结构 使用Python实现 ###Go实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport ( "container/list" "fmt")type MyStack struct &#123; stack *list.List&#125;/** Initialize your data structure here. */func Constructor() MyStack &#123; mystack := MyStack&#123;&#125; mystack.stack = list.New() return mystack&#125;/** Push element x onto stack. */func (this *MyStack) Push(x int) &#123; this.stack.PushBack(x)&#125;/** Removes the element on top of the stack and returns that element. */func (this *MyStack) Pop() int &#123; front := this.stack.Front() this.stack.Remove(front) return front.Value.(int)&#125;/** Get the top element. */func (this *MyStack) Top() int &#123; if !this.Empty() &#123; front := this.stack.Back() return front.Value.(int) &#125;else&#123; panic("Empty") &#125;&#125;/** Returns whether the stack is empty. */func (this *MyStack) Empty() bool &#123; return this.stack.Len() == 0&#125;/** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */func main() &#123; obj := Constructor() obj.Push(1) obj.Push(1) obj.Push(2) fmt.Println(obj.Top())&#125; Python实现1234567891011121314151617181920212223242526272829303132333435363738394041class MyStack(object): def __init__(self): """ Initialize your data structure here. """ self.stack = [] def push(self, x): """ Push element x onto stack. :type x: int :rtype: void """ self.stack.append(x) def pop(self): """ Removes the element on top of the stack and returns that element. :rtype: int """ if not self.empty(): val = self.stack[-1] self.stack = self.stack[0:-1] return val def top(self): """ Get the top element. :rtype: int """ if not self.empty(): val = self.stack[-1] return val def empty(self): """ Returns whether the stack is empty. :rtype: bool """ return len(self.stack) == 0]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L226 Invert Binary Tree]]></title>
    <url>%2F2017-12-11-L226-Invert-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112131415161718Invert a binary tree. 4 / \ 2 7 / \ / \1 3 6 9to 4 / \ 7 2 / \ / \9 6 3 1Trivia:This problem was inspired by this original tweet by Max Howell:Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off. 解题思路 递归方式 非递归方式 Go递归实现12345678910111213func invertTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return root &#125; //将左右节点交换 root.Left, root.Right = root.Right, root.Left //递归访问root.Left root.Left = invertTree(root.Left) //递归访问root.right root.Right = invertTree(root.Right) return root&#125; Go非递归实现12345678910111213141516171819202122func invertTree(root *TreeNode) *TreeNode &#123; if root == nil &#123; return root &#125; var stack []*TreeNode stack = append(stack, root) for len(stack)&gt;0 &#123; current := stack[len(stack)-1] stack = stack[0:len(stack)-1] if current != nil&#123; //关键就是交换左右 current.Left, current.Right = current.Right, current.Left //这里先压入左或者先压入右一样 stack = append(stack, current.Right) stack = append(stack, current.Left) &#125; &#125; return root&#125; 思想很简单，从根节点遍历树，将左右节点交换后，然后将其压入栈]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L205 Isomorphic Strings]]></title>
    <url>%2F2017-12-11-L205-Isomorphic-Strings%2F</url>
    <content type="text"><![CDATA[题目描述12345678910111213141516Given two strings s and t, determine if they are isomorphic.Two strings are isomorphic if the characters in s can be replaced to get t.All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.For example,Given &quot;egg&quot;, &quot;add&quot;, return true.Given &quot;foo&quot;, &quot;bar&quot;, return false.Given &quot;paper&quot;, &quot;title&quot;, return true.Note:You may assume both s and t have the same length. 解题思路 使用map进行映射的判断，相同的字符是否映射相同 使用数组解决 Go实现——使用map12345678910111213141516171819202122232425262728293031323334func containsVal(m map[int]int, val int) bool&#123; for _,v := range m&#123; if val == v&#123; return true &#125; &#125; return false&#125;func isIsomorphic(s string, t string) bool &#123; if len(s) != len(t) &#123; return false &#125; m := map[int]int&#123;&#125; for i:=0;i&lt;len(s);i++ &#123; c1 := int(s[i]) c2 := int(t[i]) if _,ok:=m[c1]; ok&#123; if m[c1] != c2 &#123; return false &#125; &#125;else&#123; if containsVal(m, c2) &#123; return false &#125; m[c1] = c2 &#125; &#125; return true&#125; Go实现12345678910111213141516171819func isIsomorphic(s string, t string) bool &#123; if len(s) != len(t) &#123; return false &#125; m1 := make([]int, 256) m2 := make([]int, 256) for i:=0;i&lt;len(s); i++ &#123; if m1[s[i]] != m2[t[i]] &#123; return false &#125; m1[s[i]] = i+1 m2[t[i]] = i+1 &#125; return true&#125; 参考资料：http://www.cnblogs.com/grandyang/p/4465779.html]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L206 Reverse Linked List]]></title>
    <url>%2F2017-12-11-L206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述123Reverse a singly linked list.Hint:A linked list can be reversed either iteratively or recursively. Could you implement both? 解题思路 使用循环的方式，使用newHead保存新的链表，将newHead的位置插入current节点 使用递归的方式, 使用prev和current指针，初始prev为nil 使用递归方式，先递归到最后一个节点，调整head节点的next-&gt;next为head，将当前head的next设置为NULL，返回上一层 Go——循环方式12345678910111213141516func reverseList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; var newHead *ListNode current := head for current != nil&#123; next := current.Next current.Next = newHead newHead = current current = next &#125; return newHead&#125; Go——递归实现123456789101112131415161718func reverse(current *ListNode, prev *ListNode) *ListNode &#123; if current.Next == nil &#123; current.Next = prev return current &#125; node := current.Next current.Next = prev return reverse(node, current)&#125;func reverseList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; return reverse(head, nil)&#125; Go——递归实现2123456789func reverseList(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L203 Remove Linked List Elements]]></title>
    <url>%2F2017-12-10-L203-Remove-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[题目描述12345Remove all elements from a linked list of integers that have value val.ExampleGiven: 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6Return: 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 解题思路 使用prev指针记录当前节点的前一个节点，current表示当前节点 需要判断当前节点是否为head节点 Go实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package mainimport "fmt"type ListNode struct &#123; Val int Next *ListNode&#125;func insertNode(head *ListNode,val int) *ListNode &#123; if head == nil &#123; head = new(ListNode) head.Val = val &#125;else&#123; tmp := head for tmp.Next!=nil &#123; tmp = tmp.Next &#125; node := new(ListNode) node.Val = val tmp.Next = node &#125; return head&#125;func removeElements(head *ListNode, val int) *ListNode &#123; if head == nil&#123; return nil &#125; current:=head prev := head for current != nil &#123; if current.Val == val &#123; if current == head&#123; prev = current.Next head = prev &#125;else&#123; prev.Next = current.Next &#125; &#125;else&#123; prev = current &#125; current = current.Next &#125; return head&#125;func printList(head *ListNode) &#123; for head != nil &#123; if head.Next!=nil &#123; fmt.Printf("%d -&gt; ", head.Val) &#125;else&#123; fmt.Println(head.Val) &#125; head = head.Next &#125;&#125;func main()&#123; //nums := []int&#123;1,2,6,3,4,5,6&#125;, val=6 //nums := []int&#123;1,2&#125;, val=1 //nums := []int&#123;1&#125;, val=1 //nums := []int&#123;1,1&#125;, val=1 //nums :=[]int&#123;1,2&#125;, val=2 nums := []int&#123;1,2,2,1&#125; var head *ListNode for _,v := range nums &#123; head = insertNode(head, v) &#125; printList(head) head=removeElements(head, 2) printList(head)&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L191 Number of 1 Bits]]></title>
    <url>%2F2017-12-08-L191-Number-of-1-Bits%2F</url>
    <content type="text"><![CDATA[题目描述123456Write a function that takes an unsigned integer and returns the number of ’1&apos; bits it has (also known as the Hamming weight).For example, the 32-bit integer ’11&apos; has binary representation 00000000000000000000000000001011, so the function should return 3. 解题思路 计算二进制，判断当前是否需要计数 使用n&amp;n-1 Python实现123456789101112class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ count = 0 while n&gt;0: if n%2: count +=1 n /= 2 return count Python实现12345678910111213class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ count = 0 while n&gt;0: n = n &amp;(n-1) count+=1 return count]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L190 Reverse Bits]]></title>
    <url>%2F2017-12-08-L190-Reverse-Bits%2F</url>
    <content type="text"><![CDATA[题目描述1234567Reverse bits of a given 32 bits unsigned integer.For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).Follow up:If this function is called many times, how would you optimize it? 解题思路解题思路1——使用list记录然后reverse重新计算10进制数值 先计算出n对应的二进制数保存到list中，对于不满足32位的数设置0 将list翻转后，再重新计算10进制数值 不使用List 先数值计算 然后判断位数是否小于32，进行左移位 使用bin和zfill函数 使用bin获取int对应的二进制 使用zfill补齐零 使用int计算二进制对应的十进制 Python实现——使用List1234567891011121314151617181920class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): ret = [] while n &gt; 0: ret.append(n%2) n = n/2 n = len(ret) while n &lt; 32: ret.append(0) n += 1 reversed(ret) v = 0 for bit in ret: v = v*2 + bit return vs = Solution()print s.reverseBits(43261596) Runtime: 38 ms Python实现——不使用List12345678910111213141516171819202122class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): idx = 0 s = 0 flag = False while n &gt; 0: if n % 2 == 0: idx+=1 else: flag = True idx +=1 if flag: s = s*2 + n%2 n /= 2 if idx&lt;32: s = s&lt;&lt;32-idx return ss = Solution()print s.reverseBits(43261596) Runtime: 55 ms 使用标准函数库123456class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): ret= bin(n)[2:].zfill(32)[::-1] return int(ret, 2) Runtime: 36 ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L189 Rotate Array]]></title>
    <url>%2F2017-12-07-L189-Rotate-Array%2F</url>
    <content type="text"><![CDATA[题目描述12345678910Rotate an array of n elements to the right by k steps.For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].Note:Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.测试案例：[1,2] 0 [1,2][1,2] 1 [2,1] 解题思路O(n)时间复杂度+ O(n)空间复杂度O(n*k)时间复杂度 + O(1)空间复杂度 将最后一个元素保存，然后从N-1开始将前面一个元素往后移动一个位置，然后将最后一个元素放在首位置 重复k次操作 冒泡排序的思想 O(n)时间复杂度 + O(1)空间复杂度 将nums[0:n-k]翻转，将nums[n-k:]翻转 再将nums翻转 问题的关键是n-k翻转，还是k翻转？ O(n)时间复杂度 + O(1)空间复杂度 将每个元素向后移动k个位置 Go实现-O(n)时间复杂度+ O(n) 空间复杂度1234567891011121314151617181920212223func rotate(nums []int, k int) &#123; n := len(nums) arr :=[]int&#123;&#125; for _,v := range nums&#123; arr = append(arr, v) &#125; for i:=0;i&lt;n;i++ &#123; nums[(i+k)%n] = arr[i] &#125;&#125;func rotate(nums []int, k int) &#123; n := len(nums) arr := make([]int, n) copy(arr, nums) for i:=0;i&lt;n ; i++ &#123; nums[(i+k)%n] = arr[i] &#125;&#125; Go实现-O(n*k)12345678910111213func rotate(nums []int, k int) &#123; n := len(nums) for i:=0;i&lt;k ;i++ &#123; t := nums[n-1] j := n-1 for j&gt;=1 &#123; nums[j] = nums[j-1] j-- &#125; nums[j] = t &#125;&#125; Runtime: 462 ms Go实现-翻转123456789101112131415161718192021222324func reverse(nums []int) &#123; n := len(nums) low := 0 high := n-1 for low&lt;high &#123; nums[low], nums[high] = nums[high], nums[low] low++ high-- &#125;&#125;func rotate(nums []int, k int) &#123; n:= len(nums) k = k%n if n==0 || k%n==0 &#123; return &#125; if k&lt;n &#123; reverse(nums[0:n-k]) reverse(nums[n-k:]) reverse(nums) &#125;&#125; Go实现-每个元素向后移动k个位置123456789101112131415161718192021func rotate(nums []int, k int) &#123; n := len(nums) if k == 0 || n == 0 &#123; return &#125; k = k % n idx := 0 distance := 0 cur := nums[0] for i:=0; i&lt;n; i++ &#123; idx = (idx+k) % n nums[idx], cur = cur, nums[idx] distance = (distance+k) % n if distance == 0 &#123; idx = (idx+1) % n cur = nums[idx] &#125; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L172 Factorial Trailing Zeroes]]></title>
    <url>%2F2017-12-07-L172-Factorial-Trailing-Zeroes%2F</url>
    <content type="text"><![CDATA[题目描述123Given an integer n, return the number of trailing zeroes in n!.Note: Your solution should be in logarithmic time complexity. 解题思路 先不考虑时间复杂度，最简单的方法是计算出n的阶乘值，然后再计算出尾部0的个数 使用非O(n)的算法 N N的阶乘值 结果 1 1 0 5 5*2 1 9 5*2 1 10 10,5*2 2 11 10,5*2 2 15 10,152, 54 3 19 10, 152, 54 3 20 20,10,152, 54 4 30 30,20,10,25=55(52,54),156,5*8 7 Go实现-计算阶乘12345678910111213141516171819202122232425package mainimport "fmt"func factorial(n int) int &#123; if n==0 || n==1 &#123; return 1 &#125;else&#123; return n*factorial(n-1) &#125;&#125;func trailingZeroes(n int) int &#123; f := factorial(n) ret := 0 for f%10==0 &#123; f = f/10 ret++ &#125; return ret&#125;func main() &#123; fmt.Println(trailingZeroes(30))&#125; 使用阶乘的方法计算，在30!的时候会出现数越界，导致其结果输出为0 Go实现1234567891011121314151617func trailingZeroes(n int) int &#123; ret := 0 for n&gt;0 &#123; ret += n/5 n = n/5 &#125; return ret&#125;func main() &#123; nums := []int&#123;1, 5, 9, 10, 11, 15, 20,25,30&#125; for _,v := range nums &#123; fmt.Println(trailingZeroes(v)) &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel Sheet]]></title>
    <url>%2F2017-12-07-Excel-Sheet%2F</url>
    <content type="text"><![CDATA[题目描述L168. Excel Sheet Column Title1234567891011Given a positive integer, return its corresponding column title as appear in an Excel sheet.For example: 1 -&gt; A 2 -&gt; B 3 -&gt; C ... 26 -&gt; Z 27 -&gt; AA 28 -&gt; AB L171. Excel Sheet Column Number12345678910111213Related to question [Excel Sheet Column Title](https://leetcode.com/problems/excel-sheet-column-title/description/)Given a column title as appear in an Excel sheet, return its corresponding column number.For example: A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 解题思路 26进制计算 注意从1开始 Go实现123456789101112131415161718192021222324252627282930313233343536373839package mainimport "fmt"func convertToTitle(n int) string &#123; ret:="" for n&gt;0 &#123; ret = string('A'+(n-1)%26) + ret n = (n-1)/26 &#125; return ret&#125;func titleToNumber(s string) int &#123; ret := 0 n := len(s) for i:=0;i&lt;n;i++ &#123; ret = ret*26 + int(s[i] - 'A') + 1 &#125; return ret&#125;func main() &#123; fmt.Println(convertToTitle(26)) fmt.Println(convertToTitle(27)) fmt.Println(convertToTitle(28)) fmt.Println(convertToTitle(52)) fmt.Println(convertToTitle(53)) fmt.Println(titleToNumber("A")) fmt.Println(titleToNumber("AA")) fmt.Println(titleToNumber("AB")) fmt.Println(titleToNumber("AZ")) fmt.Println(titleToNumber("BA"))&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L169 Majority Element]]></title>
    <url>%2F2017-12-06-L169-Majority%2F</url>
    <content type="text"><![CDATA[题目描述12Given an array of size n, find the majority element. The majority element is the element that appears more than [n/2] times.You may assume that the array is non-empty and the majority element always exist in the array. 解题思路 将数组排序，计算连续出现数的个数是否大于n/2，如果是则返回该元素 使用map做计数，需要额外的空间 如何通过不排序进行解决呢？基于一个前提：这个元素的个数超过n/2向下取整 Go实现1-使用排序1234567891011121314151617181920212223242526272829303132333435package mainimport ( "fmt" "sort")func majorityElement(nums []int) int &#123; sort.Ints(nums) n := len(nums) ret := nums[0] for i:=0;i&lt;n;i++ &#123; count :=1 for i+1&lt;n &amp;&amp; nums[i+1] == nums[i] &#123; i++ count++ &#125; if count&gt;n/2 &#123; ret = nums[i] break &#125; &#125; return ret&#125;func main()&#123; //nums := []int&#123;1,1,1,1,2,3,3&#125; nums := []int&#123;1&#125; //nums :=[]int&#123;2,2&#125; fmt.Println(majorityElement(nums))&#125; Go实现2-无排序123456789101112131415161718 majorityElement(nums []int) int &#123; var count = 0 var num int for _, v := range nums &#123; if count==0 &#123; num = v count = 1 &#125;else&#123; if num == v &#123; count++ &#125;else&#123; count-- &#125; &#125; &#125; return num&#125; 这个算法成立的前提是这个元素超过一半以上，例如下面的案例[1 2 1 2 3 2 3 2 2 3]此算法输出的结果为3，而实际上更多的元素是2]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L167 Two Sum II]]></title>
    <url>%2F2017-12-06-L167-Two-Sum-II%2F</url>
    <content type="text"><![CDATA[题目描述12345678Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution and you may not use the same element twice.Input: numbers=&#123;2, 7, 11, 15&#125;, target=9Output: index1=1, index2=2 解题思路 使用两个索引，判断其和和target关系 比target大，low++ 比target小，high– Go实现1234567891011121314151617181920212223242526272829303132package mainimport "fmt"func twoSum(numbers []int, target int) []int &#123; low := 0 high := len(numbers)-1 for low&lt;high &#123; sum := numbers[low] + numbers[high] if sum &lt; target &#123; low++ &#125;else if sum &gt; target &#123; high-- &#125;else&#123; break &#125; &#125; ret :=[]int&#123;&#125; ret = append(ret, low+1) ret = append(ret, high+1) return ret&#125;func main() &#123; nums := []int&#123;2, 7, 11, 15&#125; target := 9 fmt.Println(twoSum(nums, target))&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L160 Intersection of Two Linked Lists]]></title>
    <url>%2F2017-12-06-L160-Intersection-of-Two-Linked-Lists%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112131415161718192021Write a program to find the node at which the intersection of two singly linked lists begins.For example, the following two linked lists:A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3begin to intersect at node c1.Notes:If the two linked lists have no intersection at all, return null.The linked lists must retain their original structure after the function returns.You may assume there are no cycles anywhere in the entire linked structure.Your code should preferably run in O(n) time and use only O(1) memory.Credits:Special thanks to @stellari for adding this problem and creating all test cases. 解题思路计算长度，起点对齐 先遍历两个链表，获取各自的长度LenA和LenB 遍历到最后一个节点，如果两个节点相同，说明存在交叉节点，否则返回None 对于较长的链表先行，移动到两者相同的长度 两个链表同时移动，遇到相同的节点时候就是交叉点，直接返回 交换head，起点对齐 主要补充图说明 两者的时间复杂度相同，只是第二种代码简洁些。 Python实现112345678910111213141516171819202122232425262728293031323334353637class Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None lenA = 0 lenB = 0 tmpA = headA tmpB = headB while tmpA.next: lenA += 1 tmpA = tmpA.next while tmpB.next: lenB += 1 tmpB = tmpB.next if tmpA is tmpB: if lenA&gt;lenB: lenA, lenB = lenB, lenA headA, headB = headB, headA while lenB&gt;lenA: lenB -= 1 headB = headB.next while headA is not headB: headA = headA.next headB = headB.next return headA else: return None Run Time 408ms Python实现212345678910111213141516class Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None p_a = headA p_b = headB while p_a is not p_b: p_a = headB if p_a is None else p_a.next p_b = headA if p_b is None else p_b.next return p_a Run Time 408ms]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min Stack]]></title>
    <url>%2F2017-12-06-Min-Stack%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112131415Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.push(x) -- Push element x onto stack.pop() -- Removes the element on top of the stack.top() -- Get the top element.getMin() -- Retrieve the minimum element in the stack.Example:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 解题思路 使用数组保存所有元素 一个len记录stack中元素数目 Go实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport "fmt"type MinStack struct &#123; stack []int len int&#125;/** initialize your data structure here. */func Constructor() MinStack &#123; s := new(MinStack) return *s&#125;func (this *MinStack) Push(x int) &#123; this.stack = append(this.stack, x) this.len++&#125;func (this *MinStack) Pop() &#123; this.len-- this.stack = this.stack[0:this.len]&#125;func (this *MinStack) Top() int &#123; if this.len&gt;0&#123; return this.stack[this.len-1] &#125;else&#123; panic("stack empty") &#125;&#125;func (this *MinStack) GetMin() int &#123; minVal := 2147483647 n := this.len-1 for n &gt;=0 &#123; if this.stack[n] &lt; minVal&#123; minVal = this.stack[n] &#125; n-- &#125; return minVal&#125;func main() &#123; s := new(MinStack) s.Push(-2) s.Push(0) s.Push(-3) fmt.Println(s.GetMin()) s.Pop() fmt.Println(s.Top()) fmt.Println(s.GetMin())&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linked List Cycle]]></title>
    <url>%2F2017-12-04-Linked-List-Cycle%2F</url>
    <content type="text"><![CDATA[题目描述L1411234Given a linked list, determine if it has a cycle in it.Follow up:Can you solve it without using extra space? L142123456Given a linked list, return the node where the cycle begins. If there is no cycle, return null.Note: Do not modify the linked list.Follow up:Can you solve it without using extra space? 解题思路解题思路步骤 使用两个指针slow和fast slow每次移动一次，fast每次移动二次，直到两者相遇（可以从示例中看到当前相遇的节点不一定是cycle开始的节点） 将slow移动到head，fast和slow每次移动一次，直到两者相遇 示例说明示例1 示例2 如何保证slow和fast一定会相遇呢？ 公式说明 L1为H到E的距离 L2为M到E的距离 C为环的周长 n为快慢指针首次相遇，快指针在环中绕行的次数 慢指针的路径长度为L1+L2 快指针的路径长度为L1+L2+n*C 由于快指针是慢指针进行距离的2倍，因此： $$(L1 + L2)*2 = L1 + L2 + n * C =&gt; L1 + L2 = n * C =&gt; L1 = (n - 1) * C + (C - L2)$$ 参考文档：http://bookshadow.com/weblog/2015/07/10/leetcode-linked-list-cycle-ii/ L141 Python 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return False prev = head next = prev while prev and next: prev = prev.next if next.next: next = next.next.next else: break if prev == next: return True return Falsedef insertNode(head, v): if not head: head = ListNode(v) else: current=head while current.next: current = current.next node = ListNode(v) current.next = node return heads = Solution()nums = [3,2,0,-4]head = Nonefor v in nums: head = insertNode(head, v)#tmp = head## while tmp.next:# tmp = tmp.next# tmp.next = headprint s.hasCycle(head) L142 Python 实现123456789101112131415161718192021222324252627class Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return None slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow is fast: break if not fast or not fast.next: return None slow = head while fast is not slow: fast = fast.next slow = slow.next return slow]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo相关使用]]></title>
    <url>%2F2017-12-01-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo使用数学公式在hexo安装目录下执行 1npm install hexo-math --save 然后编辑站点根目录下的_config.yml，添加 123456math: engine: &apos;mathjax&apos; # or &apos;katex&apos; mathjax: src: custom_mathjax_source config: # MathJax config 之后进入theme的目录，编辑主题的_config.yml，找到mathjax字段。NexT 5.0.1中默认mathjax是禁用，需要改成 12mathjax: enable: true 最后hexo g，就可以部署或者运行server查看效果了。 几个测试例子使用$的一行代码： 123&#123;% math %&#125;Simple inline $a = b + c$.&#123;% endmath %&#125; Simple inline $a = b + c$. 参考资料：http://zjubank.com/2016/08/16/hexo-use-mathjax/]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L136_Single_Number]]></title>
    <url>%2F2017-12-01-L136-Single-Number%2F</url>
    <content type="text"><![CDATA[题目描述1234Given an array of integers, every element appears twice except for one. Find that single one.Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解题思路 先将数组排序，然后前后比较，如果相同则都跳过，如果不同，则返回前者 使用Map 使用位运算 Go实现-排序比较12345678910111213141516171819202122232425262728293031package mainimport ( "fmt" "sort")func singleNumber(nums []int) int &#123; sort.Ints(nums) n := len(nums) ret:=0 for i:=0; i&lt;n;i++ &#123; if i&lt;n-1 &amp;&amp; nums[i] == nums[i+1] &#123; i++ &#125;else if i==n-1 &#123; ret = nums[i] &#125;else&#123; ret = nums[i] break &#125; &#125; return ret&#125;func main() &#123; nums := []int&#123;1,1,2,2,3&#125; fmt.Println(singleNumber(nums))&#125; 时间复杂度O(nlogn)+O(n) Go实现-Map12345678910111213141516171819func singleNumber(nums []int) int &#123; m := map[int]int&#123;&#125; for _,v := range nums&#123; if _,ok := m[v];!ok &#123; m[v] = 1 &#125;else&#123; m[v] += 1 &#125; &#125; for k := range m&#123; if m[k] == 1 &#123; return k &#125; &#125; return 0&#125; 时间复杂度O(n)，空间复杂度O(n) 使用位运算 某个数和0进行异或运算，其返回值为这个数 $a ⊕ $0 = a 相同的两个数异或运算，其返回值为0 $a ⊕ $a = 0 $a ⊕ $b ⊕ $a = ($a ⊕ $a) ⊕ $b = 0 ⊕ $b = $b 12345678func singleNumber(nums []int) int &#123; ret := 0 for _, v := range nums&#123; ret = ret ^ v &#125; return ret&#125; 时间复杂度O(n),空间复杂度O(1)]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L125 Valid Palindrome]]></title>
    <url>%2F2017-12-01-L125-Valid-Palindrome%2F</url>
    <content type="text"><![CDATA[题目描述12345678910Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.For example,&quot;A man, a plan, a canal: Panama&quot; is a palindrome.&quot;race a car&quot; is not a palindrome.Note:Have you consider that the string might be empty? This is a good question to ask during an interview.For the purpose of this problem, we define empty string as valid palindrome. 解题思路 使用low和high两个指针进行判断 如果遇到非alphanumeric字符，进行跳过处理 Go实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( "fmt")func isAlphanumeric(char uint8) bool &#123; if (char &gt;= 'A' &amp;&amp; char &lt;='Z') || (char&gt;='a' &amp;&amp; char&lt;='z')|| (char &gt;='0' &amp;&amp; char&lt;='9') || char=='_'&#123; return true &#125;else&#123; return false &#125;&#125;func lower(char uint8) uint8 &#123; if char &gt;='a' &amp;&amp; char&lt;='z' &#123; char = char-'a'+'A' &#125; return char&#125;func isPalindrome(s string) bool &#123; if len(s) == 0 || len(s) == 1&#123; return true &#125; low:=0 high := len(s)-1 for low&lt;high &#123; if !isAlphanumeric(s[low]) &#123; low++ &#125;else if !isAlphanumeric(s[high]) &#123; high-- &#125;else &#123; if lower(s[low]) == lower(s[high]) &#123; low++ high-- &#125;else&#123; return false &#125; &#125; &#125; return true&#125;func main() &#123; //fmt.Println(isPalindrome("A man, a plan, a canal: Panama")) //fmt.Println(isPalindrome("race a car")) fmt.Println(isPalindrome("0P")) fmt.Println(isPalindrome("a.")) //fmt.Println(len("."))&#125; Python实现 使用基本比较 123456789101112131415161718192021222324class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if not s: return True low = 0 high = len(s) - 1 while low &lt; high: if not str.isalnum(str(s[low])): low += 1 elif not str.isalnum(str(s[high])): high -= 1 else: if str.lower(str(s[low])) == str.lower(str(s[high])): low += 1 high -= 1 else: return False return True 遇到的错误信息: 123Runtime Error Message:Line 14: TypeError: descriptor &apos;isalnum&apos; requires a &apos;str&apos; object but received a &apos;unicode&apos;Last executed input: &quot;a.&quot; 使用库函数 123456789class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ newString = re.sub("[^0-9a-zA-Z]+", "", s) return newString.lower() == newString.lower()[::-1]]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock]]></title>
    <url>%2F2017-11-30-Best-Time-to-Buy-and-Sell-Stock%2F</url>
    <content type="text"><![CDATA[题目描述L121123456789101112131415Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)Example 2:Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 找出数组中的和其前面的数据之差为正整数的最大值 L122解题思路 O(n*2)的算法：2次循环遍历获取差值，与max进行比较 O(n)的算法：记录最小值，将当期元素与最小值进行差值，然后与maxVal进行比较 Go实现O(n*2)时间复杂度1234567891011121314func maxProfit(prices []int) int &#123; maxVal :=0 n := len(prices) for i:=1;i&lt;n;i++ &#123; for j:=0;j&lt;i; j++ &#123; delta := prices[i]- prices[j] if delta&gt;0 &amp;&amp; delta&gt;maxVal &#123; maxVal = delta &#125; &#125; &#125; return maxVal&#125; O(n)时间复杂度12345678910111213141516171819202122func maxProfit(prices []int) int &#123; maxVal :=0 n:=len(prices) if n==0 &#123; return maxVal &#125; minElement := prices[0] for i:=1;i&lt;len(prices);i++&#123; if minElement&gt;prices[i] &#123; minElement = prices[i] &#125; delta:=prices[i]-minElement if delta &gt; 0 &amp;&amp; delta&gt;maxVal&#123; maxVal = delta &#125; &#125; return maxVal&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L98 Validate Binary Search Tree]]></title>
    <url>%2F2017-11-30-L98-Validate-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011121314151617Given a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows:The left subtree of a node contains only nodes with keys less than the node&apos;s key.The right subtree of a node contains only nodes with keys greater than the node&apos;s key.Both the left and right subtrees must also be binary search trees.Example 1: 2 / \ 1 3Binary tree [2,1,3], return true.Example 2: 1 / \ 2 3Binary tree [1,2,3], return false. 判断一个二叉树是否为二叉搜索树 解题思路 使用中序遍历这个二叉树，然后生成一个数组 判断这个数据是否有序 Go递归实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport "fmt"/** * Definition for a binary tree node. */type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func initTree(root *TreeNode, nums []int, i int, n int) *TreeNode &#123; if i&lt;n &#123; if nums[i] == -1 &#123; root = nil &#125;else &#123; root = new(TreeNode) root.Val = nums[i] root.Left = initTree(root.Left, nums, 2*i+1, n) root.Right = initTree(root.Right, nums, 2*i+2, n) &#125; &#125; return root&#125;func inorder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; inorder(root.Left, path) *path = append(*path, root.Val) inorder(root.Right, path)&#125;func isValidBST(root *TreeNode) bool &#123; path := []int&#123;&#125; inorder(root, &amp;path) n := len(path) //for i:=0;i&lt;n-1;i++ &#123; // for j:=i+1;j&lt;n ;j++ &#123; // if path[i]&gt;=path[j] &#123; // return false // &#125; // &#125; //&#125; //判断数组是否有序O(n)算法 for i:=0;i&lt;n-1;i++ &#123; if path[i]&gt;=path[i+1] &#123; return false &#125; &#125; return true&#125;func main() &#123; nums :=[]int&#123;10,5,15,-1,-1,6,20&#125; root := initTree(nil, nums, 0, len(nums)) fmt.Println(isValidBST(root))&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unique Binary Search Trees]]></title>
    <url>%2F2017-11-30-Unique-Binary-Search-Trees%2F</url>
    <content type="text"><![CDATA[题目描述L951234567891011Given n, how many structurally unique BST&apos;s (binary search trees) that store values 1...n?For example,Given n = 3, there are a total of 5 unique BST&apos;s. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 L961234567891011Given an integer n, generate all structurally unique BST&apos;s (binary search trees) that store values 1...n.For example,Given n = 3, your program should return all 5 unique BST&apos;s shown below. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 L95只需要给出这些二叉搜索树对应的总数即可，而L96需要给出这些二叉搜索树 解题思路 通过排列算法给出分组，然后构建BST，通过前序遍历这些树，然后判断树是否唯一 Go解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182type TreeNode struct&#123; Val int Left *TreeNode Right *TreeNode&#125;func Perm(nums []int, k int, n int, path *[]int, ret *[]*TreeNode)&#123; if k==n &#123; s:=0 root := createBST(nil, nums) preorder(root,&amp;s) tag := true for _,v := range *path &#123; if v == s &#123; tag = false break &#125; &#125; if tag &#123; *path = append(*path, s) *ret = append(*ret, root) &#125; &#125;else&#123; for i:=k; i&lt;=n;i++ &#123; nums[i], nums[k] = nums[k], nums[i] Perm(nums, k+1, n, path, ret) nums[i], nums[k] = nums[k], nums[i] &#125; &#125;&#125;func insertNode(root *TreeNode, val int) *TreeNode &#123; if root == nil &#123; root = new(TreeNode) root.Val = val return root &#125; if root.Val&gt;val &#123; root.Left = insertNode(root.Left, val) &#125;else&#123; root.Right = insertNode(root.Right, val) &#125; return root&#125;func createBST(root *TreeNode, nums []int) *TreeNode&#123; if len(nums) == 0 &#123; return root &#125; for _,v := range nums &#123; root = insertNode(root, v) &#125; return root&#125;func preorder(root *TreeNode, s *int) &#123; if root == nil &#123; return &#125; //fmt.Printf("%d ", root.Val) *s = *s*10+root.Val preorder(root.Left, s) preorder(root.Right, s)&#125;func generateTrees(n int) []*TreeNode &#123; nums := []int&#123;&#125; path := []int&#123;&#125; ret := []*TreeNode&#123;&#125; for i:=1; i&lt;=n ; i++ &#123; nums = append(nums, i) &#125; Perm(nums, 0, len(nums)-1, &amp;path, &amp;ret) return ret&#125; 此算法针对L95有超时的问题]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L94 Binary Tree Inorder Traversal]]></title>
    <url>%2F2017-11-28-L94-Binary-Tree-Inorder-Traversal%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112Given a binary tree, return the inorder traversal of its nodes&apos; values.For example:Given binary tree [1,null,2,3], 1 \ 2 / 3return [1,3,2].Note: Recursive solution is trivial, could you do it iteratively? 解题思路 使用递归 使用栈进行循环 Go递归实现1123456789101112131415func inorder(root *TreeNode, path *[]int) &#123; if root == nil &#123; return &#125; inorder(root.Left, path) *path = append(*path, root.Val) inorder(root.Right, path)&#125;func inorderTraversal(root *TreeNode) []int &#123; path :=[]int&#123;&#125; inorder(root, &amp;path) return path&#125; Go递归实现2123456789func inorderTraversal(root *TreeNode) []int &#123; if root == nil&#123; return []int&#123;&#125; &#125; path:=inorderTraversal(root.Left) path = append(path, root.Val) return append(path, inorderTraversal(root.Right)...)&#125; Go非递归实现11234567891011121314151617181920212223func inorderTraversal(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var stack []*TreeNode path :=[]int&#123;&#125; for root!=nil || len(stack)&gt;0 &#123; if root!=nil &#123; stack = append(stack, root) root = root.Left &#125;else&#123; root = stack[len(stack)-1] stack = stack[0:len(stack)-1] path = append(path, root.Val) root = root.Right &#125; &#125; return path&#125; Go非递归实现21234567891011121314151617181920212223242526272829303132func inorderTraversal(root *TreeNode) []int &#123; if root == nil &#123; return nil &#125; var stack []*TreeNode path :=[]int&#123;&#125; stack = append(stack, root) for len(stack)&gt;0 &#123; current := stack[len(stack)-1] //向左走到尽头 for current!=nil &#123; stack = append(stack, current.Left) current = current.Left &#125; //空指针退栈 stack = stack[0:len(stack)-1] if len(stack)&gt;0 &#123; current = stack[len(stack)-1] stack = stack[0:len(stack)-1] //访问节点 path = append(path, current.Val) //将右节点压入栈 stack = append(stack, current.Right) &#125; &#125; return path&#125; 不使用栈非递归方法 http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pascal_Triangle]]></title>
    <url>%2F2017-11-28-L118-Pascal-Triangle%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112Given numRows, generate the first numRows of Pascal&apos;s triangle.For example, given numRows = 5,Return[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 杨辉三角，第5行的4为例，其等于第四行的1+3。 解题思路使用递归在numRows = 1 为[1]在numRows = 2 为[1,1]在numsRows =N, 其相对N-1进行三角加和 Go递归实现1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport "fmt"func pascal(n int) []int &#123; if n==0 &#123; ret :=[]int&#123;1&#125; return ret &#125; if n==1 &#123; ret:=[]int&#123;1,1&#125; return ret &#125; tmp := pascal(n-1) ret :=[]int&#123;&#125; for i:=0; i&lt;n; i++ &#123; k:=i-1 s:=0 if k&lt;0 &#123; s=tmp[i] &#125;else&#123; s = tmp[i] + tmp[k] &#125; ret = append(ret, s) &#125; ret = append(ret, 1) return ret&#125;func generate(numRows int) [][]int &#123; ret := [][]int&#123;&#125; for i:=0; i&lt;numRows; i++ &#123; ret = append(ret, pascal(i)) &#125; return ret&#125;func main() &#123; fmt.Println(generate(5))&#125; 此思路，也可以解决L119 Pascal’s Triangle II Go非递归实现1234567891011121314151617181920212223242526272829303132func generate(numRows int) [][]int &#123; ret := [][]int&#123;&#125; if numRows == 0 &#123; return ret &#125;else if numRows == 1 &#123; tmp:=[]int&#123;1&#125; ret = append(ret,tmp) return ret &#125; ret = append(ret, []int&#123;1&#125;) ret = append(ret,[]int&#123;1,1&#125;) for n:=2; n&lt;numRows; n++ &#123; preTmp := ret[n-1] tmp :=[]int&#123;&#125; for i:=0; i&lt;n; i++ &#123; k:=i-1 s:=0 if k&lt;0 &#123; s=preTmp[i] &#125;else&#123; s = preTmp[i] + preTmp[k] &#125; tmp = append(tmp, s) &#125; tmp = append(tmp, 1) ret = append(ret, tmp) &#125; return ret&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L114_Flatten Binary Tree to Linked List]]></title>
    <url>%2F2017-11-28-L114-Flatten-Binary-Tree-to-Linked-List%2F</url>
    <content type="text"><![CDATA[题目描述12345678910111213141516171819202122Given a binary tree, flatten it to a linked list in-place.For example,Given 1 / \ 2 5 / \ \ 3 4 6The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 解题思路非递归解题思路 通过DFS遍历，首先将root压入stack stack.pop设置为current，将current的right先压入栈，left后压入栈 设置current.left为nil,current的right为栈的最后一个元素 遍历到最后一个元素的时候，如果栈为空，将current的right设置为nil 如果栈为空，完成所有操作 递归解题思路以如下树为例： 12345 2 / \3 4 \ 7 当前root为2的时候，先保存left[3]和right[4] 将root[2]对应的left设置为nil，root[2]对应的right设置为3 遍历right的right直到为right为nil，将right[4]设置为当前节点的right Go非递归实现12345678910111213141516171819202122232425262728293031323334func preOrder(root *TreeNode) &#123; if root == nil &#123; return &#125; var stack []*TreeNode stack = append(stack, root) for len(stack)&gt;0 &#123; current :=stack[len(stack)-1] stack = stack[0:len(stack)-1] if current.Right!=nil &#123; stack = append(stack, current.Right) &#125; if current.Left!=nil &#123; stack = append(stack, current.Left) &#125; current.Left = nil if len(stack) == 0 &#123; current.Right = nil &#125;else&#123; current.Right = stack[len(stack)-1] &#125; &#125;&#125;func flatten(root *TreeNode) &#123; preOrder(root)&#125; Go递归实现123456789101112131415161718func flatten(root *TreeNode)&#123; if root == nil &#123; return &#125; flatten(root.Left) flatten(root.Right) left := root.Left right := root.Right root.Left = nil root.Right = left for root.Right!=nil &#123; root = root.Right &#125; root.Right = right&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L108 Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2F2017-11-27-L108-Convert-Sorted-Array-to-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011Given an array where elements are sorted in ascending order, convert it to a height balanced BST.Input:[0,1,2,3,4,5]Ouput: 3 / \ 1 5 / / 2 4 解题思路通过定位中间数作为根节点，然后二分迭代。 Go 递归实现12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport "fmt"/** * Definition for a binary tree node. */ type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func insertNode(root *TreeNode, nums []int, start int, end int) *TreeNode &#123; if start&gt;end&#123; return nil &#125; p := (start+end)/2 root = new(TreeNode) root.Val = nums[p] root.Left = insertNode(root.Left, nums, start, p-1) root.Right = insertNode(root.Right, nums, p+1, end) return root&#125;func sortedArrayToBST(nums []int) *TreeNode &#123; root := insertNode(nil, nums, 0, len(nums)-1) return root&#125;func main() &#123; var root *TreeNode //nums := []int&#123;1,3,5,7,9&#125; nums :=[]int&#123;0,1,2,3,4,5&#125; root = sortedArrayToBST(nums) fmt.Println(root)&#125; 相似题目 [L109]Convert Sorted List to Binary Search Tree 方案1：遍历链表生成数组 1234567891011func sortedListToBST(head *ListNode) *TreeNode &#123; nums :=[]int&#123;&#125; for head!=nil &#123; nums = append(nums, head.Val) head = head.Next &#125; root := insertNode(nil, nums, 0, len(nums)-1) return root&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L105_Construct_Binary_Tree]]></title>
    <url>%2F2017-11-27-L105-Construct-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述L105通过preorder以及inorder构建二叉树 12preorder = [1,2,4,3,5]inorder = [4,2,1,3,5] L106通过postorder以及inorder构建二叉树 12postorder = [4,2,5,3,1]inorder = [4,2,1,3,5] 通过preorder以及postorder无法构建二叉树，原因在于无法定位根节点。 解题思路首先找到根节点，然后在inorder找到其他的index，[0,index-1]为左子树，[index+1,]为右子树。递归左子树部分，通过左子树的inorder以及preorder生成左子树。同理右子树也如此。 Go递归实现通过preorder以及inorder生成二叉树123456789101112131415161718192021222324252627282930313233func build(preorder []int, inorder []int, inStart int, inEnd int, preIndex *int)*TreeNode &#123; if inStart&gt;inEnd &#123; return nil &#125; node := new(TreeNode) node.Val = preorder[*preIndex] *preIndex += 1 if inStart == inEnd &#123; return node &#125; inIndex := search(inorder, inStart, inEnd, node.Val) node.Left = build(preorder, inorder, inStart, inIndex-1, preIndex) node.Right = build(preorder, inorder, inIndex+1, inEnd, preIndex) return node&#125;func search(inorder []int, inStart int, inEnd int, val int) int &#123; for i:=inStart;i&lt;=inEnd ;i++ &#123; if inorder[i] == val &#123; return i &#125; &#125; return -1&#125;func buildTree(preorder []int, inorder []int) *TreeNode &#123; preIndex:=0 return build(preorder, inorder, 0, len(inorder)-1, &amp;preIndex)&#125; 参考链接：http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/ 通过postorder以及inorder生成二叉树1234567891011121314151617181920212223242526272829303132333435func build(inorder []int, postorder []int, inStart int, inEnd int, postIndex *int)*TreeNode &#123; if inStart&gt;inEnd &#123; return nil &#125; node := new(TreeNode) node.Val = postorder[*postIndex] *postIndex -= 1 if inStart == inEnd&#123; return node &#125; inIndex := search(inorder, inStart, inEnd, node.Val) node.Right = build(inorder, postorder,inIndex+1, inEnd, postIndex) node.Left = build(inorder, postorder,inStart, inIndex-1, postIndex) return node&#125;func search(inorder []int, inStart int, inEnd int, val int) int &#123; var i int for i=inStart;i&lt;=inEnd ;i++ &#123; if inorder[i] == val &#123; break &#125; &#125; return i&#125;func buildTree(inorder []int, postorder []int) *TreeNode &#123; postIndex:=len(postorder)-1 return build(inorder, postorder, 0, len(inorder)-1, &amp;postIndex)&#125; 参考链接：http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/ 通过postorder和inorder生成二叉树，是先递归生成右子树，然后再是左子树。中心思想是先定位根节点。 以postorder为例说明:[4,2,5,3,1] 12345 1 / \ 2 3 / \4 5 postorder[4]为根节点postorder[3]为根节点的右节点 同样preorder为例说明:[1,2,4,3,5] preorder[0]为根节点preorder[1]为根节点的左节点]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L113 Path Sum II]]></title>
    <url>%2F2017-11-24-L113-Path-Sum-II%2F</url>
    <content type="text"><![CDATA[题目描述12345678910111213141516Given a binary tree and a sum, find all root-to-leaf paths where each path&apos;s sum equals the given sum.For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1return[ [5,4,11,2], [5,8,4,5]] 解题思路题目和L112 Path Sum思路相同，通过DFS遍历获取路径。不同的是需要通过数组保存路径。 Go递归实现12345678910111213141516171819202122232425262728293031func DFS(root *TreeNode, target int, sum int, path []int, ret *[][]int) &#123; if root == nil&#123; return &#125; sum += root.Val tmp := append(path, root.Val) path = tmp[:] if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp;sum == target&#123; //*ret = append(*ret, path) tmp :=[]int&#123;&#125; for _,v:= range path &#123; tmp = append(tmp, v) &#125; *ret = append(*ret, tmp) &#125; DFS(root.Left, target, sum, path, ret) DFS(root.Right, target, sum, path, ret)&#125;func pathSum(root *TreeNode, sum int) [][]int &#123; path :=[]int&#123;&#125; ret :=[][]int&#123;&#125; DFS(root, sum, 0, path, &amp;ret) return ret&#125; 这里的path不能直接append，而是进行值的拷贝 Go循环实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263func judge(current *TreeNode, parent map[*TreeNode]*TreeNode, target int) []int &#123; var stack []*TreeNode path :=[]int&#123;&#125; sum := 0 for current!=nil &#123; stack = append(stack, current) sum += current.Val current = parent[current] &#125; if sum == target &#123; k := len(stack)-1 for k &gt;=0&#123; path = append(path, stack[k].Val) k-- &#125; return path &#125;else&#123; return nil &#125;&#125;func dfsNoRecursion(root *TreeNode, target int) [][]int &#123; if root == nil&#123; return nil &#125; var stack []*TreeNode ret :=[][]int&#123;&#125; stack = append(stack, root) parent := make(map[*TreeNode]*TreeNode, 0) parent[root] = nil var current *TreeNode for len(stack)&gt;0 &#123; current = stack[len(stack)-1] stack = stack[0:len(stack)-1] if current.Left == nil &amp;&amp; current.Right==nil &#123; path :=judge(current, parent,target) if path !=nil &#123; ret = append(ret, path) &#125; &#125; if current.Right !=nil &#123; stack = append(stack, current.Right) parent[current.Right] = current &#125; if current.Left != nil &#123; stack = append(stack, current.Left) parent[current.Left] = current &#125; &#125; return ret&#125;func pathSum(root *TreeNode, sum int) [][]int &#123; ret:=dfsNoRecursion(root, sum) return ret&#125; 需要记录节点的父亲节点信息，用于路径的回溯 参考的链接:http://www.geeksforgeeks.org/print-root-leaf-path-without-using-recursion/ Python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849__author__ = 'guosong'# Definition for a binary tree node.class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ path = [] ret = [] self.dfs(root, sum, 0, path, ret) return ret def initTree(self, root, nums, i, n): if i &lt; n: if nums[i] == -1: root = None else: node = TreeNode(nums[i]) root = node root.left = self.initTree(root.left, nums, 2*i+1, n) root.right = self.initTree(root.right, nums, 2*i+2, n) return root def dfs(self, root, target, s,path, ret): if not root: return s += root.val path = path + [root.val] #path.append(root.val) if not root.left and not root.right and s == target: ret.append(path) self.dfs(root.left, target, s, path, ret) self.dfs(root.right, target,s, path, ret)s = Solution()nums = [5,4,8,11,-1,13,4,7,2,-1,-1,-1,-1,5,1]root = Noneroot = s.initTree(root, nums,0,len(nums))print s.pathSum(root, 22) 注意点：path的追加方式不是通过path.append(root.val)，而是path=path+[root.val]的方式。]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L112 Path Sum]]></title>
    <url>%2F2017-11-23-L112-Path-Sum%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 解题思路使用深度遍历的方式进行解决。 Go实现12345678910111213141516171819func travel(root *TreeNode, target int, sum int) bool&#123; if root == nil &#123; return false &#125; sum += root.Val if root.Left==nil &amp;&amp; root.Right==nil &#123; if sum == target &#123; return true &#125;else&#123; return false &#125; &#125; return travel(root.Left, target, sum) || travel(root.Right, target, sum)&#125;func hasPathSum(root *TreeNode, sum int) bool &#123; return travel(root, sum, 0)&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L111 Minimum Depth of Binary Tree]]></title>
    <url>%2F2017-11-22-L111-Minimum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述1234567891011Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.Example: 1 / 2Output:2 解题思路和104题目的解题思路相同 不同的是将depth设置为一个比较大的数，和level+1进行比较，如果出现更小的就替换。 Go实现1234567891011121314151617181920212223242526func travel(root *TreeNode, depth *int, level int) &#123; if root==nil &#123; return &#125; if root.Left == nil &amp;&amp; root.Right==nil &#123; if *depth&gt;level+1 &#123; *depth = level+1 &#125; return &#125; travel(root.Left, depth, level+1) travel(root.Right, depth, level+1)&#125;func minDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; var depth int depth=10000 travel(root, &amp;depth, 0) return depth&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L104 Maximum Depth of Binary Tree]]></title>
    <url>%2F2017-11-21-L104-Maximum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述1234Given a binary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 解题思路将maxDepth设置为0， 判断当面节点的depth是否大于maxDepth，如果是就替换。 Go实现1234567891011121314151617func travel(root *TreeNode, depth *int, level int)&#123; if root == nil&#123; if *depth &lt; level&#123; *depth = level &#125; return &#125;else&#123; travel(root.Left, depth, level+1) travel(root.Right, depth, level+1) &#125;&#125;func maxDepth(root *TreeNode) int &#123; var depth int travel(root, &amp;depth, 0) return depth&#125; 这个方法遍历了两边，是否可以减少遍历 1234567891011121314func maxDepth(root *TreeNode) int &#123; if root == nil&#123; return 0 &#125; leftDepth := maxDepth(root.Left) rightDepth := maxDepth(root.Right) if leftDepth &gt;rightDepth&#123; return leftDepth+1 &#125;else &#123; return rightDepth+1 &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Traceroute]]></title>
    <url>%2F2017-11-20-Traceroute%2F</url>
    <content type="text"><![CDATA[背景用户反馈使用移动4G以及wifi访问公司业务有问题，使用电信没有问题，故需要获取用户网络相关访问信息。traceroute工具是第一选择。 Traceroute使用说明通过traceroute可以知道信息从计算机到互联网另一端的访问路径。traceroute通过发送小的数据包到目的设备直到其返回，来测量其需多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次的测试时间、设备名称（有的话）以及其IP地址。 Traceroute APP小白用户无法使用traceroute命令，况且需要在手机上traceroute，针对这个问题有traceroute APP。推荐腾讯云诊断APP，可以将针对结果通过QQ和微信分享。 其诊断信息包括： Http Net Ping NSLookup TraceRoute Device信息 PortScan Mtuscan Host 如下是腾讯云诊断APP的结果展示: 参考文档 https://www.cnblogs.com/peida/archive/2013/03/07/2947326.html]]></content>
      <tags>
        <tag>Linux Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L110 Balanced Binary Tree]]></title>
    <url>%2F2017-11-20-L110-Balanced-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目描述123Given a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 判断一个二叉树是否为平衡二叉树。平衡的定义是左右子树树的高度相差小于等于1。 解题思路使用前序遍历树，然后其对应的左右子树高度是否小于等于1。 Go实现12345678910111213141516171819202122232425262728293031func height(root *TreeNode, maxDepth *int, level int) &#123; if root == nil&#123; return &#125; if *maxDepth &lt;level &#123; *maxDepth = level &#125; height(root.Left, maxDepth, level+1) height(root.Right, maxDepth, level+1)&#125;func preOrder(root *TreeNode) bool &#123; var leftDepth=0 var rightDepth=0 if root == nil&#123; return true &#125; height(root.Left, &amp;leftDepth, 1) height(root.Right, &amp;rightDepth, 1) delta := leftDepth-rightDepth if delta&gt;=-1 &amp;&amp; delta&lt;=1 &#123; return preOrder(root.Left) &amp;&amp; preOrder(root.Right) &#125;else&#123; return false &#125;&#125;func isBalanced(root *TreeNode) bool &#123; return preOrder(root)&#125; 注意这里的level在root为非nil的时候设置为1 计算树的高度算法1234567func findDepth(root *TreeNode) int &#123; if nil == root &#123; return 0 &#125; return maxInt(findDepth(root.Left), findDepth(root.Right)) + 1&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L107 Binary Tree Level Order Traversal II]]></title>
    <url>%2F2017-11-19-L107-Binary-Tree-Level-Order-Traversal-II%2F</url>
    <content type="text"><![CDATA[题目描述12345678910111213141516Given a binary tree, return the bottom-up level order traversal of its nodes values.(ie, from left to right, level by level from leaf to root).For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its bottom-up level order traversal as:[ [15,7], [9,20], [3]] 层次遍历树节点，并按照层次的逆序输出 解题思路使用前序遍历的方法，将各个节点对应的level打印出来，然后level进行归类。 Go实现-递归1234567891011121314151617181920212223242526272829303132333435363738394041424344import ( "sort")func preorder(root *TreeNode, ret *[]int, levelList *[]int, level int) &#123; if root == nil&#123; return &#125; *ret = append(*ret, root.Val) *levelList = append(*levelList, level) preorder(root.Left, ret, levelList, level+1) preorder(root.Right, ret, levelList, level+1)&#125;func levelOrderBottom(root *TreeNode) [][]int &#123; if root == nil&#123; return nil &#125; r :=[][]int&#123;&#125; ret :=[]int&#123;&#125; levelList :=[]int&#123;&#125; preorder(root, &amp;ret, &amp;levelList,0) m := map[int][]int&#123;&#125; for i,v:=range levelList &#123; m[v] = append(m[v], ret[i]) &#125; keys :=[]int&#123;&#125; for k := range m&#123; keys = append(keys, k) &#125; sort.Ints(keys) n := len(keys) - 1 for n&gt;=0 &#123; r = append(r, m[keys[n]]) n-- &#125; return r&#125; 前序遍历比较简单，主要代码在于结果的处理。 相似题目L102其输出的顺序是层次遍历二叉树，根节点先出，最后是叶子节点. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport "fmt"/** * Definition for a binary tree node. */type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;func initTree(root *TreeNode, nums []int, i int, n int) *TreeNode &#123; var node *TreeNode if i &lt; n &#123; if nums[i] == -1 &#123; root = nil &#125; else &#123; node = new(TreeNode) node.Val = nums[i] root = node root.Left = initTree(root.Left, nums, 2*i+1, n) root.Right = initTree(root.Right, nums, 2*i+2, n) &#125; &#125; return root&#125;func travel(root *TreeNode, level int, m map[int][]int) &#123; if root == nil &#123; return &#125; if _, ok := m[level]; !ok &#123; m[level] = []int&#123;root.Val&#125; &#125; else &#123; m[level] = append(m[level], root.Val) &#125; travel(root.Left, level+1, m) travel(root.Right, level+1, m)&#125;func levelOrder(root *TreeNode) [][]int &#123; m := make(map[int][]int, 0) ret := [][]int&#123;&#125; travel(root, 0, m) maxDepth := 0 for k, _ := range m &#123; if maxDepth &lt; k &#123; maxDepth = k &#125; &#125; for i := 0; i &lt;= maxDepth; i++ &#123; ret = append(ret, m[i]) &#125; return ret&#125;func main() &#123; var root *TreeNode nums := []int&#123;3, 9, 20, -1, -1, 15, 7&#125; root = initTree(root, nums, 0, len(nums)) ret := levelOrder(root) fmt.Println(ret)&#125; 相似题目L103通过深度遍历，记录各个节点的level，然后以zigzag的方式输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func travel(root *TreeNode, level int, m map[int][]int) &#123; if root == nil &#123; return &#125; if _, ok := m[level]; !ok &#123; m[level] = []int&#123;root.Val&#125; &#125; else &#123; m[level] = append(m[level], root.Val) &#125; travel(root.Left, level+1, m) travel(root.Right, level+1, m)&#125;func reverse(nums []int) []int &#123; s:=0 e:=len(nums)-1 for s&lt;e&#123; nums[s], nums[e] = nums[e], nums[s] s++ e-- &#125; return nums&#125;func zigzagLevelOrder(root *TreeNode) [][]int &#123; m := make(map[int][]int, 0) ret := [][]int&#123;&#125; if root == nil&#123; return ret &#125; travel(root, 0, m) maxDepth := 0 for k, _ := range m &#123; if maxDepth &lt; k &#123; maxDepth = k &#125; &#125; for i := 0; i &lt;= maxDepth; i++ &#123; if i%2==1 &#123; ret = append(ret, reverse(m[i])) &#125;else&#123; ret = append(ret, m[i]) &#125; &#125; return ret&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L101_Symmetric_Tree]]></title>
    <url>%2F2017-11-17-L101-Symmetric-Tree%2F</url>
    <content type="text"><![CDATA[题目描述123456789101112131415161718Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \3 4 4 3But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3Note:Bonus points if you could solve it both recursively and iteratively. 解题思路此题目可以转化为L100_Same_Tree的解题思路。L100是判断两颗树是否相同，比较Left和Right是否相同，对两个数进行中序遍历。此题目可以对root的Left进行中左右遍历，对root的Right进行中右左遍历。 Go实现-递归123456789101112131415161718192021222324func judge(left *TreeNode, right *TreeNode) bool &#123; if left == nil &amp;&amp; right == nil&#123; return true &#125; if (left == nil &amp;&amp; right !=nil) || (left !=nil &amp;&amp; right == nil)&#123; return false &#125; if left.Val == right.Val &#123; return judge(left.Left, right.Right) &amp;&amp; judge(left.Right, right.Left) &#125;else&#123; return false &#125;&#125;func isSymmetric(root *TreeNode) bool &#123; if root == nil&#123; return true &#125; return judge(root.Left, root.Right)&#125; NOTE:如果root节点为nil，返回值为true 去除重复的逻辑判断后的代码 123456789101112131415161718func judge(left *TreeNode, right *TreeNode) bool &#123; if left == nil &amp;&amp; right == nil&#123; return true &#125; if left == nil || right !=nil&#123; return false &#125; return (left.Val == right.Val) &amp;&amp; judge(left.Left, right.Right) &amp;&amp; judge(left.Right, right.Left) &#125;func isSymmetric(root *TreeNode) bool &#123; return judge(root, root)&#125; Go非递归实现使用非递归遍历的方法将左右子树节点放在数组中，然后比较这两个数组的数据是否相同。注意点：对于不存在的节点，其对应的值为-1，例如下面的例子: 12345 1 / \2 2 \ \ 3 3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758func order(root *TreeNode, flag bool) (t_list[]int) &#123; var stack []*TreeNode var p *TreeNode p = root for p != nil || len(stack)!=0 &#123; for p!=nil &#123; t_list = append(t_list, p.Val) stack = append(stack, p) if flag &#123; p = p.Left &#125;else &#123; p = p.Right &#125; &#125; t_list = append(t_list, -1) if len(stack)!=0 &#123; p = stack[len(stack)-1] stack = stack[0:len(stack)-1] if flag &#123; p = p.Right &#125;else&#123; p = p.Left &#125; &#125; &#125; return&#125;func judge(t1 *TreeNode, t2 *TreeNode) bool &#123; if t1 == nil &amp;&amp; t2 == nil&#123; return true &#125; if t1 == nil || t2 ==nil&#123; return false &#125; var t1_list []int var t2_list []int t1_list = order(t1.Left, true) t2_list = order(t2.Right, false) if len(t1_list) != len(t2_list) &#123; return false &#125; for i:=0;i&lt;len(t1_list);i++ &#123; if t1_list[i] != t2_list[i] &#123; return false &#125; &#125; return true&#125;func isSymmetric(root *TreeNode) bool &#123; return judge(root, root)&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L100_SameTree]]></title>
    <url>%2F2017-11-17-L100-SameTree%2F</url>
    <content type="text"><![CDATA[题目描述判断两个二叉树是否相同 1234567891011121314151617181920212223242526272829303132Given two binary trees, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical and the nodes have the same value.Example 1:Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: trueExample 2:Input: 1 1 / \ 2 2 [1,2], [1,null,2]Output: falseExample 3:Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]Output: false 解题思路中序遍历二叉树 Go实现123456789101112131415161718192021func isSameTree(p *TreeNode, q *TreeNode) bool &#123; if p==nil &amp;&amp; q ==nil&#123; return true &#125; if (p==nil &amp;&amp; q !=nil)||(p!=nil &amp;&amp; q==nil) &#123; return false &#125; if p.Val==q.Val &#123; flag:=isSameTree(p.Left, q.Left) if flag &#123; flag=isSameTree(p.Right, q.Right) &#125;else&#123; return false &#125; return flag &#125;else&#123; return false &#125;&#125; 将flag部分去掉，改进的写法: 123456789101112131415func isSameTree(p *TreeNode, q *TreeNode) bool &#123; if p==nil &amp;&amp; q ==nil&#123; return true &#125; if (p==nil &amp;&amp; q !=nil)||(p!=nil &amp;&amp; q==nil) &#123; return false &#125; if p.Val==q.Val &#123; return isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right,q.Right) &#125;else&#123; return false &#125;&#125; 问题难点在完成这道题目的时候，直接submit的，没有进行测试，难点在于如何构建这个二叉树。 使用后续遍历的方式生成二叉树。 Go代码实现 12345678910111213141516func initTree(root *TreeNode, nums []int, i int, n int) *TreeNode &#123; var node *TreeNode if i&lt;n &#123; if nums[i] == -1&#123; node = nil &#125;else&#123; node = new(TreeNode) node.Val = nums[i] root = node root.Left = initTree(root.Left, nums, 2*i+1, n) root.Right = initTree(root.Right, nums, 2*i+2, n) &#125; &#125; return root&#125; 参考来源：http://www.geeksforgeeks.org/construct-complete-binary-tree-given-array/ 测试 使用中序遍历1234567func inOrder(root *TreeNode) &#123; if root!=nil &#123; inOrder(root.Left) fmt.Println(root.Val) inOrder(root.Right) &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L83_Merge_Sorted_Array]]></title>
    <url>%2F2017-11-16-L83-Merge-Sorted-Array%2F</url>
    <content type="text"><![CDATA[题目描述12345Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 解题思路nums1有足够的空间可以容纳2个数组的数据，故解题思路前提是不额外申请空间。遍历nums2数据对nums1进行插入排序。 Go实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport "fmt"func merge(nums1 []int, m int, nums2 []int, n int) &#123; if m == 0 &#123; for k:=0;k&lt;n;k++ &#123; nums1[k] = nums2[k] &#125; &#125; if n == 0 &#123; return &#125; j:=0 for j&lt;n &#123; i:=0 for i&lt;m &amp;&amp; nums1[i]&lt;nums2[j] &#123; i++ &#125; if i&gt;=m &#123; nums1[i] = nums2[j] j++ &#125;else &#123; t := nums1[i] nums1[i] = nums2[j] for i&lt;m &#123; t1 :=nums1[i+1] nums1[i+1] = t t = t1 i++ &#125; j++ &#125; m +=1 &#125;&#125;func main() &#123; nums1 := make([]int,10) //[]int&#123;1,3,5&#125; nums1[0] = 1 nums1[1] = 0 nums2 :=[]int&#123;2&#125; m := 1 n := 1 merge(nums1, m, nums2, n) fmt.Println(nums1[0:m+n])&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L83_从有序链表中删除重复的数据]]></title>
    <url>%2F2017-11-16-LeetCode-L83-%E4%BB%8E%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[题目描述12345Given a sorted linked list, delete all duplicates such that each element appear only once.For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 从有序链表中删除重复的数据 解题思路 使用两个指针prev，next变量链表 判断next的val是否和prev的val相同 如果相同，将prev的next设置为next.next，删除next节点 如果不同，将prev以及next都往后移动 Go 循环实现增加Insert以及printNode两个函数便于测试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package mainimport "fmt"/** * Definition for singly-linked list.*/type ListNode struct &#123; Val int Next *ListNode&#125;func Insert(vals...int) *ListNode&#123; var head *ListNode current := head for _,v := range vals &#123; n := new(ListNode) n.Val = v if head == nil &#123; head = n current = head &#125;else&#123; current.Next = n current = n &#125; &#125; return head&#125;func printNode(head *ListNode) &#123; for head!=nil &#123; fmt.Println(head.Val) head = head.Next &#125;&#125;func deleteDuplicates(head *ListNode) *ListNode &#123; if head == nil&#123; return nil &#125; prev := head next := head.Next for next !=nil &#123; if next.Val == prev.Val &#123; prev.Next = next.Next &#125;else&#123; prev = next &#125; next = next.Next &#125; return head&#125;func main() &#123; //1-&gt;1-&gt;2-&gt;3-&gt;3 head :=Insert(1,1,2,3,3) deleteDuplicates(head) printNode(head)&#125; Go递归实现123456789101112func deleteDuplicates(head *ListNode) *ListNode&#123; if head == nil || head.Next == nil&#123; return head &#125; if head.Val == head.Next.Val&#123; return deleteDuplicates(head.Next) &#125;else&#123; head.Next = deleteDuplicates(head.Next) return head &#125;&#125; 递归实现的核心思想 如果head节点和head.Next出现重复，将head往重复的节点移动，按照再判断以此节点为head的链表去除情况。 如果head的后面节点没有和head相同，对head的Next节点为新的head进行去重判断。head节点维持不变。 Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445__author__ = 'guosong'# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or head.next == None: return head if head.val == head.next.val: return self.deleteDuplicates(head.next) else: head.next = self.deleteDuplicates(head.next) return head def insert(self, vals): head = None current = None for v in vals: n = ListNode(v) if not head: head = n current = head else: current.next = n current = current.next return head def printNode(self, head): while head: print head.val head = head.nexts = Solution()head = s.insert([1,1,2,3])head = s.deleteDuplicates(head)s.printNode(head)]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L66_PlusOne]]></title>
    <url>%2F2017-11-14-Leetcode-L66-PlusOne%2F</url>
    <content type="text"><![CDATA[题目描述12345Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.You may assume the integer do not contain any leading zero, except the number 0 itself.The digits are stored such that the most significant digit is at the head of the list. 大体意思是给一个数组表示一个非负数，这个非负数加上1，结果还返回一个数组 解题思路倒叙遍历数组，判断是否需要进位。 Go 版本1234567891011121314151617181920212223242526272829303132func plusOne(digits []int) []int &#123; n := len(digits) ret :=[]int&#123;&#125; s :=1 for i:=n-1; i&gt;=0; i-- &#123; s += digits[i] if s&gt;9&#123; ret = append(ret, s%10) s = s/10 &#125;else &#123; ret = append(ret,s) s = 0 &#125; &#125; if s &gt; 0&#123; ret = append(ret, s) &#125; n = len(ret) i:=0 j:=n-1 for i&lt;j&#123; ret[i], ret[j] = ret[j], ret[i] i++ j-- &#125; return ret&#125; Python版本在Go的版本临时申请一个数组保存结果，通过append函数在尾部进行追加，最后返回这个数组的倒序结果。 Python版本中不借助额外的空间，使用insert函数在头部插入。 1234567891011121314151617181920class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ n = len(digits) - 1 carry = 1 while n&gt;=0: digits[n] += carry if digits[n] &gt; 9: carry = digits[n]/10 digits[n] %= 10 else: carry = 0 n-=1 if carry: digits.insert(0,1) return digits]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L15_3sum]]></title>
    <url>%2F2017-11-13-leetcode-L15-3sum%2F</url>
    <content type="text"><![CDATA[题目描述Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 1234567For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 解题思路首先将数组进行排序，排序后使用3个索引进行sum的判断 Go版本1234567891011121314151617181920212223242526272829303132333435363738import ( "sort")func threeSum(nums []int) [][]int &#123; l := len(nums) r := [][]int&#123;&#125; sort.Ints(nums) for i:=0; i&lt;l-2;i++ &#123; j := i+1 k := l-1 for j&lt;k &#123; s := nums[i] + nums[j] + nums[k] if s&gt;0&#123; k-- &#125;else if s&lt;0 &#123; j++ &#125;else &#123; row:=[]int&#123;nums[i],nums[j], nums[k]&#125; flag := true for _, v := range r&#123; if v[0]==row[0] &amp;&amp;v[1] == row[1] &amp;&amp; v[2] == row[2] &#123; flag = false break &#125; &#125; if flag &#123; r = append(r,row) &#125; j++ k-- &#125; &#125; &#125; return r&#125; Python版本123456789101112131415161718192021222324252627class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ r = [] nums = sorted(nums) l = len(nums) for i in range(l): j = i + 1 k = l - 1 while j &lt; k: s = nums[i] + nums[j] + nums[k] if s &gt; 0: k -= 1 elif s &lt; 0: j += 1 else: t = [nums[i], nums[j], nums[k]] if t not in r: r.append(t) j += 1 k -= 1 return r]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcollector源码功能解读]]></title>
    <url>%2F2017-03-22-tcollectoryuan-ma-gong-neng-jie-du%2F</url>
    <content type="text"><![CDATA[简介 tcollector包括如下python学习点，强烈推荐阅读 参数解析 log日志 信号量 目录结构遍历 多线程以及多线程之间的数据共享 队列 定时任务 rpm打包 collector采集 程序兼容以及动态（collectors的动态更新，程序如何兼容） subprocess执行脚本 socket通信 正则表达式 守护进程 PYTHONPATH 设置 yield 迭代实现 单元测试以及mock 功能测试守护进程123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python#-*-coding:utf8-*-import timeimport osdef daemonize(): if os.fork(): os._exit(0) os.chdir("/") os.umask(022) os.setsid() os.umask(0) if os.fork(): os._exit(0) stdin = open(os.devnull) stdout = open(os.devnull, 'w') os.dup2(stdin.fileno(), 0) os.dup2(stdout.fileno(), 1) os.dup2(stdout.fileno(), 2) stdin.close() stdout.close() for fd in xrange(3, 1024): try: os.close(fd) except OSError: passif __name__ == '__main__': daemonize() while True: with open("/Users/guosong/opdir/20181105/data", "a+") as f: f.write("%s\n" % time.ctime()) time.sleep(5)]]></content>
  </entry>
  <entry>
    <title><![CDATA[AWS boto3]]></title>
    <url>%2F2017-02-08-aws-boto3%2F</url>
    <content type="text"><![CDATA[1.根据机器名称获取instance1234567ec2 = boto3.resource("ec2")instances = ec2.instances.filter(¦ ¦ Filters = [&#123;'Name': 'tag-value', 'Values':['service-test1']&#125;])for instance in instances:¦ print instance 2.获取所有机器的信息1234ec2 = boto3.resource("ec2")instances = ec2.instances.filter()for instance in instances:print instance 3.通过instance_id获取机器信息123ec2 = boto3.resource("ec2")instance = ec2.Instance('i-d8d0c8e1')print instance.instance_type 通过方法1和方法3获取信息所需要时间差不多，方法2获取所需要时间多。]]></content>
      <categories>
        <category>AWS API</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在AWS EC2搭建Hadoop2.6集群]]></title>
    <url>%2F2016-12-23-zai-aws-ec2da-jian-hadoop2-dot-6ji-qun%2F</url>
    <content type="text"><![CDATA[升级Java版本Hadoop2.X版本需要JDK1.8版本，故首要任务就先升级JDK 1234sudo yum install java-1.8.0-openjdk.x86_64#生成jpssudo yum install java-1.8.0-openjdk-devel.x86_64sudo alternatives --config java 安装hadoophttp://www.powerxing.com/install-hadoop-cluster/ 1234hdfs namenode -format # 首次运行需要执行初始化，之后不需要start-dfs.shstart-yarn.shmr-jobhistory-daemon.sh start historyserver 安装zookeeperhttp://blog.csdn.net/huwei2003/article/details/49101269 安装hbasehttp://www.cnblogs.com/nexiyi/p/hbase_intro_94.html 安装Hivehttp://kevin12.iteye.com/blog/2280777 问题汇总 找不到java驱动将java-connector-driver放在lib下 Terminal initialization failed; falling back to unsupported原因是hadoop目录下存在老版本jline： 12/hadoop-2.5.2/share/hadoop/yarn/lib：-rw-r--r-- 1 root root 87325 Mar 10 18:10 jline-0.9.94.jar 解决方法是：将hive下的新版本jline的JAR包拷贝到hadoop下： 1234cp /hive/apache-hive-1.1.0-bin/lib/jline-2.12.jar .//hadoop-2.5.2/share/hadoop/yarn/lib：-rw-r--r-- 1 root root 87325 Mar 10 18:10 jline-0.9.94.jar.bak-rw-r--r-- 1 root root 213854 Mar 11 22:22 jline-2.12.jar IntelliJIDE配置Maven库 使用私有的maven库12org.apache.hadoop.ipc.RemoteException: Server IPC version 9 cannot communicaite with client version 4 log4j:WARN No appenders could be found for logger (org.apache.hadoop.metrics2.lib.MutableMetricsFactory). Permission denied: user=guosong 写HDFS无权限[hadoop@hbase-test-00 ~]$ hdfs dfs -chown -R guosong:guosong /user/guosong[hadoop@hbase-test-00 ~]$ hdfs dfs -ls /user/guosong https://github.com/ljdursi/hadoop-for-hpcers-tutorial/blob/master/presentation/presentation.md Cannot run program “map.py”: error=2, No such file or directory 错误的命令 1hadoop jar ./hadoop-2.6.4/share/hadoop/tools/lib/hadoop-streaming-2.6.4.jar -input input/ncdd.txt -output output -mapper map.py -reducer reduce.py 正确的命令 1hadoop jar ./hadoop-2.6.4/share/hadoop/tools/lib/hadoop-streaming-2.6.4.jar -input input/ncdd.txt -output output -mapper map.py -file ./map.py -reducer reduce.py -file ./reduce.py https://wiki.apache.org/hadoop/HadoopStreaming Error: Could not find or load main class StreamCompressor 正确的方式： 1234567891011[hadoop@hbase-test-00 StreamCompressor]$ lltotal 4-rw-r--r-- 1 hadoop hadoop 1831 Jan 4 17:26 StreamCompressor.class[hadoop@hbase-test-00 StreamCompressor]$ echo $HADOOP_CLASSPATH/home/hadoop/code/StreamCompressor:[hadoop@hbase-test-00 StreamCompressor]$ pwd/home/hadoop/code/StreamCompressor[hadoop@hbase-test-00 StreamCompressor]$ echo &quot;TestDDDDDDDDDDD&quot; | hadoop StreamCompressor org.apache.hadoop.io.compress.GzipCodec |gunzip17/01/04 18:05:36 INFO zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library17/01/04 18:05:37 INFO compress.CodecPool: Got brand-new compressor [.gz]TestDDDDDDDDDDD 引申问题 HDFS块为什么设置128M？ namenode和datanode的区别？ namenode的HA方式？ Hadoop如何动态增加DataNode节点？]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Group Replication]]></title>
    <url>%2F2016-12-22-mysql-group-replication%2F</url>
    <content type="text"><![CDATA[1.前言2016年12月12日 MySQL5.7的Group Replication功能GA啦，一时间在微博、微信都有很多提起，主要看了如下一些分享： MySQL开发组的宋利兵分享的High Aavialability with Group Replication 云和恩墨团队以前同事分享的GR的基础知识 本文主要是基于MySQL5.7.17版本，参照MySQL5.7手册Group Replication部分进行实践。 2.Group Replication配置2.1 编译MySQL5.7.17 下载带有boost库版本的源码 cmake编译 1234cmake -DCMAKE_INSTALL_PREFIX=/home/guosong/mysql5717 \-DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_general_ci -DDOWNLOAD_BOOST=0 \-DWITH_BOOST=./boost/boost_1_59_0/ make &amp;&amp; make install 创建etc、tmp、log目录放置配置文件、日志文件以及socket等文件 初始化DB 1./bin/mysql_install_db --defaults-file=./etc/my5717.cnf --datadir=./data --lc-messages-dir=./share/ 2.2 Group Replication 基本配置 123456789server_id=XXXgtid_mode=ONenforce_gtid_consistency=ONmaster_info_repository=TABLErelay_log_info_repository=TABLEbinlog_checksum=NONElog_slave_updates=ONlog_bin=binlogbinlog_format=ROW Group Replication配置 123456transaction_write_set_extraction=XXHASH64loose-group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"loose-group_replication_start_on_boot=offloose-group_replication_local_address= "10.30.6.217:5718"loose-group_replication_group_seeds= "10.30.6.217:5718,10.30.6.184:5718,10.30.6.183:5718"loose-group_replication_bootstrap_group= off &gt;Line1 表示服务器记录每个事务基于XXHASH64算法对应的hahs值Line2 表示 group 名称Line3 表示插件在server启动后是否自动启动，此处设置不启动Line4 表示插件使用的IP地址10.30.6.217，端口5718为和其他成员连接使用，此处设置MySQL端口加1的Line5 表示组内成员所有的连接地址Line6 表示是否启动bootstrap 启动插件以及设置用户权限 12345678910111213141516INSTALL PLUGIN group_replication SONAME 'group_replication.so';mysql&gt; show plugins ;+----------------------------+----------+--------------------+----------------------+---------+| Name | Status | Type | Library | License |+----------------------------+----------+--------------------+----------------------+---------+| binlog | ACTIVE | STORAGE ENGINE | NULL | GPL || group_replication | ACTIVE | GROUP REPLICATION | group_replication.so | GPL |+----------------------------+----------+--------------------+----------------------+---------+mysql&gt; show grants for 'replica'@'%';+---------------------------------------------------------------------+| Grants for replica@% |+---------------------------------------------------------------------+| GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'replica'@'%' |+---------------------------------------------------------------------+1 row in set (0.00 sec) 启动Group Replication 123456CHANGE MASTER TO MASTER_USER='rpl_user', MASTER_PASSWORD='rpl_pass' \\FOR CHANNEL 'group_replication_recovery';SET GLOBAL group_replication_bootstrap_group=ON;START GROUP_REPLICATION;SET GLOBAL group_replication_bootstrap_group=OFF; 在三台server进行相关设置，全部开启Group_replication 状态校验 12345678mysql&gt; select * from performance_schema.replication_group_members;+---------------------------+--------------------------------------+---------------+-------------+--------------+| CHANNEL_NAME | MEMBER_ID | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE |+---------------------------+--------------------------------------+---------------+-------------+--------------+| group_replication_applier | 2a22f682-c378-11e6-bb00-0277185a730c | service-test2 | 5717 | ONLINE || group_replication_applier | 2bc442e4-c2b9-11e6-8c5b-02b39697b809 | service-test1 | 5717 | ONLINE || group_replication_applier | 3010a1a8-c378-11e6-b610-02870604bd20 | service-test3 | 5717 | ONLINE |+---------------------------+--------------------------------------+---------------+-------------+--------------+ 写入数据测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950mysql&gt; insert into t1 values(3,'Test');Query OK, 1 row affected (0.01 sec)mysql&gt; select * from t1;+----+---------+| c1 | c2 |+----+---------+| 1 | Luis || 2 | Guosong || 3 | Test |+----+---------+3 rows in set (0.00 sec)mysql&gt; show binlog events in 'mysql-bin.000004';+------------------+------+----------------+-----------+-------------+-------------------------------------------------------------------------+| Log_name | Pos | Event_type | Server_id | End_log_pos | Info |+------------------+------+----------------+-----------+-------------+-------------------------------------------------------------------------+| mysql-bin.000004 | 4 | Format_desc | 19795717 | 123 | Server ver: 5.7.17-log, Binlog ver: 4 || mysql-bin.000004 | 123 | Previous_gtids | 19795717 | 150 | || mysql-bin.000004 | 150 | Gtid | 19795717 | 211 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1' || mysql-bin.000004 | 211 | Query | 19795717 | 270 | BEGIN || mysql-bin.000004 | 270 | View_change | 19795717 | 409 | view_id=14823763458501488:1 || mysql-bin.000004 | 409 | Query | 19795717 | 474 | COMMIT || mysql-bin.000004 | 474 | Gtid | 19795717 | 535 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2' || mysql-bin.000004 | 535 | Query | 19795717 | 625 | create database test || mysql-bin.000004 | 625 | Gtid | 19795717 | 686 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3' || mysql-bin.000004 | 686 | Query | 19795717 | 809 | use `test`; create table t1(c1 int primary key, c2 text not null) || mysql-bin.000004 | 809 | Gtid | 19795717 | 870 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4' || mysql-bin.000004 | 870 | Query | 19795717 | 938 | BEGIN || mysql-bin.000004 | 938 | Table_map | 19795717 | 981 | table_id: 219 (test.t1) || mysql-bin.000004 | 981 | Write_rows | 19795717 | 1023 | table_id: 219 flags: STMT_END_F || mysql-bin.000004 | 1023 | Xid | 19795717 | 1050 | COMMIT /* xid=31 */ || mysql-bin.000004 | 1050 | Gtid | 19795717 | 1111 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:5' || mysql-bin.000004 | 1111 | Query | 19795717 | 1170 | BEGIN || mysql-bin.000004 | 1170 | View_change | 19795717 | 1349 | view_id=14823763458501488:2 || mysql-bin.000004 | 1349 | Query | 19795717 | 1414 | COMMIT || mysql-bin.000004 | 1414 | Gtid | 19795717 | 1475 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:6' || mysql-bin.000004 | 1475 | Query | 19795717 | 1534 | BEGIN || mysql-bin.000004 | 1534 | View_change | 19795717 | 1713 | view_id=14823763458501488:3 || mysql-bin.000004 | 1713 | Query | 19795717 | 1778 | COMMIT || mysql-bin.000004 | 1778 | Gtid | 19815717 | 1839 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:7' || mysql-bin.000004 | 1839 | Query | 19815717 | 1898 | BEGIN || mysql-bin.000004 | 1898 | Table_map | 19815717 | 1941 | table_id: 219 (test.t1) || mysql-bin.000004 | 1941 | Write_rows | 19815717 | 1986 | table_id: 219 flags: STMT_END_F || mysql-bin.000004 | 1986 | Xid | 19815717 | 2013 | COMMIT /* xid=75 */ || mysql-bin.000004 | 2013 | Gtid | 19795717 | 2074 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1000006' || mysql-bin.000004 | 2074 | Query | 19795717 | 2147 | BEGIN || mysql-bin.000004 | 2147 | Table_map | 19795717 | 2190 | table_id: 219 (test.t1) || mysql-bin.000004 | 2190 | Write_rows | 19795717 | 2232 | table_id: 219 flags: STMT_END_F || mysql-bin.000004 | 2232 | Xid | 19795717 | 2259 | COMMIT /* xid=93 */ |+------------------+------+----------------+-----------+-------------+-------------------------------------------------------------------------+ 2.2 数据冲突测试 从这里可以在两个不同的member对同一行数据进行update操作时候，没有任何限制，结果到时节点数据存在不一致的问题。具体配置错误的地方还在找，进一步研究。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Inception源码修改阅读]]></title>
    <url>%2F2016-11-03-inceptionyuan-ma-xiu-gai-yue-du%2F</url>
    <content type="text"><![CDATA[Inception介绍去哪儿开源的Inception是一个集审核、执行、备份以及生成回滚语句集一身的MySQL自动化运维工具，其是基于MySQL5.6.10版本进行修改的。本博文主要研究其修改以及增加的相关代码。 增加Inception关键字相关命令修改lex.h增加INCEPTION关键字123456789static SYMBOL symbols[] = &#123;... &#123; "INCEPTION", SYM(INCEPTION_SYM)&#125;, &#123; "INCEPTION_MAGIC_START", SYM(INCEPTION_START_SYM)&#125;, &#123; "INCEPTION_MAGIC_COMMIT", SYM(INCEPTION_COMMIT_SYM)&#125;,... &#123; "OSC_PERCENT", SYM(OSC_PERCENT_SYM)&#125;, &#123; "OSC", SYM(OSC_SYM)&#125;,&#125; INCEPTION INCEPTION 表示以inception开头相关的命令 INCEPTION_MAGIC_START，类似begin INCEPTION_MAGIC_COMMIT，类似commit 以下是相关的SQL举例：1234567inception_magic_start;use &lt;database name&gt;;&lt;any SQL statement&gt;inception_magic_commit;inception show tables;inception show variables like "%read_only%"; OSCInception集中OSC OSC_PERCENT，查询osc进度相关 OSC 执行和osc相关的操作 12inception get osc_percent &apos;当前执行的SQL语句以及一些基本信息生成的SHA1哈希值&apos;inception get osc processlist; 在sql_lex.h中增加Inception相关12345678/*引入symbol头文件*/#include &quot;lex_symbol.h&quot;/*增加Inception命令类型*/uint inception_cmd_type;/*增加新函数*/SYMBOL *get_hash_symbol(const char *s, unsigned int len,bool function); 修改sql_cmd.h增加新的SQL_COMMAND123456enum enum_sql_command &#123;...SQLCOM_INCEPTION_START, SQLCOM_INCEPTION_COMMIT,SQLCOM_INCEPTION,...&#125; 修改sql_yacc.yy添加相关tokensql_yacc.yy中主要修改部分如下: 添加inception相关token 注释掉和replication相关、spatial index相关 注释掉prepare预编译相关 增加inception相关语法逻辑 添加token123456789101112131415161718192021%token INCEPTION_START_SYM /* SQL-2003-R */%token INCEPTION_COMMIT_SYM /* SQL-2003-R */%token INCEPTION_SYM...%token OSC_PERCENT_SYM%token OSC_SYM%type &lt;lex_str&gt; ... /* 增加opt_variables_name */ opt_constraint constraint opt_ident opt_variables_name%type &lt;item&gt; ... update_set_expr_or_default update_set_expr%type &lt;NONE&gt; ...inception_magic_start inception_magic_commit begin commit rollback savepoint release inception... 解析INCEPTION_相关命令Inception相关命令SQL举例1234567inception_magic_startinception_magic_commitinception get variables;inception get variables 'variable_name';inception set [session] variables_name=value;inception get osc_percent '当前执行的SQL语句以及一些基本信息生成的SHA1哈希值';inception get processlist; Inception相关SQL逻辑 inception_magic_start 12345verb_clause: statement | begin | inception_magic_start ; inception_magic_commit 和inception 1234567891011121314/* Verb clauses, except begin */statement: alter | analyze | binlog_base64_event | call | change | check | checksum | commit | inception_magic_commit ... | inception ; opt_variables_name Inception参数相关完成修改无需用户名和密码登陆的认证 修改文件sql/sql_acl.cc:acl_authenticate 源码文件变动比较sql目录下各个文件存在如下129个文件有修改变动。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129binlog.ccCMakeLists.txtderror.ccderror.hevent_data_objects.ccevent_db_repository.ccevents.ccfield.ccfield.hfilesort.ccgen_lex_hash.cchandler.cchostname.ccitem.ccitem_cmpfunc.ccitem_create.ccitem_func.ccitem.hitem_strfunc.ccitem_strfunc.hitem_subselect.ccitem_subselect.hitem_sum.cclex.hlock.cclog.cclog_event.cclog_event.hlog_event_old.ccmf_iocache.ccmysqld.ccmysqld.hnet_serv.ccopt_range.ccopt_range.hopt_trace2server.ccopt_trace.hpartition_info.ccprotocol.ccrpl_gtid_execution.ccrpl_gtid_mutex_cond_array.ccrpl_gtid_state.ccrpl_info_factory.ccrpl_info_factory.hrpl_injector.ccrpl_master.ccrpl_mi.ccrpl_mi.hrpl_rli.ccrpl_rli.hrpl_rli_pdb.ccrpl_slave.ccrpl_slave.hrpl_utility.ccrpl_utility.hset_var.ccset_var.hsignal_handler.ccsp.ccsp_head.ccsp_instr.ccsp_rcontext.ccsql_acl.ccsql_acl.hsql_admin.ccsql_alter.ccsql_alter.hsql_analyse.ccsql_audit.hsql_base.ccsql_base.hsql_builtin.cc.insql_cache.ccsql_class.ccsql_class.hsql_cmd.hsql_connect.ccsql_const.hsql_cursor.ccsql_db.ccsql_delete.ccsql_derived.ccsql_do.ccsql_error.hsql_executor.ccsql_handler.ccsql_help.ccsql_insert.ccsql_lex.ccsql_lex.hsql_load.ccsql_locale.ccsql_parse.ccsql_parse.hsql_partition_admin.ccsql_partition.ccsql_planner.ccsql_plugin.ccsql_prepare.ccsql_profile.ccsql_reload.ccsql_rename.ccsql_resolver.ccsql_rewrite.ccsql_select.ccsql_select.hsql_servers.hsql_show.ccsql_show.hsql_string.hsql_table.ccsql_tmp_table.ccsql_tmp_table.hsql_trigger.ccsql_truncate.ccsql_union.ccsql_update.ccsql_view.ccsql_yacc.ccsql_yacc.hsql_yacc.yysys_vars.ccsys_vars.htable_cache.cctable.cctable.htransaction.ccunireg.ccunireg.h]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql添加新的操作命令]]></title>
    <url>%2F2016-10-26-mysqltian-jia-xin-de-cao-zuo-ming-ling%2F</url>
    <content type="text"><![CDATA[添加新的SQL命令（以SHOW DISK_USAGE为例）修改lex.h添加相关Token12345678910static SYMBOL symbols[] = &#123;...&#123; "DISK", SYM(DISK_SYM)&#125;,/*BEGIN GUOSONG MODIFICATION*//* Reason for Modification: *//* Tokens for the SHOW DISK_USAGE command*/&#123;"DISK_USAGE", SYM(DISK_USAGE_SYM)&#125;,/*END GUOSONG MODIFICATION*/&#123; "DISTINCT", SYM(DISTINCT)&#125;,... 修改sql_lex.h添加相关新命令123456789enum enum_sql_command &#123;...SQLCOM_SHOW_TRIGGERS,/*BEGIN GUOSONG MODIFICATION: *//*Reason for this modification: *//*Add SQLCOM_SHOW_DISK_USAGE reference*/SQLCOM_SHOW_DISK_USAGE,/*END GUOSONG MODIFICATION*/... 在MySQL5.6.27版本修改sql_cmd.h文件 12345678enum enum_sql_command &#123; .... SQLCOM_SHOW_TRIGGERS, /*BEGIN GUOSONG MODIFICATION: */ /*Reason for this modification: */ /*Add SQLCOM_SHOW_DISK_USAGE reference*/ SQLCOM_SHOW_DISK_USAGE, /*END GUOSONG MODIFICATION*/ 修改sql_yacc.yy添加相关token添加token 1234567%token DISK_SYM/*BEGIN GUOSONG MODIFICATION*//*Reasion for this modification:/*/*Add DISK_USAGE_SYM */%token DISK_USAGE_SYM/*END GUOSONG MODIFICATION*/%token DISTINCT /* SQL-2003-R */ 解析SHOW DISK_USAGE命令 12345678910111213141516171819202122show: SHOW &#123; LEX *lex=Lex; lex-&gt;wild=0; lex-&gt;lock_option= TL_READ; mysql_init_select(lex); lex-&gt;current_select-&gt;parsing_place= SELECT_LIST; bzero((char*) &amp;lex-&gt;create_info,sizeof(lex-&gt;create_info)); &#125;...show_param: /*BEGIN GUOSONG MODIFICATION*/ /*Reasion for this modification:*/ /*Add DISK_USAGE_SYM */ ¦ ¦ DISK_USAGE_SYM &#123; LEX *lex = Lex; lex-&gt;sql_command = SQLCOM_SHOW_DISK_USAGE; &#125; ¦ | DATABASES wild_and_where /*END GUOSONG MODIFICATION*/ 注意是在show databases 前面添加，故在DATABASES前面需要添加|这个竖线 添加SHOW DISK_USAGE命令的case在sql/sql_parser.cc文件中ysql_execute_command函数中添加123456789101112case SQLCOM_SHOW_AUTHORS:res= mysqld_show_authors(thd);break;/*BEGIN GUOSONG MODIFICATION*//*Reason for this modification*//*Add SQLCOM_SHOW_DISK_USAGE case statement*/case SQLCOM_SHOW_DISK_USAGE:&#123; res = mysqld_show_disk_usage(thd); break;&#125;/*END GUOSONG MODIFICATION*/ 添加函数声明，目前修改sql_show.h文件添加 12345/*BEGIN GUOSONG MODIFICATION*//*Reason for Modification*//*Declared mysqld_show_disk_usage function*/bool mysqld_show_disk_usage(THD *thd);/*END GUOSONG MODIFICATION*/ 在sql_show.cc中添加mysqld_show_disk_usage1234567891011121314151617181920212223242526/*BEGIN GUOSONG MODIFICATION*//*Reason for Modification*//*Add show disk uage method*//*****************************************************************************List all database disk usage***************************************************************************/bool mysqld_show_disk_usage(THD *thd)&#123; List&lt;Item&gt; field_list; Protocol *protocol = thd-&gt;protocol; DBUG_ENTER("mysqld_show_disk_usage"); field_list.push_back(new Item_empty_string("Database",50)); field_list.push_back(new Item_empty_string("Size_in_bytes", 30)); if(protocol-&gt;send_fields(&amp;field_list, Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF)) DBUG_RETURN(TRUE); /*sending test data*/ protocol-&gt;prepare_for_resend(); protocol-&gt;store("test_row", system_charset_info); protocol-&gt;store("1024", system_charset_info); if(protocol-&gt;write()) DBUG_RETURN(TRUE); my_eof(thd); DBUG_RETURN(FALSE);&#125;/*END GUSONG MODIFICATION*/ 在MySQL5.6.27中有些不同: 1234567891011121314151617181920212223242526/*BEGIN GUOSONG MODIFICATION*//*Reason for Modification*//*Add show disk uage method*//*****************************************************************************List all database disk usage***************************************************************************/bool mysqld_show_disk_usage(THD *thd)&#123; List&lt;Item&gt; field_list; Protocol *protocol = thd-&gt;protocol; DBUG_ENTER("mysqld_show_disk_usage"); field_list.push_back(new Item_empty_string("Database",50)); field_list.push_back(new Item_empty_string("Size_in_bytes", 30)); if(protocol-&gt;send_result_set_metadata(&amp;field_list, Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF)) DBUG_RETURN(TRUE); /*sending test data*/ protocol-&gt;prepare_for_resend(); protocol-&gt;store("test_row", strlen("test_row"),system_charset_info); protocol-&gt;store("1024", strlen("1024"), system_charset_info); if(protocol-&gt;write()) DBUG_RETURN(TRUE); my_eof(thd); DBUG_RETURN(FALSE);&#125;/*END GUSONG MODIFICATION*/ 通过bison以及gen_lex_hash生成相关语法123bison -y -p MYSQL -d sql_yacc.yy[guosong@dev-00 11:18:52 sql]$ll y.tab.y.tab.c y.tab.h 使用y.tab.c和y.tab.h替换sql_yacc.cc和sql_yacc.h 12mv y.tab.c sql_yacc.ccmv y.tab.h sql_yacc.h 通过gen_lex_hash命令生成新的lex_hash.h文件 12 在源码的sql目录下./gen_lex_hash &gt; lex_hash.h make install遇到错误12../include/my_global.h:482:53: error: size of array ‘compile_time_assert’ is negative__attribute__ ((unused)); 修改mysqld.cc文件 123456/*BEGIN GUOSONG MODIFICATION*//*Reason for Modification*//*Solve make error*/compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==¦ ¦ ¦ ¦ ¦SQLCOM_END + 8-1);/*END GUOSONG MODIFICATION*/ 测试12345678910111213141516171819202122232425262728[guosong@dev-00 18:40:48 mysql5627]$mysql5627Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.6.27-debug-log Source distributionCopyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; select version();+------------------+| version() |+------------------+| 5.6.27-debug-log |+------------------+1 row in set (0.00 sec)mysql&gt; show disk_usage;+----------+---------------+| Database | Size_in_bytes |+----------+---------------+| test_row | 1024 |+----------+---------------+1 row in set (0.00 sec) 增加统计数据库文件大小的真实统计代码真实统计代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/*BEGIN GUOSONG MODIFICATION*//*Reason for Modification*//*Add show disk uage method*//*****************************************************************************List all database disk usage***************************************************************************/bool mysqld_show_disk_usage(THD *thd)&#123; List&lt;Item&gt; field_list; List&lt;LEX_STRING&gt; dbs; LEX_STRING *db_name; char *path; MY_DIR *dirp; FILEINFO *file; longlong fsizes = 0; longlong total_sizes = 0; longlong lsizes = 0; Protocol *protocol = thd-&gt;protocol; DBUG_ENTER("mysqld_show_disk_usage"); field_list.push_back(new Item_empty_string("Database",50)); field_list.push_back(new Item_return_int("Size_in_bytes", 7, MYSQL_TYPE_LONGLONG)); if(protocol-&gt;send_result_set_metadata(&amp;field_list, Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF)) DBUG_RETURN(TRUE); /* get database directories*/ find_files_result res = find_files(thd, &amp;dbs, NULL,mysql_data_home, NULL, 1, NULL); if (res != FIND_FILES_OK) DBUG_RETURN(1); List_iterator_fast&lt;LEX_STRING&gt; it_dbs(dbs); path = (char*)my_malloc(PATH_MAX, MYF(MY_ZEROFILL)); dirp = my_dir(mysql_data_home, MYF(MY_WANT_STAT)); fsizes = 0; for(int i = 0; i&lt; (int)dirp-&gt;number_off_files;i++) &#123; file = dirp-&gt;dir_entry + i; if (strncasecmp(file-&gt;name, "ibdata", 6) == 0) fsizes = fsizes + file-&gt;mystat-&gt;st_size; else if (strncasecmp(file-&gt;name, "ib", 2) == 0) lsizes = lsizes + file-&gt;mystat-&gt;st_size; &#125; total_sizes += fsizes; total_sizes += lsizes; /* send Innodb data to client*/ protocol-&gt;prepare_for_resend(); protocol-&gt;store("InnoDB TableSpace", system_charset_info); protocol-&gt;store((longlong)fsizes); if (protocol-&gt;write()) DBUG_RETURN(TRUE); protocol-&gt;prepare_for_resend(); protocol-&gt;store("InnoDB logs", system_charset_info); protocol-&gt;store((longlong)lsizes); if (protocol-&gt;write()) DBUG_RETURN(TRUE); /*now send database name and sizes of the databases*/ while((db_name = it_dbs++)) &#123; fsizes = 0; strcpy(path, mysql_data_home); strcat(path, "/"); strcat(path, db_name-&gt;str); dirp = my_dir(path, MYF(MY_WANT_STAT)); for(int i=0; i&lt;(int)dirp-&gt;number_off_files;i++) &#123; file = dirp-&gt;dir_entry + i; fsizes = fsizes + file-&gt;mystat-&gt;st_size; &#125; protocol-&gt;prepare_for_resend(); protocol-&gt;store(db_name-&gt;str, system_charset_info); protocol-&gt;store((longlong)fsizes); if (protocol-&gt;write()) DBUG_RETURN(TRUE); total_sizes += fsizes; &#125; protocol-&gt;prepare_for_resend(); protocol-&gt;store("TotalSize", system_charset_info); protocol-&gt;store((longlong)total_sizes); if (protocol-&gt;write()) DBUG_RETURN(TRUE); my_eof(thd); /*free memory*/ my_free(path); my_dirend(dirp); DBUG_RETURN(FALSE);&#125;/*END GUSONG MODIFICATION*/ 测试1234567891011121314151617181920212223242526[guosong@dev-00 22:39:55 mysql5627]$mysql5627Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.6.27-debug-log Source distributionCopyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; show disk_usage;+--------------------+---------------+| Database | Size_in_bytes |+--------------------+---------------+| InnoDB TableSpace | 104857600 || InnoDB logs | 3145728000 || mysql | 1647392 || orchestrator | 6047749 || performance_schema | 493639 || test | 8257 || TotalSize | 3258782637 |+--------------------+---------------+7 rows in set (0.01 sec) 其他版本测试 添加自定义命令 show disk_usage 5.6.27版本 添加自定义命令 show disk_usage 5.1.45版本 添加新的引擎]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[innodb buffer dump and load]]></title>
    <url>%2F2016-08-25-innodb-buffer-dump-and-load%2F</url>
    <content type="text"><![CDATA[预热Innodb Buffer Pool针对线上运行的MySQL Server，如果重启不设置预热的话直接提供服务，会产生很多Disk IO导致性能严重下降。 在MySQL5.6 版本之后引入Buffer Pool的dump以及load功能。 Dump扫描Buffer Pool将相关table_id以及page_id写入文件中(默认在data目录下ib_buffer_pool文件中)。 1set global innodb_buffer_pool_dump_at_shutdown = 1; ib_buffer_pool内容如下: 1234567891011[root@service-test1 data]# head -n 10 ib_buffer_pool92,1768292,13163192,6182692,6508092,11175992,11436492,9641092,13163292,9449592,131633 Load动态实现load 1set global innodb_buffer_pool_load_now=1; 122016-08-25 16:23:06 7fdd367fc700 InnoDB: Loading buffer pool(s) from .//ib_buffer_pool2016-08-25 16:23:36 7fdd367fc700 InnoDB: Buffer pool(s) load completed at 160825 16:23:36 123456789101112131415mysql&gt; show global status like '%load%';+--------------------------------+--------------------------+| Variable_name | Value |+--------------------------------+--------------------------+| Innodb_buffer_pool_load_status | Loaded 16769/54873 pages |+--------------------------------+--------------------------+mysql&gt; show global status like '%load%';+--------------------------------+--------------------------------------------------+| Variable_name | Value |+--------------------------------+--------------------------------------------------+| Com_load | 0 || Com_preload_keys | 0 || Innodb_buffer_pool_load_status | Buffer pool(s) load completed at 160825 16:23:36 |+--------------------------------+--------------------------------------------------+ Load过程不影响启动，不是一定得load完成之后才响应相关请求。Load中如果发现对应的table_id以及page_id已经在buffer中，将直接跳过。 相关参考 https://blog.marceloaltmann.com/en-warm-up-innodb-buffer-pool-pt-esquentando-o-innodb-buffer-pool/ https://dev.mysql.com/doc/refman/5.6/en/innodb-preload-buffer-pool.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[How to install Yii2]]></title>
    <url>%2F2016-04-18-how-to-install-yii2%2F</url>
    <content type="text"><![CDATA[1. Install From Archived FileEdit file /var/www/basic/config/web.php, set cookieValidationKey 1&apos;cookieValidationKey&apos; =&gt; &apos;chuchujie&apos; 2. Call to undefined function mb_strlen1Fatal error: Call to undefined function mb_strlen() yum install php55-mbstring module. Version is import. 3. The directory is not writable by the Web process1234567ec2-user 13898 0.0 0.1 393312 20952 ? S 19:47 0:00 /usr/sbin/httpdec2-user 13900 0.0 0.1 395592 22116 ? S 19:47 0:00 /usr/sbin/httpdec2-user 13901 0.0 0.1 393048 20048 ? S 19:47 0:00 /usr/sbin/httpdec2-user 13975 0.0 0.1 392024 19528 ? S 19:47 0:00 /usr/sbin/httpdec2-user 14493 0.0 0.1 396096 23296 ? S 19:48 0:00 /usr/sbin/httpdec2-user 14494 0.0 0.1 392024 19396 ? S 19:48 0:00 /usr/sbin/httpdec2-user 14495 0.0 0.0 389784 14824 ? S 19:48 0:00 /usr/sbin/httpd 1chown -R ec2-user.ec2-user /var/www/basic http://www.g-loaded.eu/2008/12/09/making-a-directory-writable-by-the-webserver/ 4. Class ‘PDO’ not foundcould not find driver Caused by: PDOException 12yum install php55-pdo.x86_64 -yyum install php-ZendFramework-Db-Adapter-Pdo-Mysql.noarch -y 5. Yii2 Gii Forbidden code 403 You are not allowed to access this pageEdit config/web.php 1234$config['modules']['gii'] = ['class' =&gt; 'yii\gii\Module','allowedIPs' =&gt; ['127.0.0.1', '::1', '10.3xxxx'],]; Due to company vpn , choose the ip by Apache access log. http://jeepxiaozi.github.io/yii2xue-xi-bi-ji-xi-lie-6-generating-code-with-giishi-yong-giisheng-cheng-dai-ma.html 6. Yii2 Programing Stylehttps://github.com/yii2-chinesization/yii2-zh-cn/blob/master/internals-zh-CN/core-code-style.md 7. Referencehttps://github.com/forecho/awesome-yii2 8. Tree Managerhttp://demos.krajee.com/tree-manager#comment-2288987974]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis info memory研究]]></title>
    <url>%2F2016-04-15-redis-info-memoryyan-jiu%2F</url>
    <content type="text"><![CDATA[info memory输出信息12345678910info memory Memoryused_memory:5198608840used_memory_human:4.84Gused_memory_rss:11156660224used_memory_peak:9816601560used_memory_peak_human:9.14Gused_memory_lua:36864mem_fragmentation_ratio:2.15mem_allocator:libc http://www.cnblogs.com/mushroom/p/4738170.html 对应的代码： 123456789101112131415161718192021222324252627282930313233343536/* Memory */if (allsections || defsections || !strcasecmp(section,"memory")) &#123;char hmem[64];char peak_hmem[64];size_t zmalloc_used = zmalloc_used_memory();/* Peak memory is updated from time to time by serverCron() so it* may happen that the instantaneous value is slightly bigger than* the peak value. This may confuse users, so we update the peak* if found smaller than the current memory usage. */if (zmalloc_used &gt; server.stat_peak_memory)server.stat_peak_memory = zmalloc_used;bytesToHuman(hmem,zmalloc_used);bytesToHuman(peak_hmem,server.stat_peak_memory);if (sections++) info = sdscat(info,"\r\n");info = sdscatprintf(info,"# Memory\r\n""used_memory:%zu\r\n""used_memory_human:%s\r\n""used_memory_rss:%zu\r\n""used_memory_peak:%zu\r\n""used_memory_peak_human:%s\r\n""used_memory_lua:%lld\r\n""mem_fragmentation_ratio:%.2f\r\n""mem_allocator:%s\r\n",zmalloc_used,hmem,server.resident_set_size,server.stat_peak_memory,peak_hmem,((long long)lua_gc(server.lua,LUA_GCCOUNT,0))*1024LL,zmalloc_get_fragmentation_ratio(server.resident_set_size),ZMALLOC_LIB);&#125; used_memory]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL性能排查案例1]]></title>
    <url>%2F2016-04-11-mysqlxing-neng-pai-cha-an-li-1%2F</url>
    <content type="text"><![CDATA[1、简单查询问题排查12345678910111213 Scores: V/M = 0.14 Attribute pct total min max avg 95% stddev median ============ === ======= ======= ======= ======= ======= ======= ======= Count 2 5 Exec time 4 27s 4s 6s 5s 6s 878ms 6s Lock time 4 246us 43us 64us 49us 63us 7us 44us Rows sent 0 0 0 0 0 0 0 0 Rows examine 0 5 1 1 1 1 0 1 Query size 3 583 116 117 116.60 112.70 0 112.70UPDATE `cc_product_skus` SET `stock`='578' WHERE ( `id` = '20081272' ) AND ( `product_id` = '100122171387' ) LIMIT 1\G Converted for EXPLAIN EXPLAIN /*!50100 PARTITIONS*/select `stock`='578' from `cc_product_skus` where ( `id` = '20081272' ) AND ( `product_id` = '100122171387' ) LIMIT 1 \G 通过pt-query-digest的可以看出上面简单的update语句耗时会在4s-6s之间。 问题1-Lock_time是否包括innodb wait lock呢？http://lists.mysql.com/commits/115766MySQL 5.5.6版本之后已经改进这个问题。 目前线上使用MySQL 5.6.19版本，且通过下面的实验进行验证： 通过2个session，1个session持有锁，另外一个session等待这个锁，模拟innodb wait lock，对应的慢查询如下： 2、在慢查询里面看到Commit提交慢12345678910111213 Time: 160411 2:02:51 User@Host: shop2[shop2] @ [10.30.11.253] Id: 5888814786 Query_time: 7.139016 Lock_time: 0.000000 Rows_sent: 0 Rows_examined: 0SET timestamp=1460340171;COMMIT; User@Host: shop2[shop2] @ [10.30.10.50] Id: 5888814819 Query_time: 7.052946 Lock_time: 0.000000 Rows_sent: 0 Rows_examined: 0SET timestamp=1460340171;COMMIT; User@Host: shop2[shop2] @ [10.30.9.251] Id: 5888814800 Query_time: 7.089021 Lock_time: 0.000000 Rows_sent: 0 Rows_examined: 0SET timestamp=1460340171;COMMIT; 根据thread_id查看整个连接做了哪些操作： 123456789101112160411 2:02:44 5888814800 Connect shop2@10.xx.xxx.xxx on shop160411 2:02:44 5888814800 Query SET NAMES 'utf8'160411 2:02:44 5888814800 Query SET sql_mode=''160411 2:02:44 5888814800 Query SELECT * FROM `cc_order_user` WHERE ( `order_sn` = 'xxx' ) LIMIT 1160411 2:02:44 5888814800 Query SELECT * FROM `cc_order_products_user` WHERE ( `order_id` = 'xxx' )160411 2:02:44 5888814800 Query SELECT * FROM `cc_refund_order` WHERE ( `order_sn` = 'xxx' ) AND ( `status` = 0 ) ORDER BY id desc LIMIT 0,10160411 2:02:44 5888814800 Query SET AUTOCOMMIT=0160411 2:02:44 5888814800 Query UPDATE `cc_order_user` SET `shipping_sn`='1xxx',`shipping_company_id`='yxxx',`status_delivery`=2,`delivery_time`=1460340164 WHERE ( `order_sn` = 'xxxx' )160411 2:02:44 5888814800 Query COMMIT160411 2:02:51 5888814800 Query SET AUTOCOMMIT=1160411 2:02:51 5888814800 Quit 可以看到COMMIT就耗时7s 2.1 COMMIT的时候做了哪些操作呢？undolog日志 redlog日志 1234567m3306:shangcheng-m1 &gt;show variables like '%flush_log%';+--------------------------------+-------+| Variable_name | Value |+--------------------------------+-------+| innodb_flush_log_at_timeout | 1 || innodb_flush_log_at_trx_commit | 2 |+--------------------------------+-------+ 关于innodb_flush_log_at_trx_commit参数的含义如下图解释： 2.2 查看redo log更新的情况innodb_log_file_size参数大小 1234567891011121314m3306:shangcheng-m1 &gt;show variables like '%innodb_log_file%';+---------------------------+-----------+| Variable_name | Value |+---------------------------+-----------+| innodb_log_file_size | 134217728 || innodb_log_files_in_group | 2 |+---------------------------+-----------+m3306:shangcheng-m1 &gt;select 134217728/1024/1024;+---------------------+| 134217728/1024/1024 |+---------------------+| 128.00000000 |+---------------------+ 可以看出innodb_log_file_size只有128M，这和以往的经验差别很大（一般设置为&gt;1G）。 根据performance的给出计算参考： https://www.percona.com/blog/2008/11/21/how-to-calculate-a-good-innodb-log-file-size/ https://www.percona.com/blog/2006/07/03/choosing-proper-innodb_log_file_size/ 1234567 最大值MAX_SIZE=18.90M 业务高峰开启的时候2016-04-11 02:00:01 10.202016-04-11 02:01:01 18.902016-04-11 02:02:01 12.272016-04-11 02:03:01 13.22 按照上述参考计算值为18.9*60/2=567G,按照128M round，至少需要设置640M。 MySQL测试推荐 http://dimitrik.free.fr/blog/archives/2015/10/mysql-performance-yes-we-can-do-more-than-16m-qps-sql-on-mysql-57-ga.html Handler情况]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql故障总结]]></title>
    <url>%2F2016-03-16-mysqlgu-zhang-zong-jie%2F</url>
    <content type="text"><![CDATA[一、MetaTable Lock1、问题现象: 2、问题追查: 1234567891011121314151617181920212223242526select * from INNODB_TRX\G*************************** 1. row ***************************trx_id: 119520700800trx_state: RUNNINGtrx_started: 2016-03-16 04:45:25trx_requested_lock_id: NULLtrx_wait_started: NULLtrx_weight: 0trx_mysql_thread_id: 17427746trx_query: NULLtrx_operation_state: NULLtrx_tables_in_use: 0trx_tables_locked: 0trx_lock_structs: 0trx_lock_memory_bytes: 360trx_rows_locked: 0trx_rows_modified: 0trx_concurrency_tickets: 0trx_isolation_level: REPEATABLE READtrx_unique_checks: 1trx_foreign_key_checks: 1trx_last_foreign_key_error: NULLtrx_adaptive_hash_latched: 0trx_adaptive_hash_timeout: 10000trx_is_read_only: 0trx_autocommit_non_locking: 0 3、上面的thread对应的查询语句 这个对thread_id对应的用户是搜索的。 1160316 3:47:48 17424544 Connect shop_search@10.30.23.222 on shop 4、Metalock原理:http://dev.mysql.com/doc/refman/5.6/en/metadata-locking.htmlhttp://blog.itpub.net/25704976/viewspace-1379568/ Binlog内操作的记录是基于事务的提交顺序进行的，如果有一个事务未执行完成，而这个时候drop了表，这样在从库的执行顺序就会出现问题。MySQL在5.5.3版本后引入了Metadata lock锁，事务释放后才会释放Metadata lock，这样在事务完成期间，是不能进行DDL操作的。 从官方文档可以看出，对于Session1的SQL语句，不仅限于更新的SQL，对于SELECT语句一样如此，且其对Metalock的锁持有时间一直到事务结束。 5、问题模拟: 手动开启事务然后进行alter table操作: 回滚事务alter table操作成功: 6、改进方案1、开启事务(set autocommit=0)，一定要显示的commit或者rollback，且事务里面不要包括太多的语句。2、对于只是Select的查询，一定不要加事务，Innodb引擎是MVCC模式，加事务不起到任何作用。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis Sentinel]]></title>
    <url>%2F2016-03-11-redis-sentinel%2F</url>
    <content type="text"><![CDATA[1、Redis哨兵搭建测试1.1 Redis主从信息主从信息: 123redis主库:10.30.6.184(service-test2)redis从库1:10.30.6.183(service-test3)redis从库2:10.30.6.217（service-test1） redis部署的目录结构: 123456789101112131415161718├── bin│ ├── redis-benchmark│ ├── redis-check-aof│ ├── redis-check-dump│ ├── redis-cli│ ├── redis-sentinel│ ├── redis-server│ └── redis-trib.rb├── conf│ ├── r3050.conf│ └── sentinel.conf├── data│ ├── appendonly.aof│ └── r3050.rdb├── log│ └── r3050.log└── tmp└── redis3050.pid redis配置文件: 123456789101112131415161718192021222324252627daemonize yespidfile /home/op/redis3050/tmp/redis3050.pidport 3050timeout 172800loglevel noticelogfile /home/op/redis3050/log/r3050.logdatabases 16rdbcompression yesdbfilename r3050.rdbdir /home/op/redis3050/data/slave-serve-stale-data yesappendonly yesappendfilename appendonly.aofappendfsync everysecno-appendfsync-on-rewrite yesauto-aof-rewrite-percentage 0auto-aof-rewrite-min-size 64mbslowlog-log-slower-than 10000slowlog-max-len 1024list-max-ziplist-entries 512list-max-ziplist-value 64set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64activerehashing yesmaxmemory-policy noevictionmaxmemory 5G 1.2 哨兵配置以上三台机器上初始化sentinel配置 1234sentinel monitor mymaster 10.30.6.184 3050 2sentinel down-after-milliseconds mymaster 60000sentinel failover-timeout mymaster 18000sentinel config-epoch mymaster 0 通过下面命令在三台机器上启动哨兵: 1./bin/redis-sentinel ./conf/sentinel.conf &amp; 在主上可以看到收到下面消息，说明各个哨兵联合在一起了: 1222210:X 11 Mar 16:37:22.505 * +sentinel sentinel 10.30.6.183:26379 10.30.6.183 26379 @ mymaster 10.30.6.184 305022210:X 11 Mar 16:37:46.050 * +sentinel sentinel 10.30.6.217:26379 10.30.6.217 26379 @ mymaster 10.30.6.184 3050 这个时候的哨兵配置文件内容变成如下: 12345678910111213sentinel monitor mymaster 10.30.6.184 3050 2sentinel down-after-milliseconds mymaster 60000sentinel failover-timeout mymaster 18000sentinel config-epoch mymaster 0 Generated by CONFIG REWRITEport 26379dir &quot;/home/op/redis3050&quot;sentinel leader-epoch mymaster 0sentinel known-slave mymaster 10.30.6.217 3050sentinel known-slave mymaster 10.30.6.183 3050sentinel known-sentinel mymaster 10.30.6.217 26379 86aefa154fe695f9e0ea56312e01a14c24e79129sentinel known-sentinel mymaster 10.30.6.183 26379 61c53d7c01409da6b5e831d0fa26f49026909809sentinel current-epoch 0 每台均是如此。 2、Sentinel基本操作2.1 Sentinel masters列出所有被见识的主Redis服务实例，以及这些主服务实例的当前状态。 1234567891011121314127.0.0.1:26379&gt; sentinel masters1) 1) &quot;name&quot;2) &quot;mymaster&quot;3) &quot;ip&quot;4) &quot;10.30.6.184&quot;5) &quot;port&quot;6) &quot;3050&quot;7) &quot;runid&quot;8) &quot;680b4c8c7cb4a05fadbe968e03c2c9e3de42e09e&quot;9) &quot;flags&quot;10) &quot;master&quot;......37) &quot;parallel-syncs&quot;38) &quot;1&quot; 2.2 Sentinel Slaves列出给定主服务实例的所有从实例，以及这些从实例的当前状态。 1234567891011121314151617181920212223242526127.0.0.1:26379&gt; sentinel slaves mymaster1) 1) &quot;name&quot;2) &quot;10.30.6.217:3050&quot;3) &quot;ip&quot;4) &quot;10.30.6.217&quot;5) &quot;port&quot;6) &quot;3050&quot;7) &quot;runid&quot;8) &quot;9ae75482b5c770c7c0cf8aa2092eab7e450ec232&quot;9) &quot;flags&quot;10) &quot;slave&quot;......37) &quot;slave-repl-offset&quot;38) &quot;186791&quot;2) 1) &quot;name&quot;2) &quot;10.30.6.183:3050&quot;3) &quot;ip&quot;4) &quot;10.30.6.183&quot;5) &quot;port&quot;6) &quot;3050&quot;7) &quot;runid&quot;8) &quot;390beeec7d4ebfd0d4c0317eed3e97e498f4d9fd&quot;9) &quot;flags&quot;10) &quot;slave&quot;......38) &quot;186791&quot; 2.3 Sentinel get-master-addr-by-name返回给定名字的主实例IP地址和端口号。如果这个主实例正在进行故障转移操作，或者针对这个主实例的故障转移操作已经完成，那么这个命令返回新的主服务器的IP地址和端口号。 123127.0.0.1:26379&gt; sentinel get-master-addr-by-name mymaster1) &quot;10.30.6.184&quot;2) &quot;3050&quot; 2.4 Sentinel failover进行一次主动的failover，即在不询问Sentinel意见的情况下，强制开始一次自动故障迁移。发起故障迁移的Sentinel会向其他Sentinel发送一个新的配置，其他Sentinel会根据这个配置进行相应的更新。 123456789101112131415161718192021222324sentinel failover mymaster22210:X 11 Mar 17:03:59.846 # Executing user requested FAILOVER of &apos;mymaster&apos;22210:X 11 Mar 17:03:59.846 # +new-epoch 122210:X 11 Mar 17:03:59.846 # +try-failover master mymaster 10.30.6.184 3050OK127.0.0.1:26379&gt; 22210:X 11 Mar 17:03:59.890 # +vote-for-leader 8da81bbf7a87e42440046a8978b2fa69adc11fae 122210:X 11 Mar 17:03:59.890 # +elected-leader master mymaster 10.30.6.184 305022210:X 11 Mar 17:03:59.890 # +failover-state-select-slave master mymaster 10.30.6.184 305022210:X 11 Mar 17:03:59.973 # +selected-slave slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:03:59.973 * +failover-state-send-slaveof-noone slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:00.031 * +failover-state-wait-promotion slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:00.901 # +promoted-slave slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:00.901 # +failover-state-reconf-slaves master mymaster 10.30.6.184 305022210:X 11 Mar 17:04:00.981 * +slave-reconf-sent slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:01.947 * +slave-reconf-inprog slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:01.947 * +slave-reconf-done slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.184 305022210:X 11 Mar 17:04:02.024 # +failover-end master mymaster 10.30.6.184 305022210:X 11 Mar 17:04:02.024 # +switch-master mymaster 10.30.6.184 3050 10.30.6.183 305022210:X 11 Mar 17:04:02.024 * +slave slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 305022210:X 11 Mar 17:04:02.024 * +slave slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050127.0.0.1:26379&gt; sentinel get-master-addr-by-name mymaster1) &quot;10.30.6.183&quot;2) &quot;3050&quot; 可以看出来新的主，原来主变成新库的从库: 1234567891011121314151617181920212223242526272811826:M 11 Mar 17:04:00.032 # Connection with slave 10.30.6.183:3050 lost.11826:M 11 Mar 17:04:00.982 # Connection with slave 10.30.6.217:3050 lost.11826:S 11 Mar 17:04:11.079 * SLAVE OF 10.30.6.183:3050 enabled (user request from &apos;id=23 addr=10.30.6.217:35942 fd=9 name=sentinel-86aefa15-cmd age=10 idle=0 flags=x db=0 sub=0psub=0 multi=3 qbuf=0 qbuf-free=32768 obl=36 oll=0 omem=0 events=rw cmd=exec&apos;)11826:S 11 Mar 17:04:11.079 # CONFIG REWRITE executed with success.11826:S 11 Mar 17:04:11.602 * Connecting to MASTER 10.30.6.183:305011826:S 11 Mar 17:04:11.602 * MASTER &lt;-&gt; SLAVE sync started11826:S 11 Mar 17:04:11.602 * Non blocking connect for SYNC fired the event.11826:S 11 Mar 17:04:11.603 * Master replied to PING, replication can continue...11826:S 11 Mar 17:04:11.603 * Partial resynchronization not possible (no cached master)11826:S 11 Mar 17:04:11.605 * Full resync from master: 390beeec7d4ebfd0d4c0317eed3e97e498f4d9fd:35720011826:S 11 Mar 17:04:11.683 * MASTER &lt;-&gt; SLAVE sync: receiving 55 bytes from master11826:S 11 Mar 17:04:11.683 * MASTER &lt;-&gt; SLAVE sync: Flushing old data11826:S 11 Mar 17:04:11.683 * MASTER &lt;-&gt; SLAVE sync: Loading DB in memory11826:S 11 Mar 17:04:11.684 * MASTER &lt;-&gt; SLAVE sync: Finished with success11826:S 11 Mar 17:04:11.684 * Background append only file rewriting started by pid 2719111826:S 11 Mar 17:04:11.712 * AOF rewrite child asks to stop sending diffs.27191:C 11 Mar 17:04:11.712 * Parent agreed to stop sending diffs. Finalizing AOF...27191:C 11 Mar 17:04:11.712 * Concatenating 0.00 MB of AOF diff received from parent.27191:C 11 Mar 17:04:11.712 * SYNC append only file rewrite performed27191:C 11 Mar 17:04:11.712 * AOF rewrite: 0 MB of memory used by copy-on-write11826:S 11 Mar 17:04:11.802 * Background AOF rewrite terminated with success11826:S 11 Mar 17:04:11.802 * Residual parent diff successfully flushed to the rewritten AOF (0.00 MB)11826:S 11 Mar 17:04:11.802 * Background AOF rewrite finished successfully11826:S 11 Mar 17:16:59.969 * SLAVE OF would result into synchronization with the master we are already connected with. No operation performed.11826:M 11 Mar 17:17:16.301 # Connection with master lost.11826:M 11 Mar 17:17:16.301 * Caching the disconnected master state.11826:M 11 Mar 17:17:16.301 * Discarding previously cached master state. 2.5 订阅哨兵的消息通过接受sentinel发送的通知:当执行故障转移操作，或者某个被监视的实例被判断为主观下线或者客观下线时，Sentinel就会发送想要的信息。一个频道能够接收和这个名字相同的事件。通过执行PUBSCRIBE *命令接收所有事件信息。例如: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848510.30.6.184:26379&gt; PSUBSCRIBE *Reading messages... (press Ctrl-C to quit)1) &quot;psubscribe&quot;2) &quot;*&quot;3) (integer) 11) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+new-epoch&quot;4) &quot;2&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+try-failover&quot;4) &quot;master mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+vote-for-leader&quot;4) &quot;8da81bbf7a87e42440046a8978b2fa69adc11fae 2&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+elected-leader&quot;4) &quot;master mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+failover-state-select-slave&quot;4) &quot;master mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+selected-slave&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+failover-state-send-slaveof-noone&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+failover-state-wait-promotion&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;-role-change&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050 new reported role is master&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+promoted-slave&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+failover-state-reconf-slaves&quot;4) &quot;master mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave-reconf-sent&quot;4) &quot;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave-reconf-inprog&quot;4) &quot;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave-reconf-done&quot;4) &quot;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+failover-end&quot;4) &quot;master mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+switch-master&quot;4) &quot;mymaster 10.30.6.183 3050 10.30.6.184 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave&quot;4) &quot;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.184 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave&quot;4) &quot;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;-role-change&quot;4) &quot;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 3050 new reported role is master&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+role-change&quot;4) &quot;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 3050 new reported role is slave&quot; 从订阅的信息可以看出，故障检测、vote、以及修改其他从库同步。 2.6 模拟故障，手动kill主库的进程从订阅的信息中可以看到+sdown的信息。 1234567891011121314151617181920212223242526272829303132333435361) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+sdown&quot;4) &quot;master mymaster 10.30.6.184 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+new-epoch&quot;4) &quot;3&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+vote-for-leader&quot;4) &quot;86aefa154fe695f9e0ea56312e01a14c24e79129 3&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+odown&quot;4) &quot;master mymaster 10.30.6.184 3050 #quorum 3/2&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;-role-change&quot;4) &quot;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.184 3050 new reported role is master&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+config-update-from&quot;4) &quot;sentinel 10.30.6.217:26379 10.30.6.217 26379 @ mymaster 10.30.6.184 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+switch-master&quot;4) &quot;mymaster 10.30.6.184 3050 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave&quot;4) &quot;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&quot;1) &quot;pmessage&quot;2) &quot;*&quot;3) &quot;+slave&quot;4) &quot;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&quot; 当将老主库的实例启动起来之后，自动同步新主库。 SDOWN 主观下线如果服务器在给定的毫秒数之内，没有返回Sentinel发送的PING命令回复或者返回一个错误，那么Sentinel将这个服务器标记为主观下线(SDOWN)。 ODOWN 客观下线只有一个Sentinel将服务器标记为主观下线并不一定会引起服务器的自动故障迁移：只有在足够数量的Sentinel都将一个服务器标记为主观下线之后，服务器才会被标记为客观下线（ODOWN），这时自动故障迁移才会执行。 将服务器标记为客观下线所需的Sentinel数量由对主服务器的配置决定。 1sentinel monitor mymaster 10.30.6.184 3050 2 2.7 Sentinel客户端如果要做到应用程序对Redis的failover透明，客户端需要监控sentinel的平道信息，并自动连接新的主节点。 这里就需要整合sentinel的redis driver。 2.8 故障通知以及配置修改123456789101112sentinel notification-script mymaster /var/redis/notify.sh Call the specified notification script for any sentinel event that is generated in the WARNING level (for instance -sdown, -odown, and so forth). This script should notify the system administrator via email, SMS, or any other messaging system, that there is something wrong with the monitored Redis systems.sentinel client-reconfig-script mymaster /var/redis/reconfig.sh When the master changed because of a failover a script can be called in order to perform application-specific tasks to notify the clients that the configuration has changed and the master is at a different address. 2.9 哨兵切换过程一次故障转移操作步骤: 发下主服务器已经进入客观下线状态 对我们的当前纪元进行自增，并尝试在这个纪元中当选 如果当选失败，那么在设定的故障迁移超时时间的两倍之后，重新尝试当选。如果当选成功，那么执行以下步骤 选出一个从服务器，并将它升级为主服务器 向被选中的从服务器发送SLAVEOF NO ONE命令，让它转变为主服务器 通过发布与订阅功能，将更新后的配置传播给所有其他Sentinel，其他Sentinel队它们自己的配置进行更新 向已下线主服务器的从服务器发送SLAVEOF命令，让它们去复制新的主服务器+当所有从服务器都已经开始复制新的主服务器时，领头的Sentinel终止这次故障迁移操作。 2.10 后续处理什么时候知道从库已经全部同步完成？？ 通过python的订阅信息： 12345678&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;psubscribe&apos;, &apos;channel&apos;: &apos;*&apos;, &apos;data&apos;: 1L&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+new-epoch&apos;, &apos;data&apos;: &apos;9&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+config-update-from&apos;, &apos;data&apos;: &apos;sentinel 10.30.6.217:26379 10.30.6.217 26379 @ mymaster 10.30.6.217 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+switch-master&apos;, &apos;data&apos;: &apos;mymaster 10.30.6.217 3050 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;-role-change&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050 new reported role is master&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+role-change&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050 new reported role is slave&apos;&#125; 123456789101112131415161718192021&#123;&apos;pattern&apos;: None, &apos;type&apos;: &apos;psubscribe&apos;, &apos;channel&apos;: &apos;*&apos;, &apos;data&apos;: 1L&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+new-epoch&apos;, &apos;data&apos;: &apos;8&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+try-failover&apos;, &apos;data&apos;: &apos;master mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+vote-for-leader&apos;, &apos;data&apos;: &apos;558204b27aada22f980284b9447fa34c30ea2fa0 8&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+elected-leader&apos;, &apos;data&apos;: &apos;master mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+failover-state-select-slave&apos;, &apos;data&apos;: &apos;master mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+selected-slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+failover-state-send-slaveof-noone&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+failover-state-wait-promotion&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;-role-change&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050 new reported role is master&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+promoted-slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.217:3050 10.30.6.217 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+failover-state-reconf-slaves&apos;, &apos;data&apos;: &apos;master mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave-reconf-sent&apos;, &apos;data&apos;: &apos;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave-reconf-inprog&apos;, &apos;data&apos;: &apos;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave-reconf-done&apos;, &apos;data&apos;: &apos;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+failover-end&apos;, &apos;data&apos;: &apos;master mymaster 10.30.6.183 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+switch-master&apos;, &apos;data&apos;: &apos;mymaster 10.30.6.183 3050 10.30.6.217 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.184:3050 10.30.6.184 3050 @ mymaster 10.30.6.217 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+slave&apos;, &apos;data&apos;: &apos;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.217 3050&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;-role-change&apos;, &apos;data&apos;: &apos;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.217 3050 new reported role is master&apos;&#125;&#123;&apos;pattern&apos;: &apos;*&apos;, &apos;type&apos;: &apos;pmessage&apos;, &apos;channel&apos;: &apos;+role-change&apos;, &apos;data&apos;: &apos;slave 10.30.6.183:3050 10.30.6.183 3050 @ mymaster 10.30.6.217 3050 new reported role is slave&apos;&#125; 2.11 问题1-failover-abort-slave-timeout master mytest 10.30.11.225 8379 http://grokbase.com/t/gg/redis-db/147hea9vmm/redis-sentinel-manual-failover-hangs-on-failover-state-wait-promotionhttps://github.com/antirez/redis/pull/2097 原因在于修改对于config命令进行重命名操作了。 https://github.com/jipperinbham/redis/blob/sentinel-rename-command-3.0/sentinel.conf 添加对rename操作支持(支持config以及slaveof 的patch)一共存在两个分支，支持全局rename以及按照cluster的rename配置https://github.com/antirez/redis/pull/2068/commits/78b5be6833d627de96136cc41896b7d01bceaaed 去哪儿使用的方式是使用patch的方式禁用高危命令，这些高危名利只对哨兵机器开放。 脚本调用超时 12345[19809] 22 Mar 18:16:44.906 # +switch-master myredis 10.30.7.211 25379 10.30.7.212 25379[19809] 22 Mar 18:16:44.906 * +slave slave 10.30.7.213:25379 10.30.7.213 25379 @ myredis 10.30.7.212 25379[19809] 22 Mar 18:16:44.909 * +slave slave 10.30.7.211:25379 10.30.7.211 25379 @ myredis 10.30.7.212 25379[19809] 22 Mar 18:17:26.937 # -script-timeout /home/op/sentinel/reconfig.py 24081[19809] 22 Mar 18:18:57.183 # -script-timeout /home/op/sentinel/reconfig.py 24283 单个从库出现问题之后如何处理？？ 订阅消息的地方如何处理？？ 3、参考资料 http://debugo.com/redis-sentinel/]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GreenPlum安装]]></title>
    <url>%2F2016-03-08-greenpluman-zhuang%2F</url>
    <content type="text"><![CDATA[1、安装遇到的错误信息Failed to insert port=40000 解决方案：http://nessfishl11.blog.51cto.com/1640535/1640972 123主要原因是它是用ed编辑器（很古老的linux编辑器）来操作文件的，需要先安装才行ed安装包http://rpmfind.net/linux/rpm2html/search.php?query=edrpm -ivh ed-1.1-3.3.el6.x86_64.rpm 2、安装参考的资料http://my.oschina.net/Kenyon/blog/487572http://www.cnblogs.com/dap570/p/greenplum_4node_install.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[yum问题处理]]></title>
    <url>%2F2016-03-03-yumwen-ti-chu-li%2F</url>
    <content type="text"><![CDATA[1. yum安装失败处理123http://packages.cn-north-1.amazonaws.com.cn/2015.09/main/201509419456/x86_64/amzn-main/readline-devel-6.2-9.14.amzn1.x86_64.rpm?instance_id=i-91da0fa9&amp;region=cn-north-1: [Errno 14] PYCURL ERROR 22 - &quot;The requested URL returned error: 403 Forbidden&quot;Trying other mirror.http://packages.cn-north-1.amazonaws.com.cn/2015.09/main/201509419456/x86_64/amzn-main/readline-devel-6.2-9.14.amzn1.x86_64.rpm?instance_id=i-91da0fa9&amp;region=cn-north-1: [Errno 14] PYCURL ERROR 22 - &quot;The requested URL returned error: 403 Forbidden&quot; 处理方案: 1yum clean all]]></content>
  </entry>
  <entry>
    <title><![CDATA[DNS 相关]]></title>
    <url>%2F2016-02-16-dns-apixiu-gai%2F</url>
    <content type="text"><![CDATA[1、使用dnspython进行DNS的修改API封装遇到的各种问题使用dnspython模块进行DNS的修改，DNS的server搭建方式是使用Bind。 12345678910111213141516171819202122232425 !/usr/bin/env python -*-coding:utf8 -*-import sysimport dns.updateimport dns.queryimport dns.tsigkeyringimport dns.rdatatypeimport tracebackkeyring = dns.tsigkeyring.from_text(&#123;'testkey' : 'yr8lRAyVpMNOrjd3BsKBlQ=='&#125;)update = dns.update.Update('mysql.internal.test.com', keyring=keyring) update.replace('s4000i', 60, 'A', '10.30.21.111')update.delete('s4000i','A', '10.30.21.111')try:response = dns.query.tcp(update, '10.30.8.227', timeout=10)print responseexcept Exception,e:traceback.print_exc() 注意点： keyname需要和named.conf配置文件中对应。 Update的参数是Domain update.replace第一个参数是主机名 问题 Key名称错误 named-denied.log日志文件 1216-Feb-2016 15:50:38.433 security: error: client 10.30.6.49#42571:request has invalid signature: TSIG keyname: tsig verify failure (BADKEY) 1234567891011121314Traceback (most recent call last):File &quot;dns_test.py&quot;, line 22, in &lt;module&gt;response = dns.query.tcp(update, &apos;10.30.8.227&apos;, timeout=10)File &quot;/usr/local/lib/python2.6/site-packages/dns/query.py&quot;, line 323, in tcpone_rr_per_rrset=one_rr_per_rrset)File &quot;/usr/local/lib/python2.6/site-packages/dns/message.py&quot;, line 790, in from_wirereader.read()File &quot;/usr/local/lib/python2.6/site-packages/dns/message.py&quot;, line 731, in readself._get_section(self.message.additional, adcount)File &quot;/usr/local/lib/python2.6/site-packages/dns/message.py&quot;, line 683, in _get_sectionself.message.first)File &quot;/usr/local/lib/python2.6/site-packages/dns/tsig.py&quot;, line 163, in validateraise PeerBadKeyPeerBadKey 原因在于Keyname指定不对。 udp以及tcp的code状态为REFUSED 123456789id 41185opcode UPDATErcode REFUSEDflags QR RA;ZONEmysql.internal.test.com. IN SOA;PREREQ;UPDATE;ADDITIONAL 原因在于allow-update的设置 12345zone &quot;mysql.internal.test.com&quot; IN &#123;type master;file &quot;mysql.internal.test.com.zone&quot;;allow-update &#123; key testkey; &#125;;&#125;; journal open failed: unexpected errorr 日志文件的错误 12345616-Feb-2016 16:11:04.313 update: info: client 10.30.6.49#26678:updating zone &apos;mysql.internal.test.com/IN&apos;: deleting rrset at &apos;s4000i.mysql.internal.test.com&apos; A16-Feb-2016 16:11:04.313 update: info: client 10.30.6.49#26678:updating zone &apos;mysql.internal.test.com/IN&apos;: adding an RR at &apos;s4000i.mysql.internal.test.com&apos; A16-Feb-2016 16:11:04.313 update: info: client 10.30.6.49#26678:updating zone &apos;mysql.internal.test.com/IN&apos;: error: journal open failed: unexpected error 原因在于权限问题，修改/var/named/chroot/var/named目录权限为named.named。 Demo参考代码https://github.com/pexip/os-dnspython 2、DNS Server搭建参考：http://blog.csdn.net/chen_jp/article/details/7855079https://www.digitalocean.com/community/tutorials/how-to-install-the-bind-dns-server-on-centos-6 主从模式https://www.digitalocean.com/community/tutorials/how-to-configure-bind-as-a-private-network-dns-server-on-centos-7 DNS的server进程 1/usr/sbin/named -u named -4 -t /var/named/chroot DNS本地缓存 我们使用Dnsmasq完成机器本地的缓存，DNS的TTL时间设置为60秒。 http://www.freeoa.net/osuport/servap/dnsmasq-use-intro-refer_2480.html]]></content>
      <categories>
        <category>DNS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GDB多进程调试]]></title>
    <url>%2F2016-02-16-gdbduo-jin-cheng-diao-shi%2F</url>
    <content type="text"><![CDATA[1、如何进行多进程调试1.1 代码123456789101112131415161718192021222324252627282930313233343536371 #include &lt;stdio.h&gt;2 #include &lt;stdlib.h&gt;3 #include &lt;unistd.h&gt;45 int main(void)6 &#123;7 pid_t pid;8 int status;9 int a;10 int b;1112 pid=fork();1314 if (pid &lt; 0)&#123;15 printf("fork error");16 exit(1);17 &#125;else if(pid == 0)&#123;18 //child19 printf("in child\n");20 fflush(stdout);21 sleep(100);22 a = 5;23 b = 10;24 printf("sum=%d\n",a+b);25 fflush(stdout);2627 &#125;else&#123;28 //parent29 printf("in parent\n");30 fflush(stdout);31 if(waitpid(pid, &amp;status,0) &lt; 0)&#123;32 printf("failed to wait");33 exit(1);34 &#125;35 &#125;36 exit(0);37 &#125; 对应的makefile 123456test:test.cgcc -g -c test.cgcc -o test test.oclean:rm -rf testrm -rf *.o 默认设置下，在调试多进程时GDB只会调试主进程，但是GDB(&gt;V7.0)持多进程的分别以及同时调试，换句话说，GDB可以同时调试多个程序。只需要设置follow-fork-mode(默认值：parent)和detach-on-fork（默认值：on）即可。 1234567891011(gdb) help set follow-fork-modeSet debugger response to a program call of fork or vfork.A fork or vfork creates a new process. follow-fork-mode can be:parent - the original process is debugged after a forkchild - the new process is debugged after a forkThe unfollowed process will continue to run.By default, the debugger will follow the parent process.(gdb) help show detach-on-forkShow whether gdb will detach the child of a fork.Tells gdb whether to detach the child of a fork. 12345follow-fork-mode detach-on-fork 说明parent on 只调试主进程（GDB默认）child on 只调试子进程parent off 同时调试两个进程，gdb跟主进程，子进程block在fork位置child off 同时调试两个进程，gdb跟子进程，主进程block在fork位置 1.2 GDB调试123456789101112131415161718192021222324252627(gdb) set detach-on-fork off(gdb) show detach-on-forkWhether gdb will detach the child of a fork is off.(gdb) lwarning: Source file is more recent than executable.3 #include &lt;unistd.h&gt;45 int main(void)6 &#123;7 pid_t pid;8 int status;9 int a;10 int b;1112 pid=fork();(gdb) b 14Breakpoint 1 at 0x400700: file test.c, line 14.(gdb) rStarting program: /home/guosong/opdir/20160216/test[New process 7638]Missing separate debuginfos, use: debuginfo-install glibc-2.17-55.93.amzn1.x86_64Breakpoint 1, main () at test.c:1414 if (pid &lt; 0)&#123;Missing separate debuginfos, use: debuginfo-install glibc-2.17-55.93.amzn1.x86_64(gdb) p pid$1 = 7638 默认是在parent进程中。 切换到子进程 123456789101112131415161718192021(gdb) info inferiorsNum Description Executable2 process 9388 /home/guosong/opdir/20160216/test* 1 process 9356 /home/guosong/opdir/20160216/test(gdb) inferior 2[Switching to inferior 2 [process 9388] (/home/guosong/opdir/20160216/test)][Switching to thread 2 (process 9388)] 0 0x00007ffff7aecc7c in fork () from /lib64/libc.so.6Breakpoint 1, main () at test.c:14warning: Source file is more recent than executable.14 if (pid &lt; 0)&#123;(gdb) n17 &#125;else if(pid == 0)&#123;(gdb) n19 printf(&quot;in child\n&quot;);(gdb) info inferiorsNum Description Executable* 2 process 9388 /home/guosong/opdir/20160216/test1 process 9356 /home/guosong/opdir/20160216/test 再切换回去主进程 12345(gdb) inferior 1[Switching to inferior 1 [process 9356] (/home/guosong/opdir/20160216/test)][Switching to thread 1 (process 9356)] 0 main () at test.c:3333 exit(1); 2、参考资料 http://blog.csdn.net/pbymw8iwm/article/details/7876797]]></content>
      <categories>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO多路复用]]></title>
    <url>%2F2016-01-28-ioduo-lu-fu-yong%2F</url>
    <content type="text"><![CDATA[参考资料Linux IO模式及 select、poll、epoll详解 select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。]]></content>
      <categories>
        <category>Unix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis相关链接]]></title>
    <url>%2F2016-01-15-redisxiang-guan-lian-jie%2F</url>
    <content type="text"><![CDATA[Redis AOF相关 AOF Replay AOF 代码详解]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql大小参数设置]]></title>
    <url>%2F2016-01-05-mysqlda-xiao-can-shu-she-zhi%2F</url>
    <content type="text"><![CDATA[MySQL5.5及其以下在同步的时候对lower_case_table_names有比较严格限制&gt;It is strongly recommended that you always use the same setting for the lower_case_table_names system variable on both master and slave. In particular, when a case-sensitive file system is used, setting this variable to 1 on the slave, but to a different value on the master, can cause two types of problems: Names of databases are not converted to lowercase; in addition, when using row-based replication names of tables are also not converted. Either of these problems can cause replication to fail. This is a known issue, which is fixed in MySQL 5.6. 否则会出现同步错误：&gt;Last_SQL_Errno: 1146Last_SQL_Error: Error executing row event: ‘Table’ 10futu.commentAZXI’ doesn’t exist http://dev.mysql.com/doc/refman/5.5/en/replication-features-variables.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pt-online-schema-change使用方法]]></title>
    <url>%2F2015-12-29-pt-online-schema-changeshi-yong-fang-fa%2F</url>
    <content type="text"><![CDATA[0、前言经常使用pt-osc，需要哪些参数以及如何设置，这里给出个demo。 1、封装的osc脚本12345678910111213141516171819202122232425262728293031323334 !/bin/shfunction run_osc()&#123;MAXSTER_IP="xxx"PORT=xxxDB="sxxx"TB="cc_oxxx"SQL="change order_type order_type tinyint nxxxxMAX_LAG=10USER="xxx"PASS="xxx"CHUNK_SIZE=200osc_file_log="$&#123;DB&#125;_$&#123;TB&#125;_osc.log"./pt-online-schema-change --host=$&#123;MAXSTER_IP&#125; \--port=$&#123;PORT&#125; --user=$&#123;USER&#125; --password=$&#123;PASS&#125; --charset=utf8 \--alter="$&#123;SQL&#125;" --max-lag=$&#123;MAX_LAG&#125; \--recursion-method=dsn=D=test,t=dsns \--no-check-replication-filters \--print --progress=time,1 --statistics \--chunk-size=$&#123;CHUNK_SIZE&#125; --check-interval 5 \--max-load Threads_running=140,Threads_connected=600 \--critical-load Threads_running=140,Threads_connected=800\--set-vars="binlog_format=row" \D=$&#123;DB&#125;,t=$&#123;TB&#125; --execute &gt; $&#123;osc_file_log&#125; 2&gt;&amp;1&#125;run_osc 2、 1366错误遇到1366错误，修改osc源码进行或护额 12345 Completely ignore these error codes.my %ignore_code = ( add by guosong1366 =&gt; 1,)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql全文索引]]></title>
    <url>%2F2015-12-23-mysqlquan-wen-suo-yin%2F</url>
    <content type="text"><![CDATA[0、全文索引说明全文索引使用情况，文件组织格式、使用方式等。 1、全文索引1234567891011FTS_000000000000004b_00000000000000a9_INDEX_1.ibdFTS_000000000000004b_00000000000000a9_INDEX_2.ibdFTS_000000000000004b_00000000000000a9_INDEX_3.ibdFTS_000000000000004b_00000000000000a9_INDEX_4.ibdFTS_000000000000004b_00000000000000a9_INDEX_5.ibdFTS_000000000000004b_00000000000000a9_INDEX_6.ibdFTS_000000000000004b_BEING_DELETED_CACHE.ibdFTS_000000000000004b_BEING_DELETED.ibdFTS_000000000000004b_CONFIG.ibdFTS_000000000000004b_DELETED_CACHE.ibdFTS_000000000000004b_DELETED.ibd 之前没有对全文索引研究过，一开始对这个ibd文件感到奇怪，原来使用到全文索引。 https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql性能测试]]></title>
    <url>%2F2015-12-21-mysqlxing-neng-ce-shi%2F</url>
    <content type="text"><![CDATA[0、前言介绍sysbench相关的使用方法。 1、sysbench生成数据12345sysbench --test=/home/guosong/source/sysbench/sysbench/tests/db/oltp.lua--mysql-host=10.30.21.179 --mysql-port=4000--mysql-user=superdba --mysql-password=nUSP9RAOXXqTrNq50rRw--mysql-table-engine=innodb --oltp-table-size=20000000--max-time=180 --num-threads=30 --max-requests=0 prepare 直接使用otlp报错： 123[guosong@dev-00 db]$ sysbench --test=oltp helpsysbench 0.5: multi-threaded system evaluation benchmarkPANIC: unprotected error in call to Lua API (cannot open oltp: No such file or directory) 原因是这个0.5版本的特性，与0.4版本不同。 122 000 0000 行数据 4.8G2 0000 0000 行数据 48G 2、运行12345678910111213sysbench --num-threads=256 --test=/home/guosong/source/sysbench/sysbench/tests/db/oltp.lua--oltp-dist-type=uniform --oltp-table-name=sbtest_1--max-requests=0 --max-time=720--mysql-host=shangcheng-online-s1-d0.db --mysql-port=3306--mysql-user=dba --mysql-password=xxxxxx--mysql-db=sbtest --mysql-table-engine=INNODB--db-driver=mysql --oltp-point-selects=1--oltp-simple-ranges=0--oltp-sum-ranges=0--oltp-order-ranges=0--oltp-distinct-ranges=0--oltp-skip-trx=on--oltp-read-only=on run 参数 含义 默认值 –oltp-simple-ranges Range size for range queries 100 –oltp-sum-ranges Number of SUM range queries in a single transaction 1 –oltp-order-ranges Number of ORDER range queries in a single transaction 1 –oltp-distinct-ranges Number of DISTINCT range queries in a single 1 transaction 1 –oltp-skip-trx Omit BEGIN/COMMIT statements, i.e. run the same queries as the test would normally run but without off using transactions. off –oltp-read-only Read-only mode. No UPDATE, DELETE or INSERT queries off will be performed. off 3、参考资料 http://wiki.mikejung.biz/Benchmarking]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql_gtid实践]]></title>
    <url>%2F2015-12-09-mysql-gtidshi-jian%2F</url>
    <content type="text"><![CDATA[0、前言介绍GTID限制、在同步中断情况下处理方式、使用xtrabackup的方式等。 1、GTID限制https://dev.mysql.com/doc/refman/5.6/en/replication-gtids-restrictions.html 限制： CREATE TABLE … SELECT statements Temporary tables Preventing execution of unsupported statements. sql_slave_skip_counter 不在支持 GTID mode and mysqldump GTID mode and mysql_upgrade 2、在GTID下pt-slave-restart如何使用？对于操作用户的权限需求必须有SUPER privilege(s)权限。 2.1、手动处理的方式：http://imysql.cn/tag/gtid 12345stop slave;set gtid_next='cc5b5f77-91a6-11e5-834b-02b39697b809:4500';begin;commit;set gtid_next="AUTOMATIC";start slave; 2.2、pt-slave-restart使用方法https://www.percona.com/doc/percona-toolkit/2.2/pt-slave-restart.html &gt;GLOBAL TRANSACTION IDSAs of Percona Toolkit 2.2.8, pt-slave-restart supports Global Transaction IDs introduced in MySQL 5.6.5. It’s important to keep in mind that: pt-slave-restart will not skip transactions when multiple replication threads are being used (slave_parallel_workers &gt; 0). pt-slave-restart does not know what the GTID event is of the failed transaction of a specific slave thread.The default behavior is to skip the next transaction from the slave’s master. Writes can originate on different servers, each with their own UUID.See –master-uuid. 1pt-slave-restart -uroot -pxxx -S /home/guosong/mysql5627/tmp/mysql5627.sock 通过PTDEBUG=1开启pt-slave-restart的日志，修改原有代码打印GTID_NEXT dev-00上我的pt-slave-restart，已经修改，不需要使用用户名和密码，只需要host以及port即可。RDS上从库出现错误需要跳过的处理方式 1CALL mysql.rds_skip_repl_error; RDS kill连接 1call rds_kill(id); dev-00上我的pt-slave-restart，已经修改，不需要使用用户名和密码，只需要host以及port即可。1234&gt;&gt;&gt;&gt;&gt;&gt;&gt; 42d27cbafc625665f68177fd142c0eec4f564361[guosong@dev-00 pt-tools]$ ./pt-slave-restart -h 10.30.7.220 -P 56272015-12-09T16:26:41 P=5627,h=10.30.7.220 relay-bin.000012 448 1062 pt_slave_restart:5108 20978 SET GTID_NEXT='cc5b5f77-91a6-11e5-834b-02b39697b809:38' 3、在GTID下xtrbackup如何备份？123innobackupex --defaults-file=/data1/mysql7500/etc/my7500.cnf --user=root --password=xxx /data1/backup/ --socket=/data1/mysql7500/tmp/mysql7500.sockinnobackupex --defaults-file=/data1/mysql7500/etc/my7500.cnf --user=root --password=xx --apply-log /data1/backup/mysql7500 查看xtrabackup_binlog_info 文件多一列： 1mysql-bin.000010 334810306 542ef021-9a64-11e5-bc49-025d3d22c211:1-24368 参考文档：https://www.percona.com/blog/2013/05/09/how-to-create-a-new-or-repair-a-broken-gtid-based-slave-with-percona-xtrabackup/ 123slave1 &gt; SET GLOBAL gtid_purged="c777888a-b6df-11e2-a604-080027635ef5:1-4";slave1 &gt; CHANGE MASTER TO MASTER_HOST="10.0.1.1",master_user="msandbox", master_password="msandbox", MASTER_AUTO_POSITION = 1;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux IO相关-iotop&pidstat]]></title>
    <url>%2F2015-12-07-linux-ioxiang-guan-iotop%2F</url>
    <content type="text"><![CDATA[0、前言上一篇介绍iostat相关使用说明，这里介绍iotop以及pidstat，发现使用最多io的进程以及线程。和之前写的IO统计，那里使用dmesg -c命令，这次是python写的iotop工具。 &gt;iotop watches I/O usage information output by the Linux kernel (requires 2.6.20 or later) and displays a table of current I/O usage by processes or threads on the system. 可以看到进程以及线程的io情况。 1、iotop1.1、基本使用1iotop 1.2、-o参数 -o, –onlyOnly show processes or threads actually doing I/O, instead of showing all processes or threads.This can be dynamically toggled by pressing o. 只显示有IO操作的进程和线程，而不是所有的。通过按o键可以从iotop切换到这里，也可以显示添加。 &gt;-p PID, –pid=PIDA list of processes/threads to monitor (all by default). 根据pid以及thread_id显示对应的信息。 12345678[root@mysql-db-009 ec2-user]# pstree my4000 -pmysqld(3819)─┬─&#123;mysqld&#125;(3821)├─&#123;mysqld&#125;(3822)├─&#123;mysqld&#125;(3823).......├─&#123;mysqld&#125;(3852)├─&#123;mysqld&#125;(3853)└─&#123;mysqld&#125;(3854) 其他的功能参照man iotop功能。 2、pidstat2.1、基本使用2.2、针对单个进程的io1234567891011121314151617[root@mysql-db-009 ec2-user]# pidstat -d -p 3819 1Linux 4.1.7-15.23.amzn1.x86_64 (mysql-db-009) 12/07/2015 _x86_64_ (8 CPU)11:30:33 AM PID kB_rd/s kB_wr/s kB_ccwr/s Command11:30:34 AM 3819 536.00 9316.00 0.00 mysqld11:30:35 AM 3819 752.00 14140.00 0.00 mysqld11:30:36 AM 3819 628.00 3556.00 0.00 mysqld11:30:37 AM 3819 724.00 6268.00 0.00 mysqld11:30:38 AM 3819 1348.00 8552.00 0.00 mysqld11:30:39 AM 3819 500.00 15776.00 0.00 mysqld11:30:40 AM 3819 720.00 7180.00 0.00 mysqld11:30:41 AM 3819 696.00 15932.00 0.00 mysqld11:30:42 AM 3819 1112.00 8064.00 0.00 mysqld11:30:43 AM 3819 824.00 16348.00 0.00 mysqld11:30:44 AM 3819 740.00 6044.00 0.00 mysqld11:30:45 AM 3819 1704.00 2688.00 0.00 mysqld11:30:46 AM 3819 536.00 6892.00 0.00 mysqld 2.3、]]></content>
      <categories>
        <category>Linux Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux IO相关-iostat]]></title>
    <url>%2F2015-12-07-iostat%2F</url>
    <content type="text"><![CDATA[0、前言给出Linux各种IO相关的工具介绍，例如iostat、dstat、iotop、pidstat等 1、iostat1.1 基本使用这篇博客介绍的非常不错，推荐http://www.orczhou.com/index.php/2010/03/iostat-detail/ 1iostat -d -k 1 10 参数 -d 表示，显示设备（磁盘）使用状态；-k某些使用block为单位的列强制使用Kilobytes为单位；1 10表示，数据显示每隔1秒刷新一次，共显示10次。 123456789101112[root@mysql-db-009 ec2-user]# iostat -d -k 1 10Linux 4.1.7-15.23.amzn1.x86_64 (mysql-db-009) 12/07/2015 _x86_64_ (8 CPU)Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnxvda 1.47 21.85 1.19 76408 4156xvdc 0.12 0.48 0.00 1693 4xvdb 714.66 3094.85 6764.03 10824977 23658812Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnxvda 0.00 0.00 0.00 0 0xvdc 0.00 0.00 0.00 0 0xvdb 577.00 1268.00 6428.00 1268 6428 tps该设备每秒的传输次数。一次传输意味着一次IO，多个逻辑请求可能会被合并成一次IO请求。一次传输请求的大小是未知的。 Indicate the number of transfers per second that were issued to the device. A transfer is an I/O request to the device. Multiple logical requests can be combined into a single I/O request to the device. A transfer is of indeterminate size. kB_read/s: 每秒从设备（drive expressed）读取的数据量 kB_wrtn/s: 每秒从设备（drive expressed）写入的数据量 kB_read/s: 每秒读取的数据量总量 kB_wrtn/s: 每秒写入的数据量总量 &gt;kB_read/sIndicate the amount of data read from the device expressed in kilobytes per second.kB_wrtn/sIndicate the amount of data written to the device expressed in kilobytes per second.kB_readThe total number of kilobytes read.kB_wrtnThe total number of kilobytes written. 通过参数-m可以将KB转换为MB 1234567[root@mysql-db-009 ec2-user]# iostat -d -m 1 10Linux 4.1.7-15.23.amzn1.x86_64 (mysql-db-009) 12/07/2015 _x86_64_ (8 CPU)Device: tps MB_read/s MB_wrtn/s MB_read MB_wrtnxvda 1.26 0.02 0.00 77 4xvdc 0.10 0.00 0.00 1 0xvdb 705.84 2.70 7.04 11759 30646 1.2 -x参数使用-x参数可以获取更多统计信息。 1234567[root@mysql-db-009 ec2-user]# iostat -d -x -m 1 10Linux 4.1.7-15.23.amzn1.x86_64 (mysql-db-009) 12/07/2015 _x86_64_ (8 CPU)Device: rrqm/s wrqm/s r/s w/s rMB/s wMB/s avgrq-sz avgqu-sz await svctm %utilxvda 0.00 0.07 0.89 0.09 0.01 0.00 30.27 0.00 0.98 0.37 0.04xvdc 0.00 0.00 0.07 0.00 0.00 0.00 7.99 0.00 0.40 0.40 0.00xvdb 0.00 335.16 159.50 537.92 2.35 7.69 29.50 0.54 0.77 0.55 38.57 rrqm/s: 每秒这个设备相关的读取请求有多少被Merge了（当系统调用需要读取数据的时候，VFS将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge） wrqm/s: ：每秒这个设备相关的写入请求有多少被Merge了。 r/s 和 w/s 合起来就IOPS。 &gt;rrqm/sThe number of read requests merged per second that were queued to the device.&gt;wrqm/sThe number of write requests merged per second that were queued to the device. r/sThe number of read requests that were issued to the device per second. w/sThe number of write requests that were issued to the device per second. await： 每一个IO请求的处理的平均时间（单位是毫秒）。这里可以理解为IO的响应时间，一般地系统IO响应时间应该低于5ms，如果大于10ms就比较大了。 avgrq-sz： 块设备的平均大小。 avgqu-sz： IO队列大小。 svctm： 废弃。 %util:在统计时间内所有处理IO时间，除以总共统计时间。例如，如果统计间隔1秒，该设备有0.8秒在处理IO，而0.2秒闲置，那么该设备的%util = 0.8/1 = 80%，所以该参数暗示了设备的繁忙程度。一般地，如果该参数是100%表示设备已经接近满负荷运行了（当然如果是多磁盘，即使%util是100%，因为磁盘的并发能力，所以磁盘使用未必就到了瓶颈）。 avgrq-szThe average size (in sectors) of the requests that were issued to the device. avgqu-szThe average queue length of the requests that were issued to the device. svctmThe average service time (in milliseconds) for I/O requests that were issued to the device. Warning! Do not trust this field any more. This field will be removed in a future sysstat version. 1util = (r/s + w/s)*svctm/1000 util的数值不准确http://yoshinorimatsunobu.blogspot.jp/2009/07/iostat-rs-ws-svctm-util-on-linux.html]]></content>
      <categories>
        <category>Linux Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Glib Thread篇]]></title>
    <url>%2F2015-12-05-glib-threadpian%2F</url>
    <content type="text"><![CDATA[1、前言在mydumper以及myloader中使用到GLib库的功能，前面分析mydumper源码的时候，已经给出参数解析的demo以及mydumper实现过程。mysqldump以及mydumper最大的不同之处就mydumper是多线程的，效率更高。本文就是研究这个多线程是如何实现的，并给出相关demo进行源码的测试以及验证。 2、GLIB的多线程123456789101112131415161718192021222324252627282930313233343536373839 include &lt;glib.h&gt; define MAX_THREAD 3gpointer gthread_func(gpointer data)&#123;gint i, num;num = GPOINTER_TO_INT(data);for (i = 0; i &lt; MAX_THREAD - num; i++)g_printf("Thread No. %d, of %d\n", i, num);return 0;&#125;gint main(gint argc, gchar* argv[])&#123;GThread *my_thread[MAX_THREAD];gint i;g_printf("Create thread.\n");for ( i = 0; i &lt; MAX_THREAD; i++)&#123;my_thread[i] = g_thread_new(NULL, gthread_func,GINT_TO_POINTER(i));&#125;g_printf("End create thread.\n");for( i = 0; i &lt; MAX_THREAD; i++)&#123;g_thread_join(my_thread[i]);&#125;g_printf("End join thread.\n");return 0;&#125; 参照http://www.d3.dion.ne.jp/~fut_nis/Other/GLib_program_04.pdf进行实现，并对其中已经废弃的函数进行修改。 对应的makefile文件为： 123test:test.cgcc -Wdeprecated-declarations -g -c test.c -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include -lglib-2.0gcc -o test test.o -pthread -lgthread-2.0 -lglib-2.0 其中由于使用到gthread模块，因此需要单独添加。 3、任务多线程实现demoDemo的链接https://github.com/dolphinsboy/code_for_c/blob/master/glib/gthread_multi_job.c 主要包含三个函数 1234567# 处理队列中的任务process_queue# 添加任务add_jobmain 4、静态库编译123456789wget http://ftp.gnome.org/pub/gnome/sources/glib/2.22/glib-2.22.5.tar.gztar zxvf glib-2.22.5.tar.gzcd glib-2.22.5./configure --prefix=/usr/local/glib --enable-static --disable-shared CFLAGS="-static"make &amp;&amp; make install 说明： –prefix指定安装到目录，不要与系统中已安装的glib混淆。 –enable-static –disable-shared CFLAGS=”-static”使得编译出静态库.a文件。 重点 12345export PKG_CONFIG_PATH=/usr/local/glib/lib/pkgconfig:$PKG_CONFIG_PATHpkg-config --libs glib-2.0 gthread-2.0pkg-config --cflags glib-2.0 gthread-2.0 说明： 第一句使用是让pkg-config找到新编译的glib库及头文件，后两句是通过pkg-config分别获取头文件地址和库地址。 此外，也可将–prefix/lib/pkgconfig下的文件拷贝到/lib/pkgconfig下，让pkg-config自动搜索到，但会覆盖之前已安装在标准目录下的的glib的相关文件。]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Graphite]]></title>
    <url>%2F2015-11-10-graphite%2F</url>
    <content type="text"><![CDATA[1、Graphite安装主要是参考http://graphite.wikidot.com/installation，不过中间遇到很多问题，主要列出这些问题。 使用源码安装，安装AWS EC2上，python版本为2.6，话说在AWS上安装软件还是非常方便的，至少不应考虑被墙的问题。 Django版本：安装Django版本过高，而使用的python2.6版本，最终安装1.5.0版本 忘记执行check-dependencies.py进行环境检查了，中间装了一堆的python包 安装最新版没有manage.py脚本，在/opt/graphite/webapp/graphite目录下没有找到这个脚本，通过pip安装获取到 apache的配置问题，在apachep配置目录/etc/httpd/conf.d/下，单独创建一个graphite-vhost.conf，内容是从原始配置中拷贝过来，只修改VirtualHost，其他都没有修改： Django的错误： 12345678from django.contrib.contenttypes.fields import GenericForeignKeyImportError: No module named fields 修改源码：/usr/local/lib/python2.7/site-packages/django_tagging-0.4-py2.7.egg/tagging/models.py from django.contrib.contenttypes.fields import GenericForeignKeyfrom django.contrib.contenttypes.generic import GenericForeignKey 123&lt;VirtualHost *:9090&gt;ServerName 10.30.xx.xx:9090&lt;/VirtualHost&gt; 一开始发现访问不了，原来还需要在/etc/httpd/conf/httpd.conf 文件，添加一行Listen 9090才可以。 运行如下命令发现无法找到django-admin.py文件，处理方法是在~/.bashrc中设置PATH： 123./bin/run-graphite-devel-server.py --port=9000 /opt/graphite/export PATH=/usr/local/lib/python2.6/site-packages/django/bin:$PATH 配置过程中出现错误的话，可以多参照日志/opt/graphite/storage/log/webapp/error.log，这个路径在 2、Graphite入门介绍推荐如下DevOps实战：Graphite监控上手指南 3. Grafana 没有权限访问graphitehttp://docs.grafana.org/installation/installation/ 修改权限： 123Header set Access-Control-Allow-Origin "*"Header set Access-Control-Allow-Methods "GET, OPTIONS"Header set Access-Control-Allow-Headers "origin, authorization, accept" 更好解决方案参照上面的链接。 4. DEV-00 启动graphite-carbon 123[root@dev-00 graphite]# pwd/opt/graphite[root@dev-00 graphite]# ./bin/carbon-cache.py start 启动graphite-web 123[root@dev-00 graphite]# pwd/opt/graphite[root@dev-00 graphite]# ./bin/run-graphite-devel-server.py --port=9000 /opt/graphite/ 启动grafana 1[root@dev-00 dashboards]# service grafan-server restart grafana和MySQL结合 https://www.percona.com/blog/2016/02/29/graphing-mysql-performance-with-prometheus-and-grafana/https://github.com/percona/grafana-dashboards 5. Grafana和Metric对应关系1&#123;service&#125;.&#123;p_name&#125;.&#123;port&#125;.&#123;role&#125;.&#123;node_id&#125;.&#123;metric&#125; &#123;value&#125; &#123;timestamp&#125; 6. Graphite-web问题汇总 perSecond函数bug导致图片无法显示 https://github.com/graphite-project/graphite-web/pull/1626 这个问题的原因在于采集脚本出现问题，导致数据无法显示，准备使用tcollector进行改造(agent采集的方式进行)。 Grafana也是调用graphite的接口实现的，通过下面的graphite API接口可以看到问题所在: http://kan.culiu.org:9090/render/?width=1602&amp;height=745&amp;from=-15mins&amp;target=perSecond(mysql.shop.4000.m.rds.shangcheng-m1.com_select))]]></content>
      <categories>
        <category>Graphite</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis内存使用情况统计]]></title>
    <url>%2F2015-10-22-redisnei-cun-shi-yong-qing-kuang-tong-ji%2F</url>
    <content type="text"><![CDATA[redis rdb文件内存使用情况分析生成rdb文件通过bgsave命令生成rdb文件，如果存在rdb，则跳过此步 1redis-cli -h xxx -p xxx bgsave 分析rdb文件需安装rdb：点击此处连接redis-rdb-tools 1rdb -c memory /var/redis/6379/dump.rdb &gt; memory.csv 使用上面的工具进行分析，分析结果如下： 123456database,type,key,size_in_bytes,encoding,num_elements,len_largest_element0,set,&quot;uv_filter_151020_10005138312&quot;,1440523,hashtable,13975,320,set,&quot;uv_filter_151021_100117706&quot;,1360332,hashtable,13074,320,set,&quot;uv_filter_151020_1000329580&quot;,1284149,hashtable,12218,320,set,&quot;uv_filter_151020_100030831&quot;,1228394,hashtable,11591,320,set,&quot;uv_filter_151020_10007780250&quot;,1194260,hashtable,11208,32 基于第4列进行汇总。按照上面的例子，前缀都是相同的，故需要进行合并。线上的业务总共6个分片，每个rdb文件完后的结果为1G+，将这些文件上传到AWS S3上面。 使用map-reduce服务数据分析将如下程序（mapper.py、reducer.py、run.sh）放在hadoop服务器（data-dev-00） map程序，分析上面的csv文件，获取k-v。 mapper.py 123456789101112131415161718192021222324 coding:utf8import sysimport reif __name__ == "__main__": qps_dic = &#123;&#125; for line in sys.stdin: try: infs = line[:-1].split(',') _key = infs[2] _key = _key.replace("\"", '') _key = ''.join(_key.split(':')[0]) _key = '_'.join(_key.split('_')[:-1]) _key = re.sub(r"\d+","N", _key) _value = int(infs[3]) if _key not in qps_dic: qps_dic[_key] = 0 qps_dic[_key] += _value except Exception: pass for k,v in qps_dic.items(): print "%s\t%d"%(k,v) 处理点： 按照逗号分隔，对前缀进行处理，将数字类转换成特殊字符N 内部进行汇总，故构建一个字典统计 输出按照tab键分隔 reduce程序进行结果合并 reducer.py 123456789101112131415161718192021222324252627 coding:utf8import sysdef emit(_key, _value): print _key + "\t" + "\t".join(map(str,_value))if __name__ == "__main__": current_key = None current_vals = [] for line in sys.stdin: infs = line[:-1].split('\t',1) if len(infs) == 1: (_key,_value) = (infs[0],'0') else: (_key, _value) = infs if _key != current_key and current_key != None: emit(current_key, current_vals) current_vals = [] current_key = _key _values = map(float,_value.split('\t')) if len(current_vals) == 0: current_vals = _values else: current_vals = [x + y for x, y in zip(_values, current_vals)] if current_key != None: emit(current_key, current_vals) 通过hadoop的streaming进行分析: run.sh 1234567891011 !/bin/shexport JAVA_HOME=/usr/java/latest/home/hadoop/bin/hadoop jar /home/hadoop/contrib/streaming/hadoop-streaming.jar \-D mapred.reduce.tasks=5 \-D mapred.job.map.capacity=100 \-input s3://logs.culiu.org/redis_analysis/\ #s3 路径，这个可以自己上传路径修改-output s3://forall/yangyh/redis_analysis \ #s3 路径，分析后保存路径-mapper "python mapper.py" \-reducer "python reducer.py" \-file "mapper.py" \-file "reducer.py" \ 下载并分析结果1aws s3 cp s3://xx.xx ./ --recursive 分析完得到的结果是5个部分： (自己汇总即可) 1part-00000 part-00001 part-00002 part-00003 part-00004 _SUCCESS 得到memory排序结果1sort -rn -k2 part-0000*|awk &apos;&#123;print $1,$2/1024/1024,&quot;M&quot;&#125; 针对购物车的统计需求根据购物车里面的商品数目，按照100为步长给出如下统计： 1234567891011[ec2-user@dev-00 ~]$ aws s3 ls s3://forall/guosong/redis_analysis/users/2016-05-03 12:01:30 02016-05-03 12:03:28 627442 user_100_200.log2016-05-03 12:03:48 136347 user_200_300.log2016-05-03 12:03:55 50394 user_300_400.log2016-05-03 12:04:01 23317 user_400_500.log2016-05-03 12:04:07 12995 user_500_600.log2016-05-03 12:04:13 7649 user_600_700.log2016-05-03 12:04:19 4831 user_700_800.log2016-05-03 12:04:25 3305 user_800_900.log2016-05-03 12:04:43 2318 user_900_1000.log user_100_200是指购物车里面的商品数据超过100且小于200的 使用HIVE来进行操作构建userid的表：12345678910111213hive&gt; show create table temp_user_id;OKCREATE EXTERNAL TABLE `temp_user_id`(`user_id` bigint)ROW FORMAT DELIMITEDFIELDS TERMINATED BY '\t'LINES TERMINATED BY '\n'STORED AS INPUTFORMAT'org.apache.hadoop.mapred.TextInputFormat'OUTPUTFORMAT'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'LOCATION's3://XA:C....@forall/weihl/u/m'; 数据存放在S3上 构建userid和内存之间的映射表 1234567891011121314hive&gt; show create table temp_user_memory;OKCREATE EXTERNAL TABLE `temp_user_memory`(`user_id` bigint,`msize` double)ROW FORMAT DELIMITEDFIELDS TERMINATED BY '\t'LINES TERMINATED BY '\n'STORED AS INPUTFORMAT'org.apache.hadoop.mapred.TextInputFormat'OUTPUTFORMAT'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'LOCATION's3://AKI....APiN@forall/weihl/u/i'; 写HiveSQL 1234567891011121314[hadoop@bd-master-00 guosong]$ more r.sqluse tmp;selectsum(t2.msize)from(selectdistinctt1.user_idfromtemp_user_id t1) t3inner jointemp_user_memory t2ont3.user_id = t2.user_id; 运行HiveSQL 1hive -f sum.sql hive输出结果： 1234567891011121314151617181920212223242526272829303132[hadoop@bd-master-00 guosong]$ hive -f sum.sqlLogging initialized using configuration in file:/etc/hive/conf.dist/hive-log4j.propertiesOKTime taken: 0.043 secondsQuery ID = hadoop_20160503181212_571d477d-2610-4a50-abf6-779eeb7b026aTotal jobs = 1Launching Job 1 out of 1Number of reduce tasks determined at compile time: 1In order to change the average load for a reducer (in bytes):set hive.exec.reducers.bytes.per.reducer=&lt;number&gt;In order to limit the maximum number of reducers:set hive.exec.reducers.max=&lt;number&gt;In order to set a constant number of reducers:set mapreduce.job.reduces=&lt;number&gt;Starting Job = job_1460542469374_69993, Tracking URL = http://ip-10-30-24-68.cn-north-1.compute.internal:20888/proxy/application_1460542469374_69993/Kill Command = /usr/lib/hadoop/bin/hadoop job -kill job_1460542469374_69993Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 12016-05-03 18:12:46,948 Stage-1 map = 0%, reduce = 0%2016-05-03 18:12:59,349 Stage-1 map = 13%, reduce = 0%, Cumulative CPU 8.03 sec2016-05-03 18:13:02,455 Stage-1 map = 27%, reduce = 0%, Cumulative CPU 11.29 sec2016-05-03 18:13:05,600 Stage-1 map = 40%, reduce = 0%, Cumulative CPU 14.51 sec2016-05-03 18:13:07,666 Stage-1 map = 100%, reduce = 0%, Cumulative CPU 16.76 sec2016-05-03 18:13:15,947 Stage-1 map = 100%, reduce = 100%, Cumulative CPU 18.58 secMapReduce Total cumulative CPU time: 18 seconds 580 msecEnded Job = job_1460542469374_69993MapReduce Jobs Launched:Stage-Stage-1: Map: 1 Reduce: 1 Cumulative CPU: 18.58 sec HDFS Read: 692 HDFS Write: 16 SUCCESSTotal MapReduce CPU Time Spent: 18 seconds 580 msecOK9.8070625201E10Time taken: 39.05 seconds, Fetched: 1 row(s)]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模拟MySQL IO线程]]></title>
    <url>%2F2015-10-15-mo-ni-mysql-ioxian-cheng%2F</url>
    <content type="text"><![CDATA[1.前言近期在看mydumper以及mysqlbinlog api的代码，发现MySQL从库同步这块也不是想象中那么复杂，故将其中的代码抽离出来，完成此篇博文。 在网上搜到沃趣科技的博客MYSQL BINLOG相关源码浅析，值得推荐，本文重点在于IO线程这块。 2. REGISTER_SLAVE从库注册流程，需要发送包信息包括如下:http://dev.mysql.com/doc/internals/en/com-register-slave.html 12345678910111 [15] COM_REGISTER_SLAVE4 server-id1 slaves hostname lengthstring[$len] slaves hostname1 slaves user lenstring[$len] slaves user1 slaves password lenstring[$len] slaves password2 slaves mysql-port4 replication rank4 master-id 对应的代码： 1234567891011121314151617181920212223242526int register_slave(MYSQL *conn)&#123;uchar buf[1024];uchar *pos = buf;uchar *unix_sock = 0;long default_start_pos = 4;int server_id = 1;//4bytes server-idint4store(pos, server_id); pos+= 4;pos= net_store_data(pos, (uchar*) hostname, strlen(hostname));pos= net_store_data(pos, (uchar*) username, strlen(username));pos= net_store_data(pos, (uchar*) passwd, strlen(passwd));int2store(pos, (uint16) port);pos += 2;int4store(pos, /* rpl_recovery_rank */ 0);pos += 4;int4store(pos, 0);pos += 4;if (simple_command(conn, COM_REGISTER_SLAVE, buf, (size_t)(pos - buf), 0))return ERR_FAIL;return ERR_OK;&#125; 这步执行之后，只能在主库上看到一个连接。 3.BinlogDUMP发起BinlogDump命令，需要包括如下信息：http://dev.mysql.com/doc/internals/en/com-binlog-dump.html 123451 [12] COM_BINLOG_DUMP4 binlog-pos2 flags4 server-idstring[EOF] binlog-filename 对应的代码： 123456789101112131415161718192021void start_dump(MYSQL *conn)&#123;const char *binlog_name = "mysql-bin.000002";size_t offset = 107;uchar buf[1024];char *binlog_pos;ushort binlog_flags = 0;int server_id = mysql_thread_id(conn) -1000;size_t binlog_name_length;conn-&gt;status = MYSQL_STATUS_READY;int4store(buf, offset);int2store(buf + 4, binlog_flags);int4store(buf + 6, server_id);binlog_name_length = strlen(binlog_name);memcpy(buf + 10, binlog_name, binlog_name_length);simple_command(conn, COM_BINLOG_DUMP, buf, binlog_name_length + 10, 1);&#125; 这里面比较简单，设置固定的binlog同步点。 4.读取EVENT5.Demo代码已经放在Git上binlog.c，编译放在makefile中。]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mydumper源码分析]]></title>
    <url>%2F2015-10-13-mydumperyuan-ma-fen-xi%2F</url>
    <content type="text"><![CDATA[前言记录和研究mydumper的过程，包括使用方法、源码研究以及源码中涉及的模块库函数。 编译安装使用的版本是mydumper-0.6.2 12cmake -DCMAKE_BUILD_TYPE=Debug .make 根据README需要安装一些依赖遇到找不到hash.h头文件： 123456789[root@typhoeus81 mydumper_sina]# make[ 20%] Building C object CMakeFiles/mydumper.dir/binlog.c.oIn file included from /data1/mydumper_sina/binlog.c:27:/data1/guosong/mysql5616/include/sql_common.h:26:18: error: hash.h: No such file or directoryIn file included from /data1/mydumper_sina/binlog.c:27:/data1/guosong/mysql5616/include/sql_common.h:37: error: expected specifier-qualifier-list before ‘HASH’make[2]: *** [CMakeFiles/mydumper.dir/binlog.c.o] Error 1make[1]: *** [CMakeFiles/mydumper.dir/all] Error 2make: *** [all] Error 2 参照这个buglist解决这个问题：http://bugs.mysql.com/bug.php?id=70672 测试实例运行命令: 1./mydumper -h 10.75.19.81 -P 9001 -u test -p test123 -B dbtest1 -T tb1 -o ./backup --lock-all-tables -L mydumper.test.log -v 3 日志输出： 12345678910111213141516[root@typhoeus81 mydumper-0.6.2]# more mydumper.test.log2015-10-13 16:33:26 [INFO] - Connected to a MySQL server2015-10-13 16:33:26 [INFO] - TokuDB detected, creating dummy table for CS2015-10-13 16:33:26 [INFO] - Started dump at: 2015-10-13 16:33:262015-10-13 16:33:26 [INFO] - Written master status2015-10-13 16:33:26 [INFO] - Written slave status2015-10-13 16:33:26 [INFO] - Thread 1 connected using MySQL connection ID 23684862015-10-13 16:33:26 [INFO] - Thread 2 connected using MySQL connection ID 23684872015-10-13 16:33:26 [INFO] - Thread 3 connected using MySQL connection ID 23684882015-10-13 16:33:26 [INFO] - Thread 4 connected using MySQL connection ID 23684892015-10-13 16:33:26 [INFO] - Thread 1 dumping schema for `dbtest1`.`tb1`2015-10-13 16:33:26 [INFO] - Thread 3 shutting down2015-10-13 16:33:26 [INFO] - Thread 1 shutting down2015-10-13 16:33:26 [INFO] - Thread 2 shutting down2015-10-13 16:33:26 [INFO] - Finished dump at: 2015-10-13 16:33:26 目录结构： 12345[root@typhoeus81 mydumper-0.6.2]# ll backup/total 12-rw-r--r-- 1 root root 181 Oct 13 16:33 dbtest1.tb1-schema.sql-rw-r--r-- 1 root root 525 Oct 13 16:33 dbtest1.tb1.sql-rw-r--r-- 1 root root 183 Oct 13 16:33 metadata 参数解析使用glib库的g_option_context_parse进行参数解析，分为两个部分的参数，common_entries包括host、port、user、passwd等，entries包括其他的，例如output_dir等 1234567g_option_group_add_entries(main_group, entries);g_option_group_add_entries(main_group, common_entries);g_option_context_set_main_group(context, main_group);if (!g_option_context_parse(context, &amp;argc, &amp;argv, &amp;error)) &#123; g_print ("option parsing failed: %s, try --help\n", error-&gt;message); exit (EXIT_FAILURE);&#125; 使用glib解析参数的简单例子： 1234567891011121314151617181920212223242526272829303132# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;glib.h&gt;/*Programe options */char *hostname = NULL;guint port = 3306;GOptionEntry common_entries[] =&#123; &#123;"host", 'h', 0, G_OPTION_ARG_STRING, &amp;hostname, "The host to connect to", NULL&#125;, &#123;"port", 'P', 0, G_OPTION_ARG_INT, &amp;port, "TCP/IP port to connect to", NULL&#125;,&#125;;int main(int argc, char *argv[])&#123; GError *error = NULL; GOptionContext *context; context = g_option_context_new("glib option test"); GOptionGroup *main_group = g_option_group_new("main", "Main options", "Main options",NULL, NULL); g_option_group_add_entries(main_group, common_entries); g_option_context_set_main_group(context, main_group); if (!g_option_context_parse(context, &amp;argc, &amp;argv, &amp;error))&#123; g_print ("option parsing failed: %s, try --help\n", error-&gt;message); exit (EXIT_FAILURE); &#125; g_option_context_free(context); return 0;&#125; makfile文件： 123test:test.cgcc -g -c test.c -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/includegcc -o test test.o -lglib-2.0 依赖的库以及包通过pkg-config命令获取： 12[root@typhoeus81 20151013]# pkg-config --cflags --libs glib-2.0-I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include -lglib-2.0 GLib主要参照这个博客浅析GLib main函数main函数除了参数解析部分以及根据参数创建相关目录外，核心功能如下： 12345678910111213141516if (daemon_mode) &#123; #ifdef WITH_BINLOG GThread *bthread= g_thread_create(binlog_thread, GINT_TO_POINTER(1), FALSE, &amp;terror); #endif start_scheduled_dump= g_async_queue_new(); GThread *ethread= g_thread_create(exec_thread, GINT_TO_POINTER(1), FALSE, &amp;terror); // Run initial snapshot run_snapshot(NULL); m1= g_main_loop_new(NULL, TRUE); g_main_loop_run(m1);&#125; else &#123; MYSQL *conn= create_main_connection(); start_dump(conn);&#125; start_dumpcreate_main_connection()函数是创建连接，并进行perl正则表达式的一些检测。PCRE - Perl-compatible regular expressions, 因此关键还在于start_dump。 设置timeout时间: 12SET SESSION wait_timeout = 2147483SET SESSION net_write_timeout = 2147483 长连接处理 / We check SHOW PROCESSLIST,and if there’re queries larger than preset value,we terminate the process.This avoids stalling whole server with flush / 通过show processlist来判断是否有长查询，如果有长查询则退出dump，可以通过–long-query-guard加长时间，或者使用–kill-long-queries杀掉长查询。大概代码如下： 1234567891011int longquery= 60;int killqueries= 0;if (row[tcol] &amp;&amp; atoi(row[tcol])&gt;longquery) &#123; if (killqueries) &#123; mysql_query(conn,p3=g_strdup_printf("KILL %lu",atol(row[icol]))) &#125;else&#123; //报错退出 exit(EXIT_FAILURE); &#125;&#125; 加锁12345 指定lock参数以及指定表参数LOCK TABLE %s READ 没有指定lock参数FLUSH TABLES WITH READ LOCK 记录同步点write_snapshot_info函数,执行SHOW MASTER STATUS 以及SHOW SLAVE STATUS 产生3个消息队列(线程ready队列、任务队列、myisam表处理完毕队列)。 12345678910conf.queue = g_async_queue_new();conf.ready = g_async_queue_new();conf.unlock_tables= g_async_queue_new();for (n=0; n&lt;num_threads; n++) &#123; td[n].conf= &amp;conf; td[n].thread_id= n+1; threads[n] = g_thread_create((GThreadFunc)process_queue,&amp;td[n],TRUE,NULL); g_async_queue_pop(conf.ready);&#125; dump_database两个GList 12innodb_tables :保存Innodb以及Tokudb的表non_innodb_table： 保存非Innodb表 4.6 dump_table4.7 dump_schema4.8 process_queue线程的处理函数是process_queue 12345threads[n] = g_thread_create((GThreadFunc)process_queue,&amp;td[n],TRUE,NULL);dump_table_data_file(MYSQL *conn, char *database, char *table, char *where, char *filename)guint64 rows_count = dump_table_data(conn, (FILE *)outfile, database, table, where, filename); 1234567891011121314151617for(;;) &#123; .... job=(struct job *)g_async_queue_pop(conf-&gt;queue); .... switch (job-&gt;type) &#123; case JOB_DUMP: .... dump_table_data_file(thrconn, tj-&gt;database, tj-&gt;table, tj-&gt;where, tj-&gt;filename); .... case JOB_DUMP_NON_INNODB: .... dump_table_data_file(thrconn, tj-&gt;database, tj-&gt;table, tj-&gt;where, tj-&gt;filename); case JOB_SCHEMA: .... dump_schema_data(thrconn, sj-&gt;database, sj-&gt;table, sj-&gt;filename); &#125;&#125; 典型的生产者（主线程）消费者（子线程）模式，子线程会从任务队列里读取需要处理的表名字和表类型，再通过1SELECT /*!40001 SQL_NO_CACHE */ * FROM `dbtest1`.`tb1` 读入数据各自写入到各自的文件。 引用 MYDUMPER的使用和源代码分析 浅析GLib GLIB参考手册]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-replication-listener]]></title>
    <url>%2F2015-10-08-mysql-replication-listener%2F</url>
    <content type="text"><![CDATA[mysql-replication-listener背景介绍同步binlog的C++ API，最开始发现是在MHA作者的博客看到的Making slave pre-fetching work better with SSD 加速SQL线程预取数据的作用。本文记录自己测试过程以及一些源码分析,主要参考mysql-replication-listener代码位置 安装编译安装参照README文件 1234export MYSQL_DIR=&lt;path of mysql directory or libmysql&gt;cmake .cmake -DCMAKE_BUILD_TYPE=Debug //便于熟悉代码进行调试，编译的时候可以加上这个参数make -j4 前提是已经装好cmake以及boost 安装遇到的问题 error: ‘MYSQL_TYPE_TIME2’ was not declared in this scope参照这个链接解决:https://bugs.mysql.com/bug.php?id=71681 测试12345[root@typhoeus81 examples]# ./basic-1 file:///data1/guosong/mysql5616/data/mysql-bin.000001Start read eventFound event of type 116 at 889193472Start read eventEndif 123456789101112131415161718192021222324252627282930#include "binlog_api.h"using mysql::Binary_log;using mysql::system::create_transport;int main(int argc, char** argv) &#123; if (argc != 2) &#123; std::cerr &lt;&lt; "Usage: basic-2 &lt;uri&gt;" &lt;&lt; std::endl; exit(2); &#125; Binary_log binlog(create_transport(argv[1])); binlog.connect(); binlog.set_position(4); Binary_log_event *event; while (true) &#123; std::cout &lt;&lt; "Start read event"&lt;&lt; std::endl; int result = binlog.wait_for_next_event(&amp;event); if (result != ERR_OK)&#123; std::cout &lt;&lt; "Endif"&lt;&lt; std::endl; break; &#125; std::cout &lt;&lt; "Found event of type " &lt;&lt; event-&gt;get_event_type() &lt;&lt; " at "&lt;&lt; binlog.get_position() &lt;&lt; std::endl; &#125;&#125; 疑问: binlog.get_position()函数获取的位置输出太大，和实际位置不符合。 源码分析 MySQL binlog API 实现过程解析 Google Doc Binlog API High-Level Description 官方文档 WL#3283: C/C++ API to binary log以下分析基于这篇博客，主要工作是格式化一下以及补充自己的理解。 代码分析由Mats Kindahl开发的mysql Replication Listener是一个基于STL/Boost的C++动态库，它提供了一组api函数可以从本地的binlog文件，或则通过网络方式获取binlog文件的具体内容。 mysql Replication Listener获取到的最小单位是binlog event，即mysql执行各种操作所产生的事件： Query eventRotate eventFormat eventTable map event 使用binlog api之前首先需要创建一个连接，输入的参数有两种类型： 本地binlog文件，形如：file:///path/to/binlog/filemysql的服务器：形如：mysql://username[:password]@ip:port两类参数分别使用了不同的过程来获取binlog event。分别对这两种实现进行说明. 读取本地binlog文件的实现src/file_driver.cpp文件中封装了对本地文件的全部操作过程。 connect函数连接过程的原理是，通过判断文件的头四个个字节是不是{0xfe, 0x62, 0x69, 0x6e}来判断输入的文件是不是一个binary log文件。 123456789101112131415int Binlog_file_driver::connect()&#123; char magic[]= &#123;0xfe, 0x62, 0x69, 0x6e, 0&#125;; char magic_buf[MAGIC_NUMBER_SIZE]; // Check if the file can be opened for reading. m_binlog_file.open(m_binlog_file_name.c_str(), ios::in | ios::binary); // Check if a valid MySQL binlog file is provided, BINLOG_MAGIC. m_binlog_file.read(magic_buf, MAGIC_NUMBER_SIZE); if(memcmp(magic, magic_buf, MAGIC_NUMBER_SIZE)) return ERR_FAIL; // Not a valid binlog file.......&#125; disconnect函数直接关闭binlog文件。 12345int Binlog_file_driver::disconnect()&#123; m_binlog_file.close(); return ERR_OK;&#125; set_position函数通过seek函数将读写指针设置到指定的位置。 1m_binlog_file.seekg(position, ios::beg ); get_position函数返回binlong文件当前的读写位置。 12345int Binlog_file_driver::get_position(string *str, ulong *position)&#123; if(position) *position= m_binlog_file.tellg();&#125; wait_for_next_event()**该函数首先从binlog文件中读取一个event_log header长度的数据块，hearder的数据结构是 123456789101112 define LOG_EVENT_HEADER_SIZE 20class Log_event_header&#123;public:uint8_t marker; // always 0 or 0xFFuint32_t timestamp;uint8_t type_code;uint32_t server_id;uint32_t event_length;uint32_t next_position;uint16_t flags;&#125;; 读取方式如下： 123456789101112131415161718192021if(m_bytes_read &lt; m_binlog_file_size &amp;&amp; m_binlog_file.good())&#123;//Protocol_chunk&lt;uint8_t&gt; prot_marker(m_event_log_header.marker);Protocol_chunk&lt;uint32_t&gt; prot_timestamp(m_event_log_header.timestamp);Protocol_chunk&lt;uint8_t&gt; prot_type_code(m_event_log_header.type_code);Protocol_chunk&lt;uint32_t&gt; prot_server_id(m_event_log_header.server_id);Protocol_chunk&lt;uint32_t&gt;prot_event_length(m_event_log_header.event_length);Protocol_chunk&lt;uint32_t&gt;prot_next_position(m_event_log_header.next_position);Protocol_chunk&lt;uint16_t&gt; prot_flags(m_event_log_header.flags);m_binlog_file &gt;&gt; prot_timestamp&gt;&gt; prot_type_code&gt;&gt; prot_server_id&gt;&gt; prot_event_length&gt;&gt; prot_next_position&gt;&gt; prot_flags;*event= parse_event(* static_cast&lt;std::istream*&gt; (&amp;m_binlog_file),&amp;m_event_log_header);&#125; m_event_log_header是Log_event_header类型，具体结构上面已经给出。 根据type_code的值来判断是什么样的event事件，然后根据不同event事件读取不同长度的文件内容，同时构造一个相应事件的数据结构填充其内容并返回。读完一个事件长度的内容后将文件的读写指针置于该事件内容的末尾，开始下一个事件的读取，直到文件的末尾。 1m_binlog_file.seekg(m_bytes_read + m_event_log_header.event_length,ios::beg); 函数的调用层次关系如下: create_transport(argv[1]) -&gt; parse_file_url(const char *body, size_t length) -&gt; Binlog_file_driver(body + 2) binlog.connect() -&gt; Binlog_file_driver::connect(const std::string &amp;filename, ulong position) binlog.wait_for_next_event(&amp;event) -&gt; int Binlog_file_driver::wait_for_next_event(mysql::Binary_log_event **event) 3.1.2 读取mysql服务器binlog文件的实现该实现采用网络通信的方式来获取mysql服务器上的binlog信息，通信过程完全采用了mysql网络通信协议的格式，并且使用的是boost::asio::io_servie服务作为通信的基础。 123456789[root@typhoeus81 test]# ./basic-1 mysql://test:test123@10.75.19.81:9001Start read eventFound event of type 4 at 0Start read eventFound event of type 15 at 107Start read eventFound event of type 2 at 246Start read eventFound event of type 2 at 314 对应的MySQL实例可以看到一个BinlogDump线程： 123456789*************************** 3. row ***************************Id: 2284460User: testHost: 10.75.19.81:33253db: NULLCommand: Binlog DumpTime: 13State: Master has sent all binlog to slave; waiting for binlog to be updatedInfo: NULL 在create_transport(const char *url)函数返回是Binlog_tcp_driver对象。 12345/* Port number is stored in portno, either the default, or a parsed one */return new Binlog_tcp_driver(std::string(user, user_end - user),std::string(pass, pass_end - pass),std::string(host, host_end - host),portno); Binlog_tcp_driver类中封装了整个操作过程的实现。src/tcp_driver.h文件中定义了所有的对外接口。下面分别对比较重要的接口进行说明。 1. connect() 12345int Binlog_tcp_driver::connect(const std::string&amp; user,const std::string&amp; passwd,const std::string&amp; host, uint port,const std::string&amp; binlog_filename,size_t offset) 该函数封装了另一个网络连接函数connect(user, passwd, host, port, binlog_filename, offset)。从字面意思可以看出6个参数的含义。 也支持指定binlog_filename以及offset 1int connect(const std::string &amp;binlog_filename, ulong offset); (1) mysql_init创建连接 1m_mysql= mysql_init(NULL); mysql_init文档说明https://dev.mysql.com/doc/refman/5.6/en/mysql-init.html &gt;Allocates or initializes a MYSQL object suitable for mysql_real_connect(). If mysql is a NULL pointer, the function allocates, initializes, and returns a new object. Otherwise, the object is initialized and the address of the object is returned. (2) sync_connect_and_authenticate将相关信息封装在buf内，然后进行身份验证，验证完成发送一个COM_REGISTER_SLAVE命令。 1simple_command(conn, COM_REGISTER_SLAVE, buf, (size_t) (pos - buf), 0) (3) start_binlog_dump(binlog_file, m_binlog_offset)这个函数核心是下面这个函数： 1simple_command(m_mysql, COM_BINLOG_DUMP, buf, binlog_name_length + 10, 1); 这个函数在include/sql_common.h文件中有宏定义, 是MySQL源生态的函数: 123 define simple_command(mysql, command, arg, length, skip_check) \(*(mysql)-&gt;methods-&gt;advanced_command)(mysql, command, 0, \0, arg, length, skip_check, NULL) 2. setposition() 123456int Binary_log::set_position(ulong position)&#123;std::string filename;m_driver-&gt;get_position(&amp;filename, NULL);return this-&gt;set_position(filename, position);&#125; 通过get_position调用fetch_master_status函数执行show master status获取当前的binlog位置点，然后再执行本身对象的set_position。 123456789101112131415161718192021222324Binlog_tcp_driver::set_position(const std::string &amp;str, ulong position)&#123;MYSQL *mysql= mysql_init(NULL);...int err= sync_connect_and_authenticate(mysql, m_user, m_passwd, m_host, m_port);//权限认证成功之后//执行show binary logs获取所有binlog点if (fetch_binlog_name_and_size(mysql, &amp;binlog_map))return ERR_MYSQL_QUERY_FAIL;//根据这个map进行判断请求点是否正确，否则错误std::map&lt;std::string, unsigned long&gt;::iterator binlog_itr= binlog_map.find(str);if (binlog_itr == binlog_map.end())return ERR_FAIL;if (position &gt; binlog_itr-&gt;second)return ERR_FAIL;//断开当前的连接disconnect();//根据实际点再重新连接一下if (connect(m_user, m_passwd, m_host, m_port, str, position))return ERR_CONNECT;&#125; 3.get_position()该函数获取mysql服务器当前正在使用的binlog文件名和当前的偏移量。实现步骤如下： 连接mysql服务端，并进行身份验证。调用的函数是sync_connect_and_authenticate。 获取mysql服务端当前使用的binlog文件名和偏移量。调用的函数为fetch_master_status。 fetch_master_status是执行show master status获取当前的binlog位置点，然后赋值driver类的两个变量。 4.start_binlog_dump()发送给主库COM_BINLOG_DUMP命令，主库开启BinlogDump线程。buf中封装同步点以及server_id信息 1simple_command(m_mysql, COM_BINLOG_DUMP, buf, binlog_name_length + 10, 1); 5.wait_for_next_event()构建完成binlogdump线程之后，就可以从server中读取一个数据包，通过下面的函数 12345len= cli_safe_read(m_mysql);//这个函数功能如下：//Read a packet from server. Give error message if socket was down//or packet is an error message 先接收到的是数据包的头部，根据头部中的长度信息读取整个包体的内容。 一个完整的包体对应的是一个binlog event，所以可以分析它是属于一个什么事件，并构造一个对应的event数据结构，使用包体中的信息填充其各个字段。 1*event_ptr= parse_event(is, m_waiting_event); 这里面还需要细化,还没有看懂 3.1.3 目录结构参照这个文档https://docs.google.com/document/d/1kZt5qcAflc8aORC7SEly-LdPz0n1t-dXlTEu1_zO8vI/edit 123456789101112131415161718192021222324252627282930313233343536# Listener user interfacebinlog_api.hbinary_log.cppbinlog_driver.h# Transport factoryaccess_method_factory.cppaccess_method_factory.h# Content handlersbasic_content_handler.hbasic_content_handler.cpp# Binlog interfacesbinlog_event.cppbinlog_event.hfield_iterator.cppfield_iterator.h# Row set and value interfacesvalue.cppvalue.hrow_of_fields.cpprow_of_fields.hrowset.h# MySQL interfacesprotocol.cppprotocol.hresultset_iterator.cppresultset_iterator.htcp_driver.cpptcp_driver.h# Misc utilitiesbounded_buffer.h 3.3备注 存在一个python版本的https://code.launchpad.net/~mkindahl/mysql-replicant-python/trunk]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重启SaltMinion导致MySQL Crash]]></title>
    <url>%2F2015-08-28-zhong-qi-saltminiondao-zhi-mysql-crash%2F</url>
    <content type="text"><![CDATA[前言 分析重启SaltMinon导致MySQL Crash原因，包括SaltMinion重启过程、KillThread导致对应进程Crash原因分析以及验证、pid和ThreadId分配规则以及最后给出原因解释。 Salt-Minion重启过程Kill Thread导致对应的进程Crashkill 和 kill -9方式1234567pstree -n -p |grep mysql|less|-mysqld_safe(18573)---mysqld(20122)-+-&#123;mysqld&#125;(20134)| |-&#123;mysqld&#125;(20135)| |-&#123;mysqld&#125;(20136)| |-&#123;mysqld&#125;(20137)| |-&#123;mysqld&#125;(20138)...... 进行两种kill的模拟 mysqld_safe作用验证将下面的代码保存在test.c文件中： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;pthread.h&gt;void *thread_func()&#123; printf("thread create\n"); sleep(100000); printf("thread ended\n");&#125;int main()&#123; pthread_t tid; int rc = pthread_create(&amp;tid, NULL, thread_func, NULL); pthread_join(tid, NULL); printf("pthread_id = %d\n", tid); return 0;&#125; 编译： 12gcc -g -c test.cgcc -o test test.o -lpthread 模拟发现kill 和kill -9输出结果 本质原因在于SaltMinion重启和MySQL的thread相重合，kill之后导致MySQL Crash。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[服务器负载那些事]]></title>
    <url>%2F2015-08-26-fu-wu-qi-fu-zai-na-xie-shi%2F</url>
    <content type="text"><![CDATA[CPU你不一定懂的cpu显示信息 IOMemoryNetLinux相关工具]]></content>
      <categories>
        <category>Linux Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化]]></title>
    <url>%2F2015-08-25-mysqlyou-hua%2F</url>
    <content type="text"><![CDATA[前言汇总各种比较好的优化博客，便于在遇到实际问题的时候查看，包括优化准则、美团的索引博文、Join优化。 优化准则12345678910111213L1 cache reference 0.5 nsBranch mispredict 5 nsL2 cache reference 7 nsMutex lock/unlock 100 nsMain memory reference 100 nsCompress 1K bytes with Zippy 10,000 nsSend 2K bytes over 1 Gbps network 20,000 nsRead 1 MB sequentially from memory 250,000 nsRound trip within same datacenter 500,000 nsDisk seek 10,000,000 nsRead 1 MB sequentially from network 10,000,000 nsRead 1 MB sequentially from disk 30,000,000 nsSend packet CA-&gt;Netherlands-&gt;CA 150,000,000 ns http://highscalability.com/numbers-everyone-should-know 美团《MySQL索引原理及慢查询优化》http://tech.meituan.com/mysql-index.html MySQL索引背后的数据结构及算法原理http://blog.codinglabs.org/articles/theory-of-mysql-index.html Join优化Join优化原则 查询所返回的结果集，通常查询返回的结果集很少，是有信心进行优化的；驱动表的选择至关重要，通过查看执行计划，可以看到优化器选择的驱动表从执行计划中的rows可以大致反映出问题的所在；理清各表之间的关联关系，注意关联字段上是否有合适的索引；使用straight_join关键词来强制表之间的关联顺序，可以方便我们验证某些猜想； 主要参照这篇博客复杂关联SQL的优化]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阿里数据库相关视频分享]]></title>
    <url>%2F2015-08-24-a-li-shu-ju-ku-xiang-guan-shi-pin-fen-xiang%2F</url>
    <content type="text"><![CDATA[阿里分布式数据库(DRDS\TDDL)实践 视频链接http://v.youku.com/v_show/id_XODMyMzk2OTUy.html pdf链接http://vdisk.weibo.com/s/CW6y_n6-bJqB/1416312608 DBFree-阿里数据库自动化运维平台 视频链接http://v.youku.com/v_show/id_XNjUyNzExNjky.html?from=s1.8-1-1.2 ppt链接http://wenku.baidu.com/view/6237edf8960590c69ec3765a.html]]></content>
      <categories>
        <category>业界技术分享汇总</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python模块汇总]]></title>
    <url>%2F2015-08-12-pythonmo-kuai-hui-zong%2F</url>
    <content type="text"><![CDATA[前言 汇总在开发过程中使用到所有Python模块，记录起来方便日后使用。 prettytable ascii_graph prettytable功能实现python console的数据格式化，按照表格的方式输出。 1.2 演示 1.3 代码demo12345678910111213141516 !/usr/bin/env python2.7 -*- coding:utf8 -*-from prettytable import PrettyTabletable = PrettyTable(["animal", "ferocity"])table.add_row(["wolverine", 100])table.add_row(["grizzly", 87])table.add_row(["Rabbit of Caerbannog", 110])table.add_row(["cat", "中文中文中文中文中文中"])table.add_row(["platypus", 23])table.add_row(["dolphin", 63])table.add_row(["albatross", 44])table.sort_key("ferocity")table.reversesort = Trueprint table 如果使用颜色的话，得使用shell的方式 123color = "\033[94m&#123;value&#125;\033[0m"value = "中文"value = color.format(value=value) ##ascii_graph 功能将数据打印输出成直方图的形式 演示 代码Demo12345678910111213141516from ascii_graph import Pyasciigraphfrom ascii_graph.colors import * Simple coloringtest = [('testval0', 600),('testval1', 500, Pur),('testval2', 400, Red),('testval3', 400, Red),('testval4', 300, Gre),('testval5', 200, Yel),('testval6', 100, Cya),('testval7', 50, Blu) ]graph = Pyasciigraph()for line in graph.graph('test graph', test):print(line) 参考资料 http://code.google.com/p/prettytable/ https://py-ascii-graph.readthedocs.org/en/latest/]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL内存使用情况]]></title>
    <url>%2F2015-08-10-mysqlnei-cun-shi-yong-qing-kuang%2F</url>
    <content type="text"><![CDATA[内存使用情况统计MySQL内存有两个组成部分，全局和线程级别的。本文分析一下具体的情况，哪些是全局内存，哪些是Session级别的内存。 下图是一个示例： 参考资料 https://dev.mysql.com/doc/refman/5.5/en/memory-use.html https://www.percona.com/blog/2006/05/17/mysql-server-memory-usage/ https://www.percona.com/blog/2014/01/24/mysql-server-memory-usage-2/]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Epoll模型]]></title>
    <url>%2F2015-08-04-epollmo-xing%2F</url>
    <content type="text"><![CDATA[Epoll模型讲解（转）首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。不管是文件，还是套接字，还是管道，我们都可以把他们看作流。 之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？ 阻塞 Epoll：阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）,那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你)。非阻塞忙轮询 select : 接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：”你到了没?”结论:很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。缓冲区为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。 例子假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”。也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。 这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。 然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）： 123456while true &#123; for i in stream[]; &#123; if i has data read until unavailable &#125;&#125; 我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。 为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样: 1234567while true &#123; select(streams[]) for i in streams[] &#123; if i has data read until unavailable &#125;&#125; 于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，没一次无差别轮询时间就越长。再次说了这么多，终于能好好解释epoll了。 epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）在讨论epoll的实现细节之前，先把epoll的相关操作列出： 12345678epoll_create 创建一个epoll对象，一般epollfd = epoll_create()epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件比如epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//注册缓冲区非空事件，即有数据流入epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//注册缓冲区非满事件，即流可以被写入epoll_wait(epollfd,...)等待直到注册的事件发生（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。 一个epoll模式的代码大概的样子是： 123456while true &#123; active_stream[] = epoll_wait(epollfd) for i in active_stream[] &#123; read or write till &#125;&#125; 结合APUE上介绍 待更新….. 参考资料 我读过最好的Epoll模型讲解 UNIX环境高级编程——epoll函数使用详解]]></content>
      <categories>
        <category>Unix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Innodb内部结构]]></title>
    <url>%2F2015-07-30-innodbnei-bu-jie-gou%2F</url>
    <content type="text"><![CDATA[资料来源 逐篇阅读Jeremy Cole大拿的bloghttp://blog.jcole.us/innodb/进行记录汇总。 官方的Internals https://dev.mysql.com/doc/internals/en/index.html 两个结合在一起看。 Innodb记录结构123456CREATE TABLE `test4` (`id` int(11) NOT NULL AUTO_INCREMENT,`data` int(11) NOT NULL DEFAULT '1',`data2` varchar(255) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 表t包括6个列，而不是3个列，额外的看不到的列是row ID、transaction ID以及rollback pointer。 插入如下记录： 12345678910+-------+------+--------+| id | data | data2 |+-------+------+--------+| 1 | 0 | NULL || 2 | 0 | b || 3 | 0 | b || 4 | 0 | b || 10 | 1 | NULL || 11 | 2 | TTTTT |+-------+------+--------+ 使用hexdump -C 读取ibd文件，下面一个片段： 12345678910111213141516171819200000c000 8e 35 7e a9 00 00 00 03 ff ff ff ff ff ff ff ff |.5~.............|0000c010 00 00 00 00 69 d8 c7 00 45 bf 00 00 00 00 00 00 |....i...E.......|0000c020 00 00 00 00 01 1a 00 02 01 26 80 08 00 00 00 00 |.........&amp;......|0000c030 01 0c 00 02 00 05 00 06 00 00 00 00 00 00 00 00 |................|0000c040 00 00 00 00 00 00 00 00 01 f7 00 00 01 1a 00 00 |................|0000c050 00 02 00 f2 00 00 01 1a 00 00 00 02 00 32 01 00 |.............2..|0000c060 02 00 1b 69 6e 66 69 6d 75 6d 00 07 00 0b 00 00 |...infimum......|0000c070 73 75 70 72 65 6d 75 6d 01 00 00 10 00 1c 80 00 |supremum........|0000c080 00 01 00 00 00 00 82 6b 99 00 00 01 40 00 84 80 |.......k....@...|0000c090 00 00 00 01 00 00 00 18 00 1d 80 00 00 02 00 00 |................|0000c0a0 00 00 82 6b 99 00 00 01 40 00 91 80 00 00 00 62 |...k....@......b|0000c0b0 01 00 00 00 20 00 1d 80 00 00 03 00 00 00 00 82 |.... ...........|0000c0c0 6b 99 00 00 01 40 00 9e 80 00 00 00 62 01 00 00 |k....@......b...|0000c0d0 00 28 00 1c 80 00 00 04 00 00 00 00 82 6b 99 00 |.(...........k..|0000c0e0 00 01 40 00 ab 80 00 00 00 62 01 00 00 30 00 1c |..@......b...0..|0000c0f0 80 00 00 0a 00 00 00 00 82 91 ae 00 00 01 9b 00 |................|0000c100 84 80 00 00 01 05 00 00 00 38 ff 64 80 00 00 0b |.........8.d....|0000c110 00 00 00 00 82 93 b0 00 00 01 9d 00 84 80 00 00 |................|0000c120 02 54 54 54 54 54 00 00 00 00 00 00 00 00 00 00 |.TTTTT..........|0000c130 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 如何找到记录的开始位置： infimum和supremum是两个具体的英文单词 对应的16个进制为infimum 69 6e 66 69 6d 75 6d supremum 73 75 70 72 65 6d 75 6d 28个字节 123456789101112131415&gt;&gt;&gt; import binascii&gt;&gt;&gt; binascii.b2a_hex('i')'69'&gt;&gt;&gt; binascii.b2a_hex('n')'6e'&gt;&gt;&gt; binascii.b2a_hex('f')'66'&gt;&gt;&gt; binascii.b2a_hex('i')'69'&gt;&gt;&gt; binascii.b2a_hex('m')'6d'&gt;&gt;&gt; binascii.b2a_hex('u')'75'&gt;&gt;&gt;hex(1024*3)'0xc00' 使用py_innodb_page_type 123456789101112page offset 00000000, page type &lt;File Space Header&gt;page offset 00000001, page type &lt;Insert Buffer Bitmap&gt;page offset 00000002, page type &lt;File Segment inode&gt;page offset 00000003, page type &lt;B-tree Node&gt;, page level &lt;0000&gt;page offset 00000000, page type &lt;Freshly Allocated Page&gt;page offset 00000000, page type &lt;Freshly Allocated Page&gt;Total number of page: 6:Freshly Allocated Page: 2Insert Buffer Bitmap: 1File Space Header: 1B-tree Node: 1File Segment inode: 1 总共6个page，文件大小是96KB，innodb单个页面大小为16KB，故也是6个page 参考资料http://www.cnblogs.com/zhoujinyi/archive/2012/10/17/2726462.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac快捷键图标]]></title>
    <url>%2F2015-07-29-mackuai-jie-jian-tu-biao%2F</url>
    <content type="text"><![CDATA[Mac图标对于mac的图标总是记不太住，在这里记录一下，便于查找。 更多图标参照参考的第2个链接。 参考资料 https://support.apple.com/zh-cn/HT201236 https://support.apple.com/kb/PH18802?locale=zh_CN&amp;viewlocale=zh_CN]]></content>
      <categories>
        <category>Mac</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在Intellij IDEA中配置golang]]></title>
    <url>%2F2015-07-22-zai-intellij-ideazhong-pei-zhi-golang%2F</url>
    <content type="text"><![CDATA[环境搭建参照下面的博客完成在Intellij IDEA中配置golangIntelliJ IDEA 14安装Golang插件go-lang-idea-plugin。 由于系统上之前已经安装好go和IDEA，现在将两者结合起来，本博客记录整个配置的过程。 下载插件在https://github.com/go-lang-plugin-org/go-lang-idea-plugin上下载插件。 配置生成intellij-go.jar包1、将下载的go-lang-idea-plugin压缩包解压，IDEA点击File -&gt; open 打开该工程。 2、点击File -&gt; Project Structure 打开项目结构配置窗口： 3、设置Project SDK点击File -&gt; Project Structure -&gt;Project，设置Project SDK为刚刚设置好的IDEA sdk 4、编译生成jar包点击Build-&gt;Prepare All Plugins For Deployment，选择intellij-go.jar包 安装插件在Perference中选择Plugins 手动安装intellij-go.jar包 设置Go SDK选择go的HOME Demo 命令行运行Go程序]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[信号量扑捉]]></title>
    <url>%2F2015-07-14-xin-hao-liang-bu-zhuo%2F</url>
    <content type="text"><![CDATA[1、背景多个平台共同使用一台中控机，由于某个部门运行python脚本的bug，导致机器压力过大无法登陆，解决的方案就是重启机器，由于是部署的crontab任务，机器启动之后很快有不行了。其他部门的同学在没有通知的情况，使用一个死循序kill掉所有和python相关的运行程序。由于没有周知其他部门的同学，其他部门同学随便运行一个python脚本都会被kill。 由此引发一个问题就是如何找出被kill程序对应的源程序呢？ 2、信号量 kill -9 和 kill -15的区别？？ kill -9 对应的信号量是SIGKILL， kill -15对应的信号量是SIGTERM SIGKILL是否可以扑捉？测试信号量SIGKILL1234567891011 ! /usr/bin/env python2.6import signalimport time, osdef handler(signum, frame):print 'Signum = %d' % signumret = signal.getsignal(signum)print os.getpid(),os.getppid()signal.signal(signal.SIGKILL, handler)signal.pause() 运行的时候会出现如下的错误： 12345[root@typhoeus79 20150714]# python2.6 signal.pyTraceback (most recent call last):File &quot;signal.py&quot;, line 11, in &lt;module&gt;signal.signal(signal.SIGKILL, handler)RuntimeError: (22, &apos;Invalid argument&apos;) 从这个链接中可以看到SIGKILL的说明，http://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html The SIGKILL signal is used to cause immediate program termination. It cannot be handled or ignored, and is therefore always fatal. It is also not possible to block this signal.SIGKILL和SIGSTOP是不能被捕获以及忽略的信号，是向管理员提供可以杀死任一进程的可靠方法。 SIGTERM默认会将未关闭的IO流关闭之后再退出。将上面的代码改成捕捉SIGTERM，输出结果为：[root@typhoeus79 20150714]# python2.6 signal.pySignum = 1514412 24840 根据ppid查看对应的进程为： 12345[root@typhoeus79 20150714]# readlink /proc/24840/exe/bin/bash[root@typhoeus79 20150714]# readlink /proc/24840/cwd/[root@typhoeus79 20150714]# readlink /proc/24840/cwd/data1/guosong/opdir/20150714 进行kill进程的话，还是使用kill -15的方式。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL的server_id出现相同情况的案例分析]]></title>
    <url>%2F2015-07-08-mysqlde-server-idfen-xi%2F</url>
    <content type="text"><![CDATA[问题经常会问到主从server_id相同会怎么样？从库之间server_id相同会怎么样？A-&gt;B-&gt;C结构下，如果A和C的server_id相同又会怎么样？ 主从server_id相同启动start slave 之后，出现错误： Last_IO_Errno: 1593Fatal error: The slave I/O thread stops because master and slave have equal MySQL server ids; these ids must be different for replication to work (or the –replicate-same-server-id option must be used on slave but this does not always make sense; please check the manual before using it). 两个从库之间存在server_id相同主库上的Binlog Dump线程会替换成新的从库ip，且Binlog Dump的Time时间是变化，主库没有任何写入。 另一个从库的状态是出现一个非常大的延迟。 源码分析从库server_id相同的情况彭立勋的博客MySQL多个Slave同一server_id的冲突原因分析 ，这里给出代码的解释，如果从库之间的server_id出现相同的情况，从库进行COM_REGISTER_SLAVE的时候会到hash表中按照server_id为key进行先删除已经存在的slave，然后再重新注册。由于从库都有重试的机制，故其中断又重新导致其他的被kill掉，然后再反复，故我们看到的现象就是出现server_id的两个从库同步状态是时断时续的。 主从server_id相同的情况sql/sql_parse.cc 解析start slave的命令12345678910113101 case SQLCOM_SLAVE_START:3102 &#123;3103 mysql_mutex_lock(&amp;LOCK_active_mi);3104 if (active_mi != NULL)3105 res= start_slave(thd, active_mi, 1 /* net report*/);3106 else3107 my_message(ER_SLAVE_CONFIGURATION, ER(ER_SLAVE_CONFIGURATION),3108 MYF(0));3109 mysql_mutex_unlock(&amp;LOCK_active_mi);3110 break;3111 &#125; sql/rpl_slave.cc中的get_master_version_and_clock函数 start_slave() -&gt; start_slave_threads() -&gt; handle_slave_io() -&gt; get_master_version_and_clock() 判断主从server_id是否相同的地方123456789101112131415161919 if (!mysql_real_query(mysql,1920 STRING_WITH_LEN("SHOW VARIABLES LIKE 'SERVER_ID'")) &amp;&amp;1921 (master_res= mysql_store_result(mysql)) &amp;&amp;1922 (master_row= mysql_fetch_row(master_res)))1923 &#123;1924 if ((::server_id == (mi-&gt;master_id= strtoul(master_row[1], 0, 10))) &amp;&amp;1925 !mi-&gt;rli-&gt;replicate_same_server_id)1926 &#123;1927 errmsg= "The slave I/O thread stops because master and slave have equal \1928 MySQL server ids; these ids must be different for replication to work (or \1929 the --replicate-same-server-id option must be used on slave but this does \1930 not always make sense; please check the manual before using it).";1931 err_code= ER_SLAVE_FATAL_ERROR;1932 sprintf(err_buff, ER(err_code), errmsg);1933 goto err;1934 &#125; gdb调试MySQL编译安装的时候使用 -DWITH_DEBUG=bool, 参照这个Compiling MySQL for Debugging gdb运行的时候，需要指定特定的配置文件，使用的方式如下： 1gdb --args ./bin/mysqld --defaults-file=/data1/guosong/mysql5616/etc/my5616.cnf 更多参照这个链接Debugging a MySQL Server 打印临时变量出现添加编译选项-O0，意思是不进行编译优化，gdb在默认情况下会使用-O2。使用-O0选项调试的时候就会顺畅了,发布项目的时候不用再使用 -O0参数项，gcc 默认编译或加上-O2优化编译会提高程序运行速度。 查看CMakeLists.txt文件中发现大量使用-O1参数，故修改所有-O1为-O0就可以打印完整的变量。 1234567(gdb) p next_rec$1 = (const rec_t *) 0x4 &lt;Address 0x4 out of bounds&gt;(gdb) p next_rec$2 = (const rec_t *) 0x7fff6e000070 "supremum"(gdb) p next_rec_heap_no$3 = 1(gdb) c (待补充)]]></content>
      <categories>
        <category>MySQL内核</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[supervisord配置使用总结]]></title>
    <url>%2F2015-06-12-supervisordpei-zhi-shi-yong-zong-jie%2F</url>
    <content type="text"><![CDATA[背景之前搭建公司内部的API系统，tornado server的守护进程使用supervisord进行管理，故当时就supervisord进行学习，并整理成相关文档。 supervisord总结文档这里不在重复贴出，给出个百度网盘的链接:使用supervisor守护Python进程.pdf 密码:msxb]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python单元测试]]></title>
    <url>%2F2015-06-08-pythondan-yuan-ce-shi%2F</url>
    <content type="text"><![CDATA[背景公司内部使用Salt进行配置管理工作，通过Salt-master的client执行相关命令，鉴于内部其他系统会使用到Salt服务，为了避免每个都ssh到Salt-master执行命令，故之前负责Salt的同学使用django框架对这些常用的命令进行HTTP API的封装。 目前总共32个接口，现在由于各种问题，需要迁移到Tornado的框架中。32个接口手动测试有点麻烦，故此研究一下python单元测试，这些可以为了后续对代码的改进，避免重复手动测试工作。 Python单元测试主要是看了如下几个博客： (1). 廖雪峰博客的单元测试 (2). Python单元测试框架 (3). python2.7手册 (4). Python自动单元测试框架 (5). Unit Testing with Python Demo1——来自博客1123456789101112131415 !/usr/bin/env python -*- coding:utf8 -*-class Dict(dict): def __init__(self, **kw): super(Dict, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r"'Dict' object has no attribute '%s'" % key); def __setattr__(self, key, value): self[key] = value Dict类，这个类的行为和dict一致，但是可以通过属性来访问，保存为mydict.py。 1234567891011121314151617181920212223242526272829303132333435363738394041424344 !/usr/bin/env python -*-coding:utf8 -*-import unittestfrom mydict import Dictclass TestDict(unittest.TestCase):"""测试类，从unittest.TestCase继承以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。""" def test_init(self): d = Dict(a=1, b= 'test'); self.assertEquals(d.a, 1) self.assertEquals(d.b, 'test') self.assertTrue(isinstance(d, dict)) def test_key(self): d = Dict() d['key'] = 'value' self.assertEquals(d.key, 'value') def test_attr(self): d = Dict() d.key = 'value' self.assertTrue('key' in d) def test_keyerror(self): d = Dict() with self.assertRaises(KeyError): value = d['empty'] def test_attrerror(self): d = Dict() with self.assertRaises(AttributeError): value = d.emptyif __name__ == '__main__':unittest.main() unitest.TestCase提供很多内置的条件判断，如下图，只需要调用这些方法就可以断言输出是否符合预期。 另一种重要的断言就是期望抛出指定类型的Error，例如上面的后面两个测试用例。 两个截图都来自链接3 可以将这个test.py当做正常的脚本使用main进行操作。另一种更常见的方法是通过命令行参数-m unittest直接运行单元测试： 通过命令行参数运行单元测试123456guosongdeMacBook-Air:20150608 guosong$ python -m unittest test.....----------------------------------------------------------------------Ran 5 tests in 0.000sOK 注意：脚本名称后面不同加.py后缀，否则出现错误。 setUp 和 tearDown如果想在执行每个测试用例的时候，在开始和结束的时候，执行一些操作，可以使用setUp和tearDown两个函数来实现，具体代码如下： TestDict类中重写setUp和tearDown函数123456def setUp(self): 打印当前执行测试case的方法名print 'setUp..., test_case_name = %s' % self._testMethodNamedef tearDown(self):print 'tearDown..., done' 如果setUp执行成功，那么无论runTest是否成功，tearDown方法都将被执行。上面的实现方式称为固件。 在博客2中介绍通过覆盖runTest 方法实现的方式，不过一般都不常用，具体可以参照博客2。 测试套件(test unit)测试Widget类123456789101112class Widget(object): def __init__(self, name, x=50, y=50): self.name = name self.x = x self.y = y def size(self): return (self.x, self.y) def resize(self, x, y): self.x = x self.y = y 测试用例12345678910111213141516171819202122232425import unittestfrom widget import Widgetclass WidgetTestCase(unittest.TestCase): def setUp(self): self.widget = Widget("The widget") def tearDown(self): self.widget.dispose() self.widget = None def testDefaultSize(self): assert self.widget.size() == (50,50), 'incorrect default size' size = self.widget.size() self.assertEquals(size, (50,50),'incorrect default size') def testResize(self): self.widget.resize(100, 150) size = self.widget.size() self.assertEquals(size, (100,150),'wrong size after resize') 测试组件12345678910111213141516171819202122232425def suite(): """ 测试用例实例可以根据它们所测试的特性组合起来, 这个机制称为测试套件 """ suite = unittest.TestSuite() suite.addTest(WidgetTestCase("testDefaultSize")) suite.addTest(WidgetTestCase("testResize")) """ makeSuite方法创建一个由测试用例类内所有测试用例组成的测试套件 makeSuite(testCaseClass, prefix='test', sortUsing=&lt;built-in function cmp&gt;, suiteClass=&lt;class 'unittest.suite.TestSuite'&gt;) makeSuite会做排序，基于内置的cmp函数 """suite = unittest.makeSuit(WidgetTestCase, 'test')return suiteif __name__ == '__main__': suite = suite() runner = unittest.TextTestRunner() runner.run(suite)]]></content>
      <categories>
        <category>Test</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ELK搭建过程]]></title>
    <url>%2F2015-06-03-elkda-jian-guo-cheng%2F</url>
    <content type="text"><![CDATA[背景内部系统MySQL API 每天都产生大量的日志，需要从这些日志分析接口的调用时间、请求超时、错误等趋势以及具体的接口，便于抓住重点进行分析。目前公司内部主要使用ELK进行日志分析，故在此也使用ELK进行API日志的分析。 ELK搭建过程文档 参照百度网盘上的链接http://pan.baidu.com/s/1pJKFoE3 重点根据上面的文档就可以搭建出ELK了，其中对于日志分析的重点还是写正则表达式。文档中提供Grok，在线工具非常值得推荐http://grokdebug.herokuapp.com/ 常用的patterns：https://github.com/logstash/logstash/tree/v1.4.0/patterns 可以根据的日志格式生成定义的pattern，定义好的变量可以放在${LogstashHOME}/patterns/grok-patterns文件中。 新浪使用ELK进行日志分析新浪是如何分析处理32亿条实时日志的?]]></content>
      <categories>
        <category>ELK</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tornado异步非阻塞]]></title>
    <url>%2F2015-06-02-tornadoyi-bu-fei-zu-sai%2F</url>
    <content type="text"><![CDATA[背景内部平台提供HTTP API对日常经常使用的MySQL运维操作进行封装，经过多人积累，目前平台共有 117 个 HTTP 接口,涵盖到 MySQL 操作、MySQL 实例 元数据、授权、MySQL 状态、MySQL 集群拓扑结构、主从复制、DNS、体检巡检、参数变更、短信邮件报警、监控、表结构修改等。在线上实际运行的过程，经常出现API夯住的问题。 平台的API接口基于Facebook的Tornado实现，Tornado本身是支持异步非阻塞的，但是我们在开发的时候并没有使用这一特性，故进行出现单个端口夯住导致其他请求查询实践过程。 Tornado异步非阻塞调研文档基于下面两个博客，对现有的API进行改造，实现支持异步非阻塞功能 tornado异步非阻塞 Blocking tasks in Tornado 下面给出之前本人写的《MySQLAPI 阻塞问题解决方案调研》的pdf文档，参照百度网盘的链接http://pan.baidu.com/s/1sjxA4KP 里面的关于《Apache+WSGI+Tornado的配置》文档为内部的链接，外网无法访问，故参照下面的链接http://pan.baidu.com/s/1dDq7yY9 介绍Tornado的资料本人学习的Tornado入门资料主要是《Introduction to Tornado》 英文版本的链接：http://maemual-share.qiniudn.com/Oreilly.Introduction.to.Tornado.Mar.2012.pdf 中文版本的链接:http://mirrors.segmentfault.com/itt2zh/index.html 中文版本的翻译看过，整体感觉还不错的，值得推荐，主要还是多敲上面的demo吧 Tornado和Django性能对比通过后台Salt执行获取某个ip机器上某个端口的mysql配置文件信息。构造一个测试例子文件： siege测试API并发量1234siege -c 100 -r 2 -f salt[root@typhoeus81 test]# more salthttp://sinadbp.mars.grid.sina.com.cn/sinasalt/get_mysql_conf/tgt=10.13.2.70 siege 测试Django API siege 测试Tornado API 测试结论从上面的结果上可以看到tornado的明显更为稳定，响应时间也比较快，django在高并发的情况下完全超时。]]></content>
      <categories>
        <category>Tornado</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO统计]]></title>
    <url>%2F2015-05-27-iotong-ji%2F</url>
    <content type="text"><![CDATA[1、背景线上一台Salt Master的机器压力特别大 故需要找出哪个进程在进行写操作，需要按照进程的维度统计出现IOPS的工具，故google的目录3中的一些参考资料 2、实现方式主要参照3节中第一个链接how-to-find-per-process-io-statistics-on-linux 下载iodump的脚本，这是perl写 1wget http://aspersa.googlecode.com/svn/trunk/iodump 打开内核有关IO消息的开关 1echo 1 &gt; /proc/sys/vm/block_dump 统计相关进程的IOPS 1while true; do sleep 1; dmesg -c; done | perl iodump 效果图： 3、参考资料 How to Find Per-Process I/O Statistics on Linux MySQL数据库SYS CPU高的可能性分析]]></content>
      <categories>
        <category>Linux Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GDB学习笔记]]></title>
    <url>%2F2015-05-11-learning-gdb%2F</url>
    <content type="text"><![CDATA[GDB概述GDB主要帮忙你完成下面四个方面的功能： 1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。 2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式） 3、当程序被停住时，可以检查此时你的程序中所发生的事。 4、动态的改变你程序的执行环境。 GDB分析corefilecorefile产生系统设置1234[root@qbj3-op-sre-test-00 guosong]# ulimit -c1024[root@qbj3-op-sre-test-00 guosong]# ulimit -acore file size (blocks, -c) 1024 Demo 源码 1234567891011121314151617181920[root@qbj3-op-sre-test-00 guosong]# more test.c #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int crash()&#123; char *xxx = "crash!!"; xxx[1] = 'D'; // 写只读存储区! return 2;&#125;int foo()&#123; return crash();&#125;int main()&#123; return foo();&#125; 编译 1gcc -g -o test test.c 需要添加-g参数，可以进行debug 执行test产生core文件。 分析core 123456789[root@qbj3-op-sre-test-00 guosong]# gdb test ./core.21740 Core was generated by `./test&apos;.Program terminated with signal 11, Segmentation fault.#0 0x0000000000400501 in crash () at test.c:77 xxx[1] = &apos;D&apos;; // 写只读存储区!(gdb) bt#0 0x0000000000400501 in crash () at test.c:7#1 0x0000000000400519 in foo () at test.c:13#2 0x0000000000400529 in main () at test.c:18 参考资料陈皓的博客-用GDB调试程序 http://blog.csdn.net/haoel/article/details/2879]]></content>
      <categories>
        <category>GDB</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python类操作符重载]]></title>
    <url>%2F2015-05-04-python-operator-overload%2F</url>
    <content type="text"><![CDATA[前言在Python中如何实现操作符重载，本文研究记录一下。 Demo12345678910111213class Object(): def __setattr__(self, n, v): if n == 'age': self.__dict__[n] = v print 'setattr' def __getattr__(self, n): if n == 'age': return self.__dict__[n]obj = Object()obj.age = 2print obj.age 输出： 12setattr2 除了上面的set和get，还有sum、add等等，可以参照下文的链接。 参考资料 Operator Overloading in Python 所有的操作符数据模型]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
</search>
